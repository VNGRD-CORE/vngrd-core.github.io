<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:; img-src * data: blob: 'unsafe-inline'; connect-src * 'unsafe-inline';">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
   <title>DRIS//CORE VNGRD</title>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="src/Compositor.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800;900&family=JetBrains+Mono:wght@300;400;500&family=Bebas+Neue&family=Russo+One&display=swap');
        
        :root { 
            --accent: #00f3ff; --accent-dim: rgba(0, 243, 255, 0.2); --accent-glow: rgba(0, 243, 255, 0.5);
            --p: #ff0055; --c: #00f3ff; --g: #00ff88; --y: #ffcc00; --r: #ff3333; --o: #ff9d00; --v: #b000ff;
            --bg: #050508; --panel: #08080c; --panel-light: #0c0c12; --border: #151520; --border-light: #202030;
            --text: #a0a0a8; --text-dim: #505058; --text-bright: #e8e8ec;
        }
        
        body.theme-magenta { --accent: #ff0055; --accent-dim: rgba(255,0,85,0.2); --accent-glow: rgba(255,0,85,0.5); }
        body.theme-green { --accent: #00ff88; --accent-dim: rgba(0,255,136,0.2); --accent-glow: rgba(0,255,136,0.5); }
        body.theme-purple { --accent: #b000ff; --accent-dim: rgba(176,0,255,0.2); --accent-glow: rgba(176,0,255,0.5); }
        body.theme-gold { --accent: #ffd700; --accent-dim: rgba(255,215,0,0.2); --accent-glow: rgba(255,215,0,0.5); }
        body.theme-night { --accent: #334455; --accent-dim: rgba(51,68,85,0.2); --bg: #020204; --panel: #040408; }

        /* --- WEB DNA KILL SWITCH --- */
        * { 
            box-sizing: border-box; margin: 0; padding: 0; 
            -webkit-user-select: none;
            user-select: none;
            -webkit-user-drag: none;
        }
        
        /* CURSOR: NORMAL BY DEFAULT */
        body { cursor: default; }
        .btn, button { cursor: pointer; }
        input[type="range"] { cursor: ew-resize; }
        input[type="text"] { cursor: text; }
        
        /* CURSOR: CROSSHAIR ONLY IN SHOOTING MODE */
        body.shooting-mode { cursor: crosshair; }
        body.shooting-mode #stage { cursor: crosshair !important; }
        body.shooting-mode .sidebar { cursor: default; }
        body.shooting-mode .sidebar .btn { cursor: pointer; }

        /* GPU PROMOTION - THE ENGINE CORE */
        #sys-log, #stage, .sidebar {
            will-change: transform;
            backface-visibility: hidden;
            transform: translate3d(0,0,0);
        }
        
        /* OPTIMIZED DRAGGING - NO TRANSITION DURING DRAG */
        .dragging {
            transition: none !important;
            pointer-events: auto !important;
        }
        
        /* Hide helper class */
        .hidden { display: none !important; }
        
        /* Hide Scrollbars Globally */
        ::-webkit-scrollbar { display: none; }
        html, body { 
            scrollbar-width: none; 
            -ms-overflow-style: none; 
            overflow: hidden; 
            height: 100vh; width: 100vw; 
            background: var(--bg); color: var(--text); 
            font-family: 'JetBrains Mono', monospace; 
            font-size: 12px; 
            overscroll-behavior: none; 
            touch-action: none; 
            transition: background 0.1s linear; 
        }

        input, textarea { 
            user-select: text; 
            cursor: text !important; 
        }

        /* SYSTEM FAILURE MODE (REPLACES PSYCHOSIS STROBE) */
        body.system-failure {
            animation: system-failure-anim 4s infinite linear;
            background: #000 !important;
        }
        body.system-failure .sidebar, body.system-failure #top-bar, body.system-failure #bottom-bar {
            border-color: var(--r) !important;
        }
        body.system-failure * {
            color: var(--r) !important;
            text-shadow: 2px 0 var(--c), -2px 0 var(--y);
        }
        @keyframes system-failure-anim {
            0% { transform: skewX(0deg) scale(1); filter: hue-rotate(0deg); }
            20% { transform: skewX(2deg) scale(1.02); filter: hue-rotate(90deg) contrast(1.5); }
            40% { transform: skewX(-2deg) scale(0.98); filter: hue-rotate(180deg) invert(0.1); }
            60% { transform: skewX(1deg); filter: hue-rotate(270deg) blur(2px); }
            80% { transform: skewX(-1deg); filter: hue-rotate(300deg); }
            100% { transform: skewX(0deg) scale(1); filter: hue-rotate(360deg); }
        }

        /* PARTY MODE CONSOLE GLOW - RESTORED LIGHT PLAY */
        body.party-active .sidebar, body.party-active header, body.party-active footer {
            animation: console-breathe 0.5s infinite alternate;
        }
        @keyframes console-breathe {
            0% { border-color: var(--c); box-shadow: inset 0 0 5px rgba(0, 243, 255, 0.1); }
            100% { border-color: var(--v); box-shadow: inset 0 0 15px rgba(176, 0, 255, 0.2); }
        }

        /* NEW LOGO ANIMATIONS */
        .logo { font-family: 'Orbitron', sans-serif; font-size: 36px; font-weight: 900; letter-spacing: -2px; color: #fff; transition: all 0.05s ease; }
        .logo:hover { transform: scale(1.02); filter: brightness(1.1); text-shadow: 4px 4px 0px var(--accent-dim); }
        
        #main-logo span { animation: core-flicker 4s infinite; display:inline-block; }
        @keyframes core-flicker { 
            0%, 90% { opacity: 0.6; color: var(--accent); transform: skewX(0deg); }
            92% { opacity: 1; color: #fff; transform: skewX(-20deg); }
            94% { opacity: 0.6; color: var(--accent); transform: skewX(0deg); }
            96% { opacity: 0; }
            98% { opacity: 1; color: var(--r); }
            100% { opacity: 0.6; color: var(--accent); }
        }

        .logo.m1 { color: #00f3ff; text-shadow: 0 0 20px #00f3ff; animation: pulse-glow 2s infinite; }
        .logo.m2 { color: #ff0055; text-shadow: 2px 2px 0px #fff; animation: glitch-text 0.3s infinite; }
        .logo.m3 { background: linear-gradient(90deg, #00f3ff, #ff0055, #00ff88); -webkit-background-clip: text; color: transparent; animation: gradient-slide 3s linear infinite; }
        .logo.m4 { color: transparent; -webkit-text-stroke: 1px #fff; animation: hollow-pulse 1s infinite alternate; }
        .logo.m5 { color: #fff; text-shadow: 2px 0 #f00, -2px 0 #0ff; animation: chromatic-shake 0.2s infinite; }
        .logo.m6 { background: linear-gradient(180deg, #fff, #555); -webkit-background-clip: text; color: transparent; opacity: 0.8; }

        @keyframes pulse-glow { 0%,100% { opacity: 1; filter: drop-shadow(0 0 5px var(--accent)); } 50% { opacity: 0.8; filter: drop-shadow(0 0 15px var(--accent)); } }
        @keyframes glitch-text { 0% { transform: translate(0,0); } 20% { transform: translate(-2px, 2px); } 40% { transform: translate(-2px, -2px); } 60% { transform: translate(2px, 2px); } 80% { transform: translate(2px, -2px); } 100% { transform: translate(0,0); } }
        @keyframes gradient-slide { 0% { background-position: 0% 50%; background-size: 200% 200%; } 100% { background-position: 100% 50%; background-size: 200% 200%; } }
        @keyframes hollow-pulse { from { stroke-opacity: 1; } to { stroke-opacity: 0.3; } }
        @keyframes chromatic-shake { 0% { transform: translate(1px, 0); } 50% { transform: translate(-1px, 0); } 100% { transform: translate(1px, 0); } }

        .sub-tag { font-size: 11px; letter-spacing: 3px; color: var(--accent); margin-left: 10px; opacity: 0.7; position: relative; display: inline-block; overflow: hidden; }
        .sub-tag::after { content: ''; position: absolute; top: 0; left: -100%; width: 50%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent); animation: vngrd-shine 8s ease-in-out infinite; }
        @keyframes vngrd-shine { 0%, 85%, 100% { left: -100%; opacity: 0; } 90%, 95% { opacity: 1; } 92% { left: 150%; } }
        .version { font-size: 10px; color: var(--accent); padding: 3px 8px; background: var(--accent-dim); border: 1px solid var(--accent); margin-left: 10px; }

        #stage { position: fixed; top: 45px; left: 200px; right: 200px; bottom: 55px; background: #000; border: 1px solid var(--border); overflow: hidden; }
        #vj-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1000; pointer-events: none !important; }
        #overlay-layer { position: absolute; inset: 0; z-index: 2000; pointer-events: none; }
        
        #stage::before { content: ""; position: absolute; inset: 0; z-index: 3000; pointer-events: none; background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.03) 2px, rgba(0,0,0,0.03) 4px); opacity: 0.3; }
        #stage::after { content: ""; position: absolute; inset: 0; z-index: 3001; pointer-events: none; background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.5) 100%); }

        body.fullscreen #stage { position: fixed; inset: 0; z-index: 9999; border: none; }
        body.fullscreen .sidebar, body.fullscreen #top-bar, body.fullscreen #bottom-bar, body.fullscreen #ghost-terminal { opacity: 0; pointer-events: none; }

        #lower-third { display: none !important; }
        .lt-container { 
            display: flex; flex-direction: column; 
            background: linear-gradient(90deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.7) 100%);
            border-left: 3px solid var(--accent); 
            padding: 12px 25px 12px 15px; 
            min-width: 280px; max-width: 400px;
            opacity: 0; transform: translateX(-20px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #lower-third.visible .lt-container { opacity: 1; transform: translateX(0); }
        .lt-title { font-family: 'Orbitron', sans-serif; font-size: 20px; font-weight: 700; color: #fff; letter-spacing: 1px; line-height: 1.2; }
        .lt-subtitle { font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; margin-top: 2px; }
        .lt-container.lt-guest { border-color: var(--c); }
        .lt-container.lt-guest .lt-subtitle { color: var(--c); }
        .lt-container.lt-track { border-color: var(--g); }
        .lt-container.lt-track .lt-subtitle { color: var(--g); }
        .lt-container.lt-breaking { border-color: var(--r); animation: lt-pulse 1s infinite; }
        .lt-container.lt-breaking .lt-subtitle { color: var(--r); }
        @keyframes lt-pulse { 0%, 100% { border-color: var(--r); } 50% { border-color: #fff; } }

        /* ========================================
           TRIPLE-STACK IDENTITY - HEADER BRAND
           ======================================== */
        #brand {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Brand Logo Slot (uploaded image) */
        #brand-logo-slot {
            max-height: 32px;
            max-width: 60px;
            object-fit: contain;
            filter: drop-shadow(0 0 8px var(--accent));
            display: none;
        }
        #brand-logo-slot.active {
            display: block;
        }
        
        /* Main Logo Text - mix-blend-mode: exclusion by default */
        #main-logo {
            mix-blend-mode: exclusion;
        }
        #main-logo.hidden { display: none; }
        
        /* Text Style Modes */
        #main-logo.style-solid {
            mix-blend-mode: normal;
            color: #fff;
            text-shadow: 0 0 15px var(--accent);
        }
        #main-logo.style-hollow {
            mix-blend-mode: normal;
            color: transparent;
            -webkit-text-stroke: 1px var(--accent);
            text-shadow: none;
        }
        #main-logo.style-inverted {
            mix-blend-mode: exclusion;
            color: #fff;
            text-shadow: none;
        }
        
        /* V29 MANUAL LAYER ELEMENTS */
       /* --- V29 INDUSTRIAL OVERRIDE (NO GLOW) --- */
 #station-bug { 
            position: absolute; top: 30px; left: 30px; z-index: 2600; 
            font-family: 'Orbitron', sans-serif; font-size: 28px; font-weight: 800; 
            
            /* CLEANUP: White text with a subtle dark lift, NO BLUE GLOW */
            color: rgba(255,255,255,0.9); 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5); 
            
            background: transparent !important; 
            border: none !important; 
            backdrop-filter: none !important;
            cursor: move;
            pointer-events: auto !important;
        }
        #station-bug.hidden { opacity: 0; pointer-events: none; }
        #station-bug img { max-height: 60px; filter: drop-shadow(0 0 10px var(--accent)); }
        
      #user-logo-layer { 
    /* POSITION & SCALE */
    position: absolute; 
    top: 30px; 
    right: 30px; 
    z-index: 2550; 
    max-width: 150px; 
    max-height: 100px; 
    object-fit: contain; 
    transform-origin: top right;
    display: none;
    cursor: move;
    pointer-events: auto !important;

    /* SURGICAL CLEANUP: NO GLOW, NO BOX */
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;

    /* REPLACED: Professional depth instead of blue neon */
    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.8)) !important;
}
        
        /* HOLOGRAM WIDGET - REACTOR CORE */
       #widget-layer {
    position: absolute;
    width: 512px;
    height: 512px;
    background: transparent !important;
    border: none !important;
    z-index: 1;
    pointer-events: none !important;
    display: block;
    opacity: 0;
}

#hologram-canvas {
    width: 100% !important;
    height: 100% !important;
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    pointer-events: none !important;
    display: block;
}

/* STRUCTURAL INTEGRITY BAR (FLAT) */
#integrity-bar {
    position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
    width: 200px; height: 6px;
    background: #111; /* Solid dark background */
    border: 1px solid var(--border-light);
    z-index: 99998; display: none;
    box-shadow: none !important;
}

#integrity-fill {
    height: 100%; width: 100%;
    /* Solid colors feel more industrial than soft gradients */
    background: var(--g); 
    transition: width 0.1s;
}

#integrity-text {
    position: absolute; top: -16px; left: 50%; transform: translateX(-50%);
    font-size: 9px; 
    color: var(--text-bright); 
    text-shadow: none !important; /* GLOW REMOVED */
    font-family: 'Orbitron', sans-serif;
}
        
        /* LENS FAILURE STATE */
        body.lens-shattered #stage { backdrop-filter: none !important; filter: none !important; }
        body.lens-shattered .glass-fracture { animation: fracture-fall 1s forwards; }
        @keyframes fracture-fall {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(120vh) rotate(720deg); opacity: 0; }
        }
        
        /* CAMERA PREVIEW BOX - INLINE SIDEBAR */
        #cam-preview-float {
            position: relative;
            width: 100%;
            aspect-ratio: 16 / 9;
            background: #000;
            border: 1px solid var(--border);
            border-radius: 2px;
            display: none;
            overflow: hidden;
            margin: 6px 0;
        }
        #cam-preview-float.active { display: block; border-color: var(--accent); }
        #cam-preview-float video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            display: block;
        }
        #cam-preview-float .preview-label {
            position: absolute;
            top: 3px;
            left: 3px;
            font-size: 7px;
            color: var(--accent);
            background: rgba(0,0,0,0.7);
            padding: 1px 5px;
            border-left: 1px solid var(--accent);
            letter-spacing: 1.5px;
            font-family: 'Orbitron', sans-serif;
        }
        #cam-preview-float .rec-indicator {
            position: absolute;
            top: 3px;
            right: 3px;
            width: 6px;
            height: 6px;
            background: var(--r);
            border-radius: 50%;
            display: none;
            animation: rec-blink 1s infinite;
        }
        #cam-preview-float .rec-indicator.on { display: block; }
        
        /* AUTO-INVERT FOR TV LEGIBILITY */
        #station-bug {
            mix-blend-mode: difference;
            color: #ffffff !important;
            background: transparent !important;
        }
        #ticker-text {
            mix-blend-mode: difference;
        }
        
        /* MIDI LEARN MODE */
        body.midi-learn-active .btn,
        body.midi-learn-active input[type="range"] {
            animation: midi-learn-pulse 0.5s infinite alternate;
        }
        @keyframes midi-learn-pulse {
            0% { box-shadow: 0 0 5px var(--v); }
            100% { box-shadow: 0 0 20px var(--v), inset 0 0 10px rgba(176,0,255,0.2); }
        }
        .midi-bound {
            position: relative;
        }
        .midi-bound::after {
            content: 'M';
            position: absolute;
            top: -4px;
            right: -4px;
            width: 12px;
            height: 12px;
            background: var(--v);
            color: #fff;
            font-size: 7px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 2px;
            z-index: 10;
        }
        

        

        
        /* REFRACTIVE GLASS SHARDS - WebGL */
        .glass-shard-webgl {
            position: absolute;
            pointer-events: none;
            backdrop-filter: blur(2px) brightness(1.2);
            -webkit-backdrop-filter: blur(2px) brightness(1.2);
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 50%, rgba(255,255,255,0.05) 100%);
            border: 1px solid rgba(255,255,255,0.3);
            mix-blend-mode: overlay;
        }
        
        /* DEPTH HOLES - Physical Console Punctures */
        .bullet-hole-depth {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, #000 0%, #111 40%, #222 70%, transparent 100%);
            box-shadow: inset 3px 3px 8px rgba(0,0,0,0.9), 
                        inset -1px -1px 4px rgba(50,50,50,0.5),
                        0 0 10px rgba(0,0,0,0.5);
            pointer-events: none;
        }

        #ghost-terminal {
            position: fixed; bottom: 70px; right: 210px;
            width: 320px; height: 220px;
            background: rgba(0,5,8,0.95);
            border: 1px solid var(--c);
            z-index: 6000; font-family: 'JetBrains Mono', monospace; font-size: 10px;
            display: none; flex-direction: column;
            box-shadow: 0 0 20px var(--accent-dim);
        }
        #ghost-terminal.active { display: flex; }
        #ghost-terminal-header { display: flex; justify-content: space-between; align-items: center; padding: 6px 10px; background: var(--accent-dim); border-bottom: 1px solid var(--border); }
        #ghost-terminal-title { font-family: 'Orbitron', sans-serif; font-size: 9px; letter-spacing: 2px; color: var(--c); }
        #ghost-terminal-status { font-size: 8px; color: var(--g); }
        #ghost-terminal-body { flex: 1; padding: 8px; overflow-y: auto; scrollbar-width: none; }
        .ghost-log { margin-bottom: 3px; line-height: 1.3; font-size: 9px; }
        .ghost-log .ts { color: var(--text-dim); margin-right: 4px; font-size: 8px; }
        .ghost-log .ai { color: var(--accent); }
        .ghost-log .user { color: #fff; }
        .ghost-log .crit { color: var(--r); }
        .ghost-log .success { color: var(--g); }
        #ghost-input-line { display: flex; border-top: 1px solid var(--border); padding: 6px 8px; }
        #ghost-prompt { color: var(--accent); margin-right: 6px; font-size: 9px; }
        #ghost-input { background: transparent; border: none; color: #fff; flex: 1; font-family: 'JetBrains Mono', monospace; font-size: 10px; outline: none; }

        #top-bar { position: fixed; top: 0; left: 0; right: 0; height: 45px; background: linear-gradient(180deg, var(--panel-light) 0%, var(--panel) 100%); border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; padding: 0 15px; z-index: 5000; }
        #brand { display: flex; align-items: center; }
        #status-bar { display: flex; align-items: center; gap: 15px; }
        .stat { display: flex; align-items: center; gap: 5px; font-size: 10px; }
        .dot { width: 7px; height: 7px; border-radius: 50%; background: var(--g); box-shadow: 0 0 6px var(--g); }
        .dot.live { background: var(--r); box-shadow: 0 0 8px var(--r); animation: dot-pulse 0.5s infinite; }
        @keyframes dot-pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }
        #clock { font-family: 'Orbitron', sans-serif; font-size: 16px; color: var(--accent); letter-spacing: 2px; }
        #tally { display: none; padding: 4px 12px; background: var(--r); color: #fff; font-size: 10px; font-weight: bold; letter-spacing: 2px; animation: tally-blink 1s infinite; }
        @keyframes tally-blink { 0%,100% { opacity: 1; } 50% { opacity: 0.6; } }
        /* NEW RECORDING INDICATOR IN HEADER */
        #rec-status { display: none; padding: 4px 12px; background: var(--r); color: #fff; font-size: 10px; font-weight: bold; letter-spacing: 2px; animation: rec-header-blink 1s infinite; border-radius: 2px; }
        @keyframes rec-header-blink { 0%,100% { opacity: 1; box-shadow: 0 0 10px var(--r); } 50% { opacity: 0.3; box-shadow: none; } }
        
        .badge { display: flex; align-items: center; gap: 5px; padding: 3px 8px; border: 1px solid; font-size: 9px; transition: all 0.2s; }
        .badge:hover { box-shadow: 0 0 10px currentColor; }
        #fps-badge { border-color: var(--g); color: var(--g); background: rgba(0,255,136,0.05); }
        #cycle-badge { border-color: var(--y); color: var(--y); background: rgba(255,204,0,0.05); display: none; }
        #cycle-badge.on { display: flex; }

        .sidebar { position: fixed; top: 45px; bottom: 55px; width: 200px; background: var(--panel); border: 1px solid var(--border); overflow-y: auto; z-index: 4000; scrollbar-width: none; transition: border-color 0.4s ease, box-shadow 0.4s ease; }
        #left-panel { left: 0; border-left: none; border-right: 1px solid rgba(0, 243, 255, 0.1); }
        #right-panel { right: 0; border-right: none; border-left: 1px solid rgba(0, 243, 255, 0.1); }
        .section { border-bottom: 1px solid var(--border); }
        /* SCANNING ANIMATION FOR CYCLE MODE */
        .sec-head { display: flex; align-items: center; justify-content: space-between; padding: 8px 12px; background: rgba(0,0,0,0.3); border-bottom: 1px solid var(--border); position: relative; overflow: hidden; }
        .sec-head.scanning::after {
            content: ''; position: absolute; bottom: 0; left: -100%; width: 50%; height: 2px; background: var(--y);
            box-shadow: 0 0 10px var(--y); animation: scan-line 2s linear infinite;
        }
        @keyframes scan-line { 0% { left: -50%; } 100% { left: 150%; } }

        .sec-title { font-family: 'Orbitron', sans-serif; font-size: 9px; font-weight: 600; letter-spacing: 2px; color: var(--accent); }
        .sec-dot { width: 5px; height: 5px; background: var(--g); border-radius: 50%; box-shadow: 0 0 4px var(--g); }
        .sec-dot.off { background: var(--text-dim); box-shadow: none; }
        .sec-dot.gold { background: var(--y); box-shadow: 0 0 6px var(--y); }
        .sec-body { padding: 10px 12px; }
        .sec-head.collapsible { cursor: pointer; }
        .sec-arrow { font-size: 8px; color: var(--text-dim); margin-left: 4px; transition: transform 0.2s; }
        .sec-head.collapsible.open .sec-arrow { color: var(--accent); }
        #session-lab-body, #p2p-call-body, #midi-host-body, #nft-vault-body { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; padding: 0 12px; }
        #gif-host img { position: fixed; top: 0; left: 0; width: 10px !important; height: 10px !important; opacity: 0.01 !important; z-index: -1; pointer-events: none; will-change: contents; }
        
        /* VNGRD BUTTONS - DIGITAL SNAP */
        .btn { display: block; width: 100%; padding: 8px 10px; margin-bottom: 6px; background: linear-gradient(180deg, #0f0f14 0%, #0a0a0e 100%); border: 1px solid var(--border); color: var(--text); font-family: 'JetBrains Mono', monospace; font-size: 10px; text-align: left; transition: all 0.05s step-end; }
        .btn:hover { background: linear-gradient(180deg, #151520 0%, #0f0f14 100%); color: var(--text-bright); border-color: var(--border-light); }
        .btn:active { box-shadow: inset 0 2px 10px rgba(0,0,0,0.8); transform: translateY(2px); }
        .btn.on { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 10px var(--accent-dim); }
        .btn.fx-active { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 8px var(--accent-dim), inset 0 0 4px var(--accent-dim); animation: fx-armed 1.4s ease-in-out infinite; }
        @keyframes fx-armed { 0%,100%{ box-shadow:0 0 8px var(--accent-dim),inset 0 0 4px var(--accent-dim); } 50%{ box-shadow:0 0 20px var(--accent),0 0 35px var(--accent-dim),inset 0 0 8px var(--accent-dim); } }
        .btn.active-mode { 
            background: var(--accent-dim) !important; 
            border-color: var(--accent) !important; 
            color: var(--accent) !important; 
            box-shadow: inset 0 0 15px rgba(0,243,255,0.3), 0 0 5px var(--accent);
            text-shadow: 0 0 8px var(--accent);
            font-weight: bold;
        }

        /* CYCLE TOGGLE GOLD STATE */
        .btn.cycle-active {
            border-color: var(--y) !important; color: var(--y) !important;
            box-shadow: 0 0 10px rgba(255,204,0,0.2);
            animation: cycle-pulse 2s infinite;
        }
        @keyframes cycle-pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.7; } }
        
        #btn-ui-react { animation: party-breathe 2s ease-in-out infinite; }
        #btn-ui-react.fx-active { color: #ff00ff; text-shadow: 0 0 10px #ff00ff; border-color: #ff00ff; background: rgba(255,0,255,0.1); }
        @keyframes party-breathe { 0%, 100% { color: var(--text); } 50% { color: #ff00ff; text-shadow: 0 0 8px #ff00ff; } }
        
        #btn-rumble { animation: seismic-breathe 2.5s ease-in-out infinite; }
        #btn-rumble.fx-active { color: #ff6600; text-shadow: 0 0 10px #ff6600; border-color: #ff6600; background: rgba(255,102,0,0.1); }
        #btn-punch.fx-active { color: #ff3300; text-shadow: 0 0 10px #ff3300; border-color: #ff3300; background: rgba(255,51,0,0.1); }
        @keyframes seismic-breathe { 0%, 100% { color: var(--text); } 50% { color: #ff6600; text-shadow: 0 0 6px #ff6600; } }

        #btn-psychosis { border-color: #ff00ff; color: #ff00ff; text-align: center; font-weight: bold; letter-spacing: 1px; }
        #btn-psychosis:hover { background: #ff00ff; color: #000; box-shadow: 0 0 20px #ff00ff; }
        
        .btn.panic { background: #000; border-color: #ff0000; color: #ff0000; text-shadow: 0 0 5px #ff0000; font-weight: bold; text-align: center; }
        .btn.panic:hover { background: #ff0000; color: #000; box-shadow: 0 0 20px #ff0000; }
        .btn.warn { border-color: #ff9900; color: #ff9900; text-align: center; }
        .btn.warn:hover { background: #ff9900; color: #000; }
        .btn.eject { border-color: var(--text-dim); color: var(--text); text-align: center; }
        .btn.eject:hover { border-color: #fff; color: #fff; }
        
        .btn.impact { background: linear-gradient(180deg, #1a1000 0%, #0f0800 100%); border-color: var(--o); color: var(--o); }
        .btn.donate { background: linear-gradient(180deg, #0a1a0a 0%, #051005 100%); border-color: var(--g); color: var(--g); }
        .btn.donate:hover { background: var(--g); color: #000; box-shadow: 0 0 20px var(--g); }
        
        .btn-row { display: flex; gap: 6px; }
        .btn-row .btn { flex: 1; text-align: center; }
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .btn-grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; }
        .btn-grid-3 .btn { text-align: center; font-size: 9px; padding: 6px 4px; }
        
        .audio-ctrl-row { display: flex; gap: 4px; margin-bottom: 6px; }
        .btn-compact { flex: 1; text-align: center; padding: 8px 0; }
        .btn-compact svg { display: block; margin: 0 auto; pointer-events: none; width: 10px; height: 10px; }
        
        .inp { width: 100%; padding: 7px 10px; margin-bottom: 6px; background: #040406; border: 1px solid var(--border); color: var(--text-bright); font-family: 'JetBrains Mono', monospace; font-size: 10px; }
        .inp:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 8px var(--accent-dim); }
        .lbl { font-size: 9px; color: var(--text-dim); letter-spacing: 1px; margin-bottom: 4px; text-transform: uppercase; }
        .slider-wrap { margin-bottom: 10px; }
        .slider-top { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .slider-lbl { font-size: 9px; color: var(--text-dim); }
        .slider-val { font-size: 10px; color: var(--accent); font-family: 'Orbitron', sans-serif; }
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 4px; background: var(--border); border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: var(--accent); border-radius: 2px; box-shadow: 0 0 8px var(--accent-dim); }

        /* Camera preview removed - using full stage instead */

        #audio-box { background: #000; border: 1px solid var(--border); padding: 8px; margin-bottom: 8px; border-radius: 3px; }
        #vu { display: flex; gap: 2px; height: 30px; align-items: flex-end; }
        .vu-bar { flex: 1; background: linear-gradient(to top, var(--g) 0%, var(--y) 60%, var(--r) 90%); min-height: 2px; border-radius: 1px; transition: height 0.05s; }
        #track-info { font-family: 'Orbitron', sans-serif; font-size: 9px; color: var(--y); margin-top: 6px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        .palette-grid { display: flex; gap: 6px; flex-wrap: wrap; }
        .pal { width: 26px; height: 26px; border: 2px solid var(--border); border-radius: 4px; transition: all 0.2s; }
        .pal:hover { transform: scale(1.15); }
        .pal.on { border-color: #fff; box-shadow: 0 0 10px rgba(255,255,255,0.4); }
        .pal[data-t="cyan"] { background: #00f3ff; }
        .pal[data-t="magenta"] { background: #ff0055; }
        .pal[data-t="green"] { background: #00ff88; }
        .pal[data-t="purple"] { background: #b000ff; }
        .pal[data-t="gold"] { background: #ffd700; }
        .pal[data-t="night"] { background: linear-gradient(135deg, #0a1a15, #1a1a2a); border-color: #334455; }

        #bottom-bar { position: fixed; bottom: 0; left: 0; right: 0; height: 55px; background: linear-gradient(0deg, var(--panel-light) 0%, var(--panel) 100%); border-top: 1px solid var(--border); z-index: 5000; display: flex; flex-direction: column; }
        #ticker-wrap { flex: 1; display: flex; align-items: center; background: rgba(0,0,0,0.3); border-bottom: 1px solid var(--border); overflow: hidden; }
        #ticker-label { padding: 0 12px; font-size: 8px; letter-spacing: 2px; color: var(--accent); background: var(--accent-dim); height: 100%; display: flex; align-items: center; border-right: 1px solid var(--border); }
        #ticker-scroll { flex: 1; overflow: hidden; white-space: nowrap; }
        #ticker-text { display: inline-block; padding-left: 100%; animation: scroll-ticker 60s linear infinite; font-size: 10px; display: flex; gap: 30px; }
        @keyframes scroll-ticker { 0% { transform: translateX(0); } 100% { transform: translateX(-100%); } }
        .tick-up { color: var(--g); } .tick-down { color: var(--r); }
        #info-bar { display: flex; align-items: center; justify-content: space-between; padding: 6px 15px; font-size: 9px; }
        .info-group { display: flex; gap: 20px; }
        .info-item { color: var(--text-dim); }
        .info-item span { color: var(--text); }
        .info-item .hl { color: var(--accent); }

        #sys-log { position: fixed; bottom: 55px; right: 200px; width: 220px; height: 45px; background: rgba(0,0,0,0.95); border: 1px solid var(--border); border-bottom: none; font-size: 8px; color: var(--text-dim); overflow-y: auto; padding: 5px; z-index: 4400; }
        .log-line { margin-bottom: 2px; }
        .log-line .ts { color: var(--accent); margin-right: 5px; }

        #countdown { position: absolute; inset: 0; background: rgba(0,0,0,0.95); display: none; align-items: center; justify-content: center; z-index: 5000; }
        #countdown-num { font-family: 'Orbitron', sans-serif; font-size: 140px; font-weight: 900; color: var(--accent); text-shadow: 0 0 60px var(--accent); }
        #nft-hud { position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%); z-index: 9999; background: rgba(0,0,0,0.95); border: 2px solid var(--r); padding: 15px 30px; font-family: 'Orbitron', sans-serif; display: none; text-align: center; }
        #nft-hud.active { display: block; }
        #nft-timer { font-size: 36px; color: var(--r); font-weight: 900; }
        #nft-label { font-size: 10px; color: #fff; margin-top: 5px; letter-spacing: 2px; }
        .nft-bar { width: 200px; height: 4px; background: #333; margin-top: 10px; }
        .nft-fill { height: 100%; background: var(--r); transition: width 0.1s linear; }

        .blur-reveal { position: fixed; inset: 0; backdrop-filter: blur(50px); -webkit-backdrop-filter: blur(50px); z-index: 99999; pointer-events: none; animation: material-reveal 0.5s ease forwards; }
        @keyframes material-reveal { 0% { backdrop-filter: blur(50px); opacity: 1; } 100% { backdrop-filter: blur(0px); opacity: 0; } }

        input[type="file"] { display: none; }
        body.vhs-aggressive #stage::before { background: repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(255,0,0,0.05) 1px, rgba(0,255,0,0.04) 2px, rgba(0,0,255,0.05) 3px, transparent 4px); animation: vhs-agg 0.07s steps(4) infinite; opacity: 1; }
        @keyframes vhs-agg { 0%{background-position:0 0;transform:translateX(-2px)} 25%{background-position:0 2px;transform:translateX(1px)} 50%{background-position:0 -1px;transform:translateX(3px)} 75%{background-position:0 3px;transform:translateX(-1px)} 100%{background-position:0 4px;transform:translateX(0)} }
        body.scan-tear #stage::after { background: linear-gradient(0deg,transparent 0%,transparent 48%,rgba(255,255,255,0.08) 50%,rgba(255,255,255,0.15) 51%,transparent 53%,transparent 100%); animation: scan-tear 2.2s linear infinite; }
        @keyframes scan-tear { 0%{transform:translateY(-110%)} 100%{transform:translateY(110%)} }
        body.night-vision #stage::before { background: repeating-linear-gradient(0deg,transparent,transparent 1px,rgba(0,255,68,0.06) 1px,rgba(0,255,68,0.06) 2px); opacity:1; animation: nv-flick 0.06s steps(2) infinite; }
        @keyframes nv-flick { 0%{opacity:0.7} 100%{opacity:0.95} }
        
        /* CONSOLE_HARDWARE BUTTON EFFECTS - HIGH-END GLOW AND PULSE */
        .btn {
            transition: all 0.15s ease;
            text-transform: uppercase;
            position: relative;
        }
        .btn:hover {
            box-shadow: 0 0 20px var(--accent), 0 0 40px var(--accent-dim), inset 0 0 10px var(--accent-dim);
            border-color: var(--accent);
            text-shadow: 0 0 10px var(--accent);
            animation: btn-pulse 0.4s ease-in-out infinite;
        }
        @keyframes btn-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }
        .btn.on, .btn.active-mode {
            animation: btn-active-glow 0.8s ease-in-out infinite;
        }
        @keyframes btn-active-glow {
            0%, 100% { box-shadow: 0 0 15px var(--accent); }
            50% { box-shadow: 0 0 30px var(--accent), 0 0 50px var(--accent-dim); }
        }
        
        /* METAL DENT EFFECT - PERMANENT INSET */
        .dented {
            box-shadow: inset 4px 4px 10px rgba(0,0,0,0.8), inset -2px -2px 6px rgba(30,30,30,0.5) !important;
        }
        /* --- V34 FINAL SHOOTING MODE --- */

/* 1. FORCE CROSSHAIR EVERYWHERE */
body.shooting-mode, 
body.shooting-mode * {
    cursor: crosshair !important;
}

/* 2. MAKE CONSOLE "GHOSTLY" BUT VISIBLE */
/* This allows bullets to hit the buttons instead of clicking them */
body.shooting-mode .sidebar .btn, 
body.shooting-mode .sidebar input,
body.shooting-mode .logo-layer {
    pointer-events: none !important; /* IGNORE CLICKS (So you can shoot through) */
    /* NO OPACITY CHANGE - KEEPS IT LOOKING NORMAL */
}

/* 3. THE DISARM BUTTON (MUST WORK) */
body.shooting-mode #btn-shooting {
    pointer-events: auto !important; /* CLICKABLE */
    cursor: cell !important;
    background: var(--r) !important; /* RED ALERT */
    color: #000 !important;
    font-weight: 900 !important;
    box-shadow: 0 0 20px var(--r);
    z-index: 999999;
}
        /* MACHINE_GUN SHOOTING FX */
        #btn-shooting {
            z-index: 9999 !important;
            position: relative;
        }
        .bullet-hole {
            position: fixed;
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 99999;
        }
        .bullet-hole::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle, #000 30%, #333 50%, transparent 70%);
            border-radius: 50%;
            box-shadow: inset 0 0 5px #000, 0 0 3px rgba(0,0,0,0.8);
        }
        .bullet-hole::after {
            content: '';
            position: absolute;
            top: -5px; left: -5px; right: -5px; bottom: -5px;
            background: radial-gradient(circle, transparent 40%, rgba(50,50,50,0.3) 60%, transparent 80%);
            border-radius: 50%;
        }
        .smoke-puff {
            position: fixed;
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 99998;
            background: radial-gradient(circle, rgba(150,150,150,0.6) 0%, rgba(100,100,100,0.3) 40%, transparent 70%);
            border-radius: 50%;
            animation: smoke-rise 1.5s ease-out forwards;
        }
        @keyframes smoke-rise {
            0% { opacity: 1; transform: scale(0.5) translateY(0); }
            100% { opacity: 0; transform: scale(2) translateY(-50px); }
        }
        
        /* GLASS FRACTURE - REFRACTIVE VECTORS WITH LIGHTER COMPOSITE */
        #glass-fracture-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 99997;
            mix-blend-mode: lighter;
        }
        .glass-fracture {
            position: absolute;
            pointer-events: none;
            mix-blend-mode: lighter;
        }
        .glass-fracture svg {
            overflow: visible;
            mix-blend-mode: lighter;
        }
        .fracture-line {
            stroke: rgba(200,220,255,0.9);
            stroke-width: 1.5;
            filter: drop-shadow(0 0 4px rgba(200,220,255,1)) drop-shadow(0 0 8px rgba(150,200,255,0.6));
        }
        .fracture-glow {
            stroke: rgba(255,255,255,0.4);
            stroke-width: 3;
            filter: blur(2px);
        }
        
        #shooting-overlay {
            position: fixed;
            top: 45px; left: 200px; right: 200px; bottom: 55px;
            z-index: 99990;
            pointer-events: none;
            display: none;
        }
        body.shooting-mode #shooting-overlay { display: block; pointer-events: auto; }
        
        

        

        
        
            25% { transform: translateX(1px); }
            75% { transform: translateX(-1px); }
        }
        
        @keyframes voice-flash {
            0% { filter: brightness(2.5); }
            100% { filter: brightness(1); }
        }
        .voice-flash { animation: voice-flash 0.1s ease-out; }
        
        /* SEISMIC SHAKE - BASS AND MIC REACTIVITY */
        @keyframes seismic-shake {
            0%, 100% { transform: translate(0, 0); }
            20% { transform: translate(-3px, 2px); }
            40% { transform: translate(3px, -2px); }
            60% { transform: translate(-2px, 3px); }
            80% { transform: translate(2px, -3px); }
        }
        body.seismic-active { animation: seismic-shake 0.08s infinite; }
        
    /* ═══ MIRROR COCKPIT — MOBILE ═══ */

    /* PORTRAIT LOCK OVERLAY — rotate-to-landscape gate */
    #portrait-lock {
        display: none;
        position: fixed; inset: 0; z-index: 99999;
        background: var(--bg);
        flex-direction: column; align-items: center; justify-content: center;
        gap: 24px;
        text-align: center;
    }
    #portrait-lock .lock-brand {
        font-family: 'Orbitron', sans-serif; font-weight: 900;
        font-size: clamp(28px, 8vw, 48px);
        color: var(--accent);
        text-shadow: 0 0 20px var(--accent-glow), 0 0 60px var(--accent-dim);
        letter-spacing: 0.15em;
    }
    #portrait-lock .lock-icon {
        width: 64px; height: 64px;
        border: 3px solid var(--accent);
        border-radius: 8px;
        position: relative;
        animation: lock-rotate 2s ease-in-out infinite;
    }
    #portrait-lock .lock-icon::after {
        content: ''; position: absolute;
        top: 50%; left: 50%; transform: translate(-50%,-50%);
        width: 0; height: 0;
        border-left: 12px solid var(--accent);
        border-top: 8px solid transparent;
        border-bottom: 8px solid transparent;
    }
    @keyframes lock-rotate {
        0%, 100% { transform: rotate(0deg); }
        25% { transform: rotate(90deg); }
        50% { transform: rotate(90deg); }
        75% { transform: rotate(0deg); }
    }
    #portrait-lock .lock-msg {
        font-family: 'JetBrains Mono', monospace;
        font-size: clamp(11px, 3vw, 15px);
        color: var(--text);
        letter-spacing: 0.2em;
        text-transform: uppercase;
        max-width: 80vw;
        line-height: 1.8;
    }
    #portrait-lock .lock-line {
        width: 40vw; height: 1px;
        background: linear-gradient(90deg, transparent, var(--accent), transparent);
    }

    /* Show overlay ONLY in portrait */
    @media (orientation: portrait) {
        #portrait-lock { display: flex !important; }
        body > *:not(#portrait-lock) { display: none !important; }
    }

    /* LANDSCAPE MOBILE — 1:1 desktop parity (full UI mirrored) */
    /* LANDSCAPE MOBILE — 1:1 desktop mirror, full UI, 0→1 coords intact */
    @media (max-width: 1024px) and (orientation: landscape) {
        html, body { font-size: 10px; }
        .sidebar {
            width: 200px; min-width: 160px;
            overflow-y: auto; overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }
        #stage { flex: 1; min-height: 0; }
        #top-bar { height: 36px; }
        #bottom-bar { height: 40px; }
        #sys-log { max-height: 60px; font-size: 9px; }
        #lower-third { bottom: 40px; left: 15px; }
        .lt-container { min-width: 200px; max-width: 300px; padding: 8px 16px 8px 10px; }
        .lt-title { font-size: 14px; }
        .lt-subtitle { font-size: 9px; }
    }

/* --- KINETIC SHUTTER TRANSITION --- */
.kinetic-shutter {
    animation: shutter-wipe 0.4s cubic-bezier(0.85, 0, 0.15, 1) forwards;
}

@keyframes shutter-wipe {
    0% { 
        clip-path: inset(0 0 0 0);
        transform: scale(1);
        filter: brightness(1) contrast(1);
    }
    45% { 
        clip-path: inset(0 100% 0 0); /* Horizontal wipe */
        transform: scale(1.03);
        filter: brightness(1.4) contrast(1.1);
    }
    50% { 
        clip-path: inset(0 0 0 100%); /* Reset wipe position */
    }
    100% { 
        clip-path: inset(0 0 0 0);
        transform: scale(1);
        filter: brightness(1) contrast(1);
    }
}/* --- TACTICAL FX MODULES --- */

/* --- TACTICAL FX v4.0 (FINAL POLISH) --- */

/* GLOBAL FIX: Ensure all FX overlays don't block mouse clicks */
.fx-scan::after, .fx-tear::after, .fx-bloom::after, .fx-chroma::after, .fx-punch::after {
    pointer-events: none !important;
}

/* 1. SCAN (Sharp Mechanical Scanline) */
.fx-scan {
    position: relative;
}
.fx-scan::after {
    content: ""; 
    position: absolute; 
    top: 0; left: 0; width: 100%; height: 2px;
    background: var(--c); 
    opacity: 0.4;
    box-shadow: 0 0 10px var(--c);
    animation: scan-move 2s linear infinite;
    z-index: 100;
}
@keyframes scan-move { 
    0% { top: 0%; } 
    100% { top: 100%; } 
}

/* 2. TEAR (Horizontal Data Glitch) */
.fx-tear {
    animation: tear-shake 0.2s steps(2) infinite;
}
@keyframes tear-shake {
    0% { transform: translate(3px,0) skew(1deg); filter: contrast(1.5) hue-rotate(45deg); }
    50% { transform: translate(-3px,0) skew(-1deg); filter: contrast(2) brightness(1.2); }
    100% { transform: translate(0,0); }
}

/* 3. BLOOM (Refined Thermal - Glowing but Readable) */
.fx-bloom {
    filter: brightness(1.1) contrast(1.3) saturate(1.4) !important;
    box-shadow: inset 0 0 80px rgba(0, 255, 255, 0.15);
    border: 1px solid rgba(0, 255, 255, 0.3);
}

/* 4. CHROMA (Tactical RGB Split) */
.fx-chroma {
    filter: contrast(1.1) brightness(1.05) !important;
    text-shadow: 1.5px 0 var(--r), -1.5px 0 var(--c);
}

/* 5. PUNCH (The Pulse - Momentary Impact) */
.fx-punch {
    animation: punch-pulse 0.4s cubic-bezier(0, 1, 0, 1) infinite;
}
@keyframes punch-pulse {
    0% { transform: scale(1.02); filter: brightness(1.4); }
    100% { transform: scale(1); filter: brightness(1); }
}

/* 6. HARD RESET (CRT Collapse Animation) */
@keyframes crt-collapse {
    0% { transform: scale(1, 1); filter: brightness(1); }
    40% { transform: scale(1, 0.005); filter: brightness(4); }
    50% { transform: scale(0, 0); opacity: 0; }
    90% { transform: scale(0.01, 1); opacity: 1; filter: brightness(3); }
    100% { transform: scale(1, 1); filter: brightness(1); }
}
.anim-hard-reset {
    animation: crt-collapse 0.5s cubic-bezier(0.19, 1, 0.22, 1);
}#nft-vault-list {
    display: flex; 
    overflow-x: auto; 
    gap: 10px;
    padding-bottom: 10px; /* Space for the scrollbar */
}
.nft-vault-item {
    flex: 0 0 100px; 
    opacity: 0.4; /* This dims them */
    transition: 0.3s;
    cursor: pointer;
}
.nft-vault-item:hover {
    opacity: 1; /* This "lights them up" on hover */
}</style>
</head>
<body oncontextmenu="return false;">
    <!-- PORTRAIT ORIENTATION LOCK -->
    <div id="portrait-lock">
        <div class="lock-brand">VNGRD</div>
        <div class="lock-line"></div>
        <div class="lock-icon"></div>
        <div class="lock-msg">PLEASE ROTATE FOR FULL EXPERIENCE</div>
        <div class="lock-line"></div>
    </div>

    <!-- SHOOTING_OVERLAY -->
    <div id="shooting-overlay"></div>
    

    
    <svg style="position:absolute;width:0;height:0;">
        <defs>
<!-- chromatic-ghost removed -->
            <filter id="heat-distort" x="-10%" y="-10%" width="120%" height="120%">
                <feTurbulence type="fractalNoise" baseFrequency="0.02 0.06" numOctaves="2" result="noise">
                    <animate attributeName="seed" from="0" to="100" dur="1s" repeatCount="indefinite"/>
                </feTurbulence>
                <feDisplacementMap in="SourceGraphic" in2="noise" scale="6" xChannelSelector="R" yChannelSelector="G"/>
            </filter>


        </defs>
    </svg>
    
    <!-- STRUCTURAL INTEGRITY BAR -->
    <div id="integrity-bar">
        <div id="integrity-fill"></div>
        <div id="integrity-text">INTEGRITY: 100%</div>
    </div>
    
    <div class="blur-reveal" id="blur-reveal"></div>
    
    <header id="top-bar">
        <div id="brand">
            <!-- TRIPLE-STACK IDENTITY: [Image] [Text] [Controls] -->
            <img id="brand-logo-slot" src="" alt="" style="display:none;">
            <span class="logo m1" id="main-logo">DRIS<span style="font-size:14px;font-weight:400;color:var(--accent);opacity:0.6;margin-left:2px;letter-spacing:1px">//&nbsp;CORE</span></span>
            <span class="sub-tag">VNGRD</span>
            <span class="version">V34</span>
        </div>
        <div id="status-bar">
            <div id="wallet-badge" class="badge" style="cursor:pointer;border-color:var(--o);color:var(--o);"><span class="dot off" id="wallet-dot"></span>WALLET</div>
            <div id="rec-status">REC</div>
            
            <div class="badge" id="fps-badge">FPS: <span id="fps-val">60</span></div>
            <div class="badge" id="cycle-badge">CYCLE</div>
            <div class="stat"><div class="dot" id="main-dot"></div><span id="status-text">STANDBY</span></div>
            <div id="tally">ON_AIR</div>
            <div id="clock">00:00:00</div>
        </div>
    </header>

    <main id="stage">
        <canvas id="vj-canvas"></canvas>

        <div id="glass-fracture-layer"></div>
        <div id="overlay-layer">
            <!-- V33 MANUAL LAYER SEPARATION -->
            <div id="station-bug">VNGRD</div>
            <img id="user-logo-layer" src="" alt="Logo">
            <!-- HOLOGRAM WIDGET - REACTOR CORE -->
            <div id="widget-layer">
                <canvas id="hologram-canvas"></canvas>
            </div>
            <div id="lower-third">
                <div class="lt-container lt-guest">
                    <div class="lt-title" id="lt-title-text">GUEST_NAME</div>
                    <div class="lt-subtitle" id="lt-subtitle-text">TITLE_ROLE</div>
                </div>
            </div>
        </div>
        <div id="countdown"><div id="countdown-num">3</div></div>
    </main>
    
    <!-- Camera preview moved inline into sidebar CAMERA_4K section -->

    <div id="ghost-terminal">
        <div id="ghost-terminal-header">
            <span id="ghost-terminal-title">GHOST://COMMAND_INTERFACE</span>
            <span id="ghost-terminal-status">ONLINE</span>
        </div>
        <div id="ghost-terminal-body"></div>
        <div id="ghost-input-line">
            <span id="ghost-prompt">GHOST></span>
            <input type="text" id="ghost-input" placeholder="Awaiting command..." autocomplete="off">
        </div>
    </div>

    <aside class="sidebar" id="left-panel">
        <div class="section">
            <div class="sec-head"><span class="sec-title">CAMERA_4K</span><div class="sec-dot off" id="cam-dot"></div></div>
            <div class="sec-body">
                <button class="btn" id="btn-init-cam">SENSORS ONLINE [4K]</button>
                <div id="cam-preview-float">
                    <video id="preview-vid-float" autoplay muted playsinline></video>
                    <div class="preview-label">PREVIEW</div>
                    <div class="rec-indicator" id="rec-dot-float"></div>
                </div>
                <div id="cam-ctrls" style="display:none">
                    <button class="btn" id="btn-go-live" style="color:var(--y)">GO LIVE [3-2-1]</button>
                    <div class="btn-row">
                        <button class="btn" id="btn-inject">INJECT LOOP (10s)</button>
                        <button class="btn" id="btn-mic">MIC</button>
                    </div>
                </div>
                <div id="live-ctrls" style="display:none">
                    <button class="btn rec" id="btn-rec">REC_BROADCAST</button>
                    <button class="btn" id="btn-end">END LIVE</button>
                </div>
                <button class="btn" id="btn-kill" style="display:none;color:var(--r)">SHUTDOWN CAM</button>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head" id="media-header"><span class="sec-title">MEDIA_DECK</span><div class="sec-dot off" id="media-dot"></div></div>
            <div class="sec-body">
                <button class="btn" id="btn-load-media">LOAD MEDIA</button>
                
                <div class="audio-ctrl-row">
                    <button class="btn btn-compact" id="btn-prev"><svg width="10" height="10" viewBox="0 0 12 12"><path fill="currentColor" d="M2 2h2v8H2zm2 4l6 4V2z"/></svg></button>
                    <button class="btn btn-compact" id="btn-cycle-toggle" style="flex:3; font-size:9px;">CYCLE: OFF</button>
                    <button class="btn btn-compact" id="btn-rotate"><svg width="10" height="10" viewBox="0 0 12 12"><path fill="currentColor" d="M2 10l6-4-6-4v8zm6-8v8h2V2H8z"/></svg></button>
                </div>
                <div class="slider-wrap" id="cycle-slider-wrap" style="display:none;">
                    <div class="slider-top"><span class="slider-lbl">CYCLE TIME</span><span class="slider-val" id="val-cycle">8s</span></div>
                    <input type="range" min="2" max="30" value="8" id="sl-cycle">
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">REACTIVITY</span><div class="sec-dot"></div></div>
            <div class="sec-body">
                <div class="btn-grid-3" style="margin-bottom:6px;">
                    <button class="btn" id="btn-ui-react" style="font-size:8px;">PARTY</button>
                    <button class="btn" id="btn-rumble" style="font-size:8px;">SEISMIC</button>
                    <button class="btn" id="btn-psychosis" style="font-size:8px;">FAILURE</button>
                </div>
                <button class="btn" id="btn-shooting" style="color:var(--r);border-color:var(--r);font-size:9px;">SHOOTING_BASS</button>
            </div>
        </div>

        <div class="section">
            <div class="sec-head"><span class="sec-title">COMMAND</span><div class="sec-dot"></div></div>
            <div class="sec-body">
                <div class="lbl" style="text-align:center;color:var(--r)">EMERGENCY PROTOCOLS</div>
                <div class="btn-grid">
                    <button class="btn eject" id="btn-eject">EJECT</button>
                    <button class="btn warn" id="btn-clear-deck">CLEAR</button>
                </div>
                <button class="btn panic" id="btn-panic">[ESC] PANIC KILL</button>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head collapsible"><span class="sec-title">MIDI_HOST</span><span class="sec-arrow">&#x25B8;</span><div class="sec-dot off" id="midi-dot"></div></div>
            <div class="sec-body" id="midi-host-body">
                <button class="btn" id="btn-midi">INIT WEBMIDI</button>
                <button class="btn" id="btn-midi-learn" style="color:var(--v);border-color:var(--v);">LEARN: OFF</button>
                <div id="midi-status" style="font-size:8px;color:var(--text-dim);margin-top:4px;">NO MIDI DEVICE</div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">LOWER_THIRD</span><div class="sec-dot"></div></div>
            <div class="sec-body">
                <input type="text" class="inp" id="lt-title" placeholder="Title..." value="GUEST NAME">
                <input type="text" class="inp" id="lt-sub" placeholder="Subtitle..." value="TITLE / ROLE">
                <div class="btn-grid">
                    <button class="btn" id="btn-lt-guest">GUEST</button>
                    <button class="btn" id="btn-lt-track">TRACK</button>
                    <button class="btn" id="btn-lt-breaking">BREAKING</button>
                    <button class="btn" id="btn-lt-off">OFF</button>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">IDENTITY</span><div class="sec-dot"></div></div>
            <div class="sec-body">
                <!-- STATION BUG -->
                <input type="text" class="inp" id="bug-text" placeholder="STATION_NAME..." value="VNGRD">
                <div class="btn-row">
                    <button class="btn" id="btn-set-station" style="flex:2;">SET BUG</button>
                    <button class="btn" id="btn-bug-toggle" title="Toggle Bug">[X]</button>
                </div>
                <!-- 2D LOGO -->
                <div class="btn-row" style="margin-top:6px;">
                    <button class="btn" id="btn-upload-2d" style="flex:2;">2D LOGO</button>
                    <button class="btn" id="btn-2d-x" title="Hide/Clear 2D">[X]</button>
                </div>
                <input type="file" id="file-2d-logo" accept=".png,.jpg,.jpeg,.gif,.webp" style="display:none;">
                <!-- 3D HOLOGRAM -->
                <div class="btn-row">
                    <button class="btn" id="btn-inject-3d" style="flex:2;color:var(--v);border-color:var(--v);">3D MODEL</button>
                    <button class="btn" id="btn-3d-x" title="HIDE / CLEAR 3D">[X]</button>
                </div>
                <input type="file" id="file-3d-model" accept=".stl,.obj,.glb,.gltf,.vgd,.json" style="display:none;">

            </div>
        </div>
    </aside>

    <aside class="sidebar" id="right-panel">
        <div class="section">
            <div class="sec-head"><span class="sec-title">AUDIO_ENGINE</span><div class="sec-dot off" id="audio-dot"></div></div>
            <div class="sec-body">
                <div id="audio-box">
                    <div id="vu"></div>
                    <div id="track-info">NO_TRACK</div>
                </div>
                <div class="btn-row"><button class="btn" id="btn-audio" style="flex:1;">LOAD_AUDIO</button><button class="btn" id="btn-mute-vid" style="width:32px;font-size:12px;padding:2px;" title="Toggle video audio">&#x1F50A;</button></div>
                <div class="audio-ctrl-row">
                    <button class="btn btn-compact" id="btn-prev-track"><svg width="10" height="10" viewBox="0 0 12 12"><path fill="currentColor" d="M2 2h2v8H2zm2 4l6 4V2z"/></svg></button>
                    <button class="btn btn-compact" id="btn-play-pause"><svg width="10" height="10" viewBox="0 0 12 12" id="icon-play-state"><path fill="currentColor" d="M3 2v8l7-4z"/></svg></button>
                    <button class="btn btn-compact" id="btn-next-track"><svg width="10" height="10" viewBox="0 0 12 12"><path fill="currentColor" d="M2 10l6-4-6-4v8zm6-8v8h2V2H8z"/></svg></button>
                </div>

                <div class="lbl" style="margin-top:8px;">INPUT_SIGNAL</div>
                <select class="inp" id="audio-input-select" style="width:100%;font-size:9px;padding:5px;background:var(--panel);border:1px solid var(--border);color:var(--text);">
                    <option value="">SELECT_DEVICE...</option>
                </select>
                <button class="btn" id="btn-scan-inputs" style="font-size:8px;margin-top:4px;">SCAN_DEVICES</button>
                <div id="input-level" style="height:3px;background:var(--border);margin-top:4px;">
                    <div id="input-level-bar" style="height:100%;width:0%;background:var(--g);transition:width 0.05s;"></div>
                </div>

                <div class="lbl" style="margin-top:8px;">ENGINEER_MODE</div>
                <div class="btn-grid-3">
                    <button class="btn active-mode" id="btn-stereo">STEREO</button>
                    <button class="btn" id="btn-spatial">3D_SPATIAL</button>
                    <button class="btn" id="btn-dolby" style="color:#00f3ff">DOLBY_DSP</button>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">OPTIC_STRESS</span><div class="sec-dot on"></div></div>
            <div class="sec-body">
                <div class="btn-grid">
                    <button class="btn" id="btn-night-vision" style="font-size:8px;">NIGHT_VIS</button>
                    <button class="btn" id="btn-tactical-xy" style="font-size:8px;">TACT_XY</button>
                    <button class="btn" id="btn-vhs" style="font-size:8px;">VHS_AGG</button>
                    <button class="btn" id="btn-crt" style="font-size:8px;">SCAN_TEAR</button>
                </div>
                <div class="btn-grid-3" style="margin-top:4px;">
                    <button class="btn" id="btn-stutter">STUTTER</button>
                    <button class="btn" id="btn-invert">INVERT</button>
                    <button class="btn" id="btn-crush">CRUSH</button>
                </div>
                <div class="btn-grid-3" style="margin-top:4px;">
                    <button class="btn" id="btn-trails">TRAILS</button>
                    <button class="btn" id="btn-rgb">RGB</button>
                    <button class="btn" id="btn-pixelate">PIXEL</button>
                </div>
            </div>
        </div>
        <div class="section">
            <div class="sec-head"><span class="sec-title">THEME</span><div class="sec-dot"></div></div>
            <div class="sec-body">
                <div class="palette-grid">
                    <div class="pal on" data-t="cyan"></div>
                    <div class="pal" data-t="magenta"></div>
                    <div class="pal" data-t="green"></div>
                    <div class="pal" data-t="purple"></div>
                    <div class="pal" data-t="gold"></div>
                    <div class="pal" data-t="night"></div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">SYSTEM_GEAR</span><div class="sec-dot"></div></div>
            <div class="sec-body" style="padding:0;">
                <div style="padding:6px 10px 0;">
                    <button class="btn" id="btn-reset" style="color:var(--r);border-color:var(--r);font-size:9px;">[ESC] RESET ALL</button>
                </div>
                <div class="sec-head collapsible" style="padding:5px 10px;background:rgba(0,0,0,0.15);border-top:1px solid var(--border);"><span class="sec-title" style="font-size:7px;">SESSION_LAB</span><span class="sec-arrow">&#x25B8;</span></div><span class="sec-arrow">&#x25B8;</span><div class="sec-dot"></div></div>
                <div id="session-lab-body" style="max-height:0;overflow:hidden;transition:max-height 0.3s ease;padding:0 10px;">
                <button class="btn rec" id="btn-nft-30">CAPTURE_VGD_CLIP</button>
                <button class="btn" id="btn-save-session">SAVE_SESSION</button>
                <button class="btn" id="btn-import-dna">IMPORT_VGD</button>
                <div class="btn-row">
                    <button class="btn" id="btn-projector">PROJECTOR</button>
                    <button class="btn" id="btn-vr" style="color:var(--v)">ENTER_VR</button>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head collapsible"><span class="sec-title">NFT_VAULT</span><span class="sec-arrow">&#x25B8;</span><div class="sec-dot off" id="vault-dot"></div></div>
            <div class="sec-body" id="nft-vault-body">
                <input type="text" class="inp" id="tezos-addr" placeholder="tz1... TEZOS ADDRESS (OPTIONAL)" style="font-size:7px;margin-bottom:4px;padding:3px 4px;">
                <button class="btn" id="btn-scan-nfts" style="font-size:8px;">SCAN_WALLET_ASSETS</button>
                <div id="nft-vault-list" style="max-height:60px;overflow-y:auto;font-size:8px;color:var(--text-dim);margin-top:4px;">
                    CONNECT_WALLET_FIRST
                </div>
                <div id="nft-count" style="font-size:8px;color:var(--accent);margin-top:4px;">ASSETS: 0</div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">LEXICA_NANO</span><div class="sec-dot off" id="neural-dot"></div></div>
            <div class="sec-body">
                <input type="text" class="inp" id="ai-prompt" placeholder="DESCRIBE_IMAGE..." style="font-size:9px;">
                <button class="btn" id="btn-generate-ai" style="color:var(--v);border-color:var(--v);">LEXICA GENERATE</button>
                <div id="ai-status" style="font-size:8px;color:var(--text-dim);margin-top:4px;">LEXICA_API: READY</div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head collapsible"><span class="sec-title">P2P_E2E_CALL</span><span class="sec-arrow">&#x25B8;</span><div class="sec-dot off" id="guest-dot"></div></div>
            <div class="sec-body" id="p2p-call-body">
                <div class="lbl" style="font-size:8px;margin-bottom:4px;">YOUR_CALL_ID:</div>
                <input type="text" class="inp" id="peer-id-display" readonly placeholder="CLICK_INIT_TO_GET_ID..." style="font-size:9px;text-align:center;color:var(--g);">
                <button class="btn" id="btn-copy-id" style="font-size:8px;margin-bottom:6px;">COPY_ID</button>
                
                <div class="lbl" style="font-size:8px;margin-bottom:4px;">GUEST_ID_TO_CALL:</div>
                <input type="text" class="inp" id="remote-peer-id" placeholder="PASTE_GUEST_ID..." style="font-size:9px;">
                
                <div class="btn-row" style="margin-top:6px;">
                    <button class="btn" id="btn-init-peer" style="color:var(--g)">INIT</button>
                    <button class="btn" id="btn-call-guest" style="color:var(--c)">CALL</button>
                </div>
                <button class="btn" id="btn-hangup" style="color:var(--r);border-color:var(--r);">END_CALL</button>
                <div id="call-status" style="font-size:8px;color:var(--text-dim);margin-top:4px;text-align:center;">NOT_CONNECTED</div>
            </div>
        </div>
    </aside>

    <footer id="bottom-bar">
        <div id="ticker-wrap">
            <div id="ticker-label">SYS</div>
            <div id="ticker-scroll">
                <div id="ticker-text">INITIALIZING_CRYPTO_STREAM...</div>
            </div>
        </div>
        <div id="info-bar">
            <div class="info-group">
                <div class="info-item">UP: <span id="uptime" class="hl">00:00:00</span></div>
                <div class="info-item">RES: <span id="res">3840x2160</span></div>
                <div class="info-item">Q: <span id="q-info">0</span></div>
            </div>
            <div class="info-group">
                <div class="info-item">AI: <span style="color:var(--g)">[G]_TO_SUMMON</span></div>
            </div>
        </div>
    </footer>

    <div id="sys-log"></div>
    
    <div id="nft-hud">
        <div id="nft-timer">00:00</div>
        <div id="nft-label">SYSTEM_CAPTURING</div>
        <div class="nft-bar"><div class="nft-fill" id="nft-fill"></div></div>
    </div>

    <input type="file" id="file-media" multiple accept="image/*,video/*">
    <input type="file" id="file-audio" multiple accept="audio/*">
    <input type="file" id="file-logo" accept="image/*">
    <input type="file" id="file-layer-logo" accept="image/*">
    <input type="file" id="file-vgd" accept=".vgd,.json">
    <audio id="audio-el"></audio>
    <div id="media-container" style="display:none;"></div>
    <div id="gif-host" style="position:fixed;top:0;left:0;width:10px;height:10px;z-index:-1;opacity:0.01;pointer-events:none;overflow:hidden;"></div>

<script>
const $ = id => document.getElementById(id);

// --- BROADCAST SAFE DRAG MODULE ---
function makeLogSafeDraggable(el) {
    let isDragging = false;
    let offset = { x: 0, y: 0 };

    el.addEventListener('mousedown', (e) => {
        if (e.target !== el) return; 
        isDragging = true;
        offset.x = e.clientX - el.offsetLeft;
        offset.y = e.clientY - el.offsetTop;
        el.style.borderColor = 'var(--accent)'; 
        el.style.transition = 'none'; 
    });

    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;

        const marginX = window.innerWidth * 0.10;
        const marginY = window.innerHeight * 0.10;

        let newX = e.clientX - offset.x;
        let newY = e.clientY - offset.y;

        newX = Math.max(marginX, Math.min(newX, window.innerWidth - el.offsetWidth - marginX));
        newY = Math.max(marginY, Math.min(newY, window.innerHeight - el.offsetHeight - marginY));

        el.style.left = newX + 'px';
        el.style.top = newY + 'px';
        el.style.right = 'auto'; 
        el.style.bottom = 'auto';
    });

    document.addEventListener('mouseup', () => {
        isDragging = false;
        el.style.borderColor = 'var(--border)';
        el.style.transition = 'all 0.2s';
    });

    el.ondblclick = () => {
        el.style.left = ''; el.style.top = '';
        el.style.right = '200px'; el.style.bottom = '55px';
    };
}
// --- KILL SWITCH ---
document.addEventListener('keydown', e => {
    if ((e.ctrlKey || e.metaKey) && (e.key === 's' || e.key === 'S')) { e.preventDefault(); console.log('SYS: SAVE_DISABLED'); }
});
document.ondragstart = function() { return false; };

// ══════════════════════════════════════════════════
// CACHE BUSTER — forces browser to load new logic
// ══════════════════════════════════════════════════
window.VANGUARD_VERSION = '1.0.1';
window.VANGUARD_BUILD = '2026-02-09T' + Date.now();
console.log('[VNGRD] Version ' + window.VANGUARD_VERSION + ' build ' + window.VANGUARD_BUILD);

const APP = {
    state: { isLive: false, isRecording: false, isFullscreen: false, isCycle: false, cycleTimer: null, isMobile: false, theme: 'cyan', startTime: Date.now(), psychosis: false },
    vj: { 
        brightness: 1.0, contrast: 1.0, saturation: 1.0, hue: 0, trailsEnabled: false, trailAlpha: 0.92, rgbEnabled: false, rgbIntensity: 0, rgbBassLink: false, pixelateEnabled: false, pixelSize: 1, rumbleEnabled: false, invert: false, uiReactivity: false, shakeIntensity: 0, shockwave: 0, lastBassLevel: 0, avgVol: 0, maskMode: false, glitchSnap: 0,
        seismicVelocity: 0, seismicPosition: 0, springConstant: 0.8, damping: 0.9, punchEnabled: false, punchScale: 1.0, nightVision: false, tacticalXY: false, mouseX: 0.5, mouseY: 0.5
    },
    media: { queue: [], currentIndex: -1, currentElement: null },
    fx: { stutter: false, crush: false, invert: false, echo: false, rgbSplit: 0, freezeFrame: null },
    audio: { ctx: null, analyzer: null, source: null, element: null, playlist: [], currentTrack: -1, currentTrackName: '', bassLevel: 0, vuData: new Uint8Array(32), isPlaying: false, isConnected: false, videoSource: null, videoMuted: false, kick: 0, highs: 0, spatialMode: 'stereo', panner: null, compressor: null, masterGain: null, lowShelf: null, highShelf: null, spatialInterval: null },
    projector: { window: null, stream: null, isOpen: false },
    nft: { recorder: null, chunks: [], isRecording: false, startTime: 0, duration: 30000, dnaSnapshot: null, audioDest: null },
    broadcast: { recorder: null, chunks: [], isRecording: false },
    loop: { recorder: null, chunks: [], activeUrl: null, timer: null, counter: 10 },
    guest: { peer: null, connection: null, stream: null, videoElement: null, audioSource: null, isActive: false, peerId: null },
    peer: { peer: null, call: null, localStream: null },
    wallet: { connected: false, address: null, chainId: null, nfts: [] },
    user: { assets: [] },
    nftVault: { thumbnails: [], scrollOffset: 0 },
    camera: { stream: null, recorder: null, chunks: [], mode: 'off', isRecording: false, videoEl: null, previewEl: null, micStream: null },
    render: { canvas: null, ctx: null, width: 3840, height: 2160, fps: 0, frameCount: 0, lastTime: 0, lastFpsUpdate: 0, rafId: null, scale: 1.0, pixelCanvas: null, pixelCtx: null, rgbActive: false, source: null },
    bug: { visible: true, text: 'VNGRD', image: null, textMode: 0, textVisible: true, imageVisible: false },
    layers: { logoScale: 1.0, logoSrc: null, bugScale: 1.0 },
    // IDENTITY TRINITY — three independent broadcast actors
    trinity: {
        bug:  { x: 0.015, y: 0.015, scale: 1.5, visible: true },
        logo: { x: 0.85,  y: 0.015, scale: 1.0, visible: false },
        holo: { x: 0.42,  y: 0.75,  scale: 1.0, visible: false }
    },
    lowerThird: { visible: false, preset: 'guest' },
    ui: { logoMorph: 0, morphs: ['m1','m2','m3','m4','m5','m6'] },
    ghost: { seismicEnergy: 0, nodesSecured: 0, directoryHandle: null },
    crypto: { ids: 'bitcoin,ethereum,solana,dogecoin' },
    // WEAPON_STATE_ISOLATION + STRUCTURAL_INTEGRITY
    shooting: { 
        active: false, bullets: [], audioCtx: null, 
        machineGunInterval: null, fractures: [], dents: [],
        lastX: 0, lastY: 0, tinkBuffer: null,
        lastFireTime: 0, fireThrottle: 100,
        repairTimer: null
    },
    glassIntegrity: 100,
    lensShattered: false,
    // MIDI_HOST + LEARN MODE + INSTRUMENT PASSTHROUGH
    midi: {
        access: null, inputs: [], outputs: [],
        learnMode: false, learnTarget: null,
        bindings: {}, // { noteOrCC: { element, target, type } }
        passthrough: false,
        synthCtx: null, synthOsc: null, synthGain: null
    },
    // Phase 1: Compositor (Iron-Clad Recorder Engine)
    compositor: null,
    // Phase 3: Web3 Sovereign DNA
    web3: { provider: null, signer: null, address: null, isConnected: false, mode: 'guest' },
    // Phase 5: Layer Saver
    layerSaver: { textureReady: false, fontReady: false, audioReady: false, allReady: false },
    vr: null,
    // PRO-AUDIO: 48kHz RAW
    inputDevices: { 
        list: [], selectedId: null, stream: null, analyzer: null,
        sampleRate: 48000, echoCancellation: false, noiseSuppression: false, autoGainControl: false
    },
    // TRANSUDATE_ATMOSPHERE_ENGINE
    atmosphere: { 
        voiceReact: false, intensity: 50, heatIntensity: 0,
        rainDrops: [], rainInterval: null,
        canvas: null, ctx: null, temperature: null,
        latitude: null, longitude: null, city: 'UNKNOWN', country: '',
        weatherCode: null, metar: '', isRaining: false,
        refractionCanvas: null, refractionCtx: null,
        midiOverride: false
    },


    // HOLOGRAM_ENGINE - THREE.JS REACTOR CORE
    hologram: {
        scene: null, camera: null, renderer: null,
        mesh: null,
        logoGroup: null,
        scale: 1.0, rotationSpeed: 0.01,
        targetScale: 1.0
    },
    // LEXICA_NANO
    neural: { generating: false, lastImage: null }
};

// GHOST TERMINAL
function ghostLog(msg, type = 'cmd') {
    const body = $('ghost-terminal-body');
    const ts = new Date().toTimeString().split(' ')[0].substring(0, 5);
    const line = document.createElement('div');
    line.className = 'ghost-log';
    line.innerHTML = `<span class="ts">${ts}</span><span class="${type}">${msg}</span>`;
    body.appendChild(line);
    body.scrollTop = body.scrollHeight;
    if (body.children.length > 50) body.firstChild.remove();
}

function ghostInit() {
    let dragging = false, startX, startY, elX, elY;
    const header = $('ghost-terminal-header');
    const terminal = $('ghost-terminal');
    header.addEventListener('mousedown', e => {
        dragging = true; startX = e.clientX; startY = e.clientY;
        elX = terminal.offsetLeft; elY = terminal.offsetTop;
    });
    document.addEventListener('mousemove', e => {
        if (!dragging) return;
        terminal.style.left = (elX + e.clientX - startX) + 'px';
        terminal.style.top = (elY + e.clientY - startY) + 'px';
        terminal.style.right = 'auto'; terminal.style.bottom = 'auto';
    });
    document.addEventListener('mouseup', () => { dragging = false; });
}

function toggleGhost() {
    const term = $('ghost-terminal');
    const isActive = term.style.display === 'flex';
    term.style.display = isActive ? 'none' : 'flex';
    if(!isActive) { term.classList.add('active'); $('ghost-input').focus(); ghostLog('GHOST_AI LISTENING...', 'ai'); }
}

$('ghost-input').addEventListener('keydown', e => { if(e.key === 'Enter') { const val = e.target.value.trim(); if(val) processGhostCommand(val); e.target.value = ''; } });

function processGhostCommand(cmd) { 
    ghostLog(cmd.toUpperCase(), 'user'); 
    const c = cmd.toLowerCase().trim();
    const hour = new Date().getHours();
    
    setTimeout(() => { 
        // Greetings
        if (c.match(/^(hi|hello|hey|yo|sup|ciao|hola|bonjour|salut|oi)$/)) {
            const greets = [
                'Hey operator. Systems are yours.',
                'Yo. What are we breaking today?',
                'Ciao. Ready when you are.',
                hour < 12 ? 'Morning. Coffee protocols engaged.' : hour < 18 ? 'Good afternoon, commander.' : 'Night shift. Let\'s make magic.'
            ];
            ghostLog(greets[Math.floor(Math.random()*greets.length)], 'ai');
        }
        // Status
        else if (c.includes('status') || c === 'sys') {
            ghostLog(`FPS:${APP.render.fps} | MEDIA:${APP.media.queue.length} | AUDIO:${APP.audio.isPlaying ? 'PLAYING' : 'IDLE'}`, 'ai');
        }
        // Help
        else if (c === 'help' || c === '?') {
            ghostLog('SOVEREIGN_COMMANDS:', 'ai');
            ghostLog('SHATTER | TRASUDATE | LOAD | MINT', 'success');
            ghostLog('status | theme | party | seismic | fx', 'ai');
            ghostLog('time | crypto | about | clear | fs', 'ai');
        }
        // ========== SOVEREIGN COMMANDS ==========
        // SHATTER - Trigger glass fractures across screen
        else if (c === 'shatter') {
            ghostLog('SHATTER_PROTOCOL: INITIATING...', 'success');
            const stage = $('stage');
            const rect = stage.getBoundingClientRect();
            for (let i = 0; i < 6; i++) {
                setTimeout(() => {
                    const x = rect.left + Math.random() * rect.width;
                    const y = rect.top + Math.random() * rect.height;
                    if (typeof createGlassFracture === 'function') {
                        createGlassFracture(x, y);
                    }
                }, i * 80);
            }
            ghostLog('GLASS_MATRIX: SHATTERED', 'success');
        }

        // LOAD - Open directory picker for media scan
        else if (c === 'load' || c === 'scan') {
            ghostLog('LOAD_PROTOCOL: SCANNING...', 'ai');
            (async () => {
                try {
                    if (!window.showDirectoryPicker) {
                        ghostLog('DIRECTORY_PICKER: NOT_SUPPORTED', 'crit');
                        return;
                    }
                    const dirHandle = await window.showDirectoryPicker();
                    APP.ghost.directoryHandle = dirHandle;
                    let mediaCount = 0;
                    const mediaExt = ['.mp4', '.webm', '.mov', '.jpg', '.jpeg', '.png', '.gif', '.mp3', '.wav'];
                    
                    for await (const entry of dirHandle.values()) {
                        if (entry.kind === 'file') {
                            const name = entry.name.toLowerCase();
                            if (mediaExt.some(ext => name.endsWith(ext))) {
                                mediaCount++;
                                const file = await entry.getFile();
                                const url = URL.createObjectURL(file);
                                if (name.match(/\.(mp4|webm|mov)$/i)) {
                                    const vid = document.createElement('video');
                                    vid.src = url; vid.loop = true; vid.muted = true;
                                    APP.media.queue.push({ type: 'video', element: vid, name: entry.name });
                                } else if (name.match(/\.(jpg|jpeg|png|gif)$/i)) {
                                    const img = new Image();
                                    img.src = url;
                                    APP.media.queue.push({ type: 'image', element: img, name: entry.name });
                                }
                            }
                        }
                    }
                    ghostLog(`LOADED: ${mediaCount} MEDIA_FILES`, 'success');
                    $('q-info').textContent = APP.media.queue.length;
                } catch (e) {
                    ghostLog('LOAD_ABORTED: ' + e.message, 'crit');
                }
            })();
        }
        // MINT - Prepare NFT snapshot
        else if (c === 'mint') {
            ghostLog('MINT_PROTOCOL: PREPARING...', 'ai');
            if (APP.render.canvas) {
                try {
                    const dataUrl = APP.render.canvas.toDataURL('image/png');
                    APP.nft.dnaSnapshot = dataUrl;
                    ghostLog('SNAPSHOT: ' + (dataUrl.length / 1024).toFixed(0) + 'KB', 'success');
                    ghostLog('READY_FOR_MINT // CONNECT_WALLET', 'ai');
                    const a = document.createElement('a');
                    a.href = dataUrl;
                    a.download = `VNGRD_MINT_${Date.now()}.png`;
                    a.click();
                    ghostLog('SNAPSHOT_DOWNLOADED', 'success');
                } catch (e) {
                    ghostLog('MINT_ERROR: ' + e.message, 'crit');
                }
            }
        }
        // ========== END SOVEREIGN COMMANDS ==========
        // Theme
        else if (c.startsWith('theme ')) {
            const t = c.split(' ')[1];
            if (['cyan','magenta','green','purple','gold','night'].includes(t)) {
                setTheme(t);
                ghostLog(`Theme: ${t.toUpperCase()}`, 'success');
            } else {
                ghostLog('Themes: cyan, magenta, green, purple, gold, night', 'ai');
            }
        }
        else if (c === 'theme') {
            ghostLog(`Current: ${APP.state.theme || 'cyan'}`, 'ai');
        }
        // Party
        else if (c === 'party') {
            $('btn-ui-react').click();
            ghostLog(APP.vj.uiReactivity ? 'PARTY MODE: ON' : 'PARTY MODE: OFF', APP.vj.uiReactivity ? 'success' : 'ai');
        }
        // Seismic
        else if (c === 'seismic' || c === 'shake') {
            $('btn-rumble').click();
            ghostLog(APP.vj.rumbleEnabled ? 'SEISMIC: ARMED' : 'SEISMIC: OFF', APP.vj.rumbleEnabled ? 'success' : 'ai');
        }
        // FX
        else if (c === 'fx' || c === 'crush') {
            impactCrush();
            ghostLog('CRUSH FX TRIGGERED', 'success');
        }
        else if (c === 'stutter') {
            impactStutter();
            ghostLog('STUTTER FX', 'success');
        }
        else if (c === 'invert') {
            impactInvert();
            ghostLog('INVERT FX', 'success');
        }
        // Time
        else if (c === 'time' || c === 'clock') {
            ghostLog(new Date().toLocaleTimeString() + ' | UP:' + $('uptime').textContent, 'ai');
        }
        // Crypto
        else if (c === 'crypto' || c === 'btc' || c === 'eth') {
            fetchCrypto();
            ghostLog('Fetching feeds...', 'ai');
        }
        // Joke
        else if (c === 'joke') {
            const jokes = [
                'Why do DJs make great coders? They know how to drop the beat and the bugs.',
                'I told my GPU a joke. It rendered me speechless.',
                '404: Humor module temporarily unavailable.',
                'What\'s a VJ\'s favorite key? The space bar.',
            ];
            ghostLog(jokes[Math.floor(Math.random()*jokes.length)], 'ai');
        }
        // About
        else if (c === 'about' || c === 'who') {
            ghostLog('GHOST://AI v3 | VNGRD companion system', 'ai');
        }
        // Clear
        else if (c === 'clear' || c === 'cls') {
            $('ghost-terminal-body').innerHTML = '';
            ghostLog('Terminal cleared', 'ai');
        }
        // Fullscreen
        else if (c === 'fs' || c === 'fullscreen') {
            toggleFullscreen();
            ghostLog('Fullscreen toggled', 'success');
        }
        // Random/unknown - give helpful response
        else {
            const responses = [
                'Unknown. Type "help" for commands.',
                'Didn\'t catch that. Try "help".',
                'Command not found. "help" for list.',
            ];
            ghostLog(responses[Math.floor(Math.random()*responses.length)], 'crit');
        }
    }, 200 + Math.random() * 150); 
}

// CRYPTO — Binance API (reliable browser-side fetch)
async function fetchCrypto() {
    try {
        const symbols = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'DOGEUSDT'];
        const labels = { BTCUSDT: 'BTC', ETHUSDT: 'ETH', SOLUSDT: 'SOL', DOGEUSDT: 'DOGE' };
        
        const prices = await Promise.all(symbols.map(s =>
            fetch('https://api.binance.com/api/v3/ticker/price?symbol=' + s).then(r => r.json())
        ));

        APP.crypto.tickerHTML = prices.map(p => {
            const sym = labels[p.symbol] || p.symbol;
            const price = parseFloat(p.price);
            return `<span>${sym}: $${price < 1 ? price.toFixed(6) : price.toFixed(2)}</span>`;
        }).join('&nbsp;&nbsp;//&nbsp;&nbsp;');

        updateTickerCycle();
        
        // DELETED: log('CRYPTO_FEED: BINANCE_LOCKED'); 
        // This removes the minute-by-minute text from your system log box.

    } catch(e) {
        APP.crypto.tickerHTML = '<span style="color:var(--r)">CRYPTO_FEED_OFFLINE</span>';
        updateTickerCycle();
        // Console warning only - keeps the visible terminal clean for the "TV Station" look
        console.warn("Binance data sync paused."); 
    }
}
// TICKER CYCLE ENGINE — [WEATHER] > [CRYPTO] > [IDENTITY]
APP.crypto.tickerHTML = '';
APP.ticker = { phase: 0, interval: null };

function updateTickerCycle() {
    const ticker = $('ticker-text');
    if (!ticker) return;
    const weatherBlock = APP.atmosphere.city !== 'UNKNOWN'
        ? `<span style="color:var(--accent)">[LOC: ${APP.atmosphere.city}]</span>&nbsp;//&nbsp;<span>[TEMP: ${APP.atmosphere.temperature || '—'}°C]</span>&nbsp;//&nbsp;<span>[${APP.atmosphere.isRaining ? 'PRECIPITATION_DETECTED' : 'ATMOS_STABLE'}]</span>`
        : '<span style="color:var(--text-dim)">WEATHER: ACQUIRING...</span>';
    const cryptoBlock = APP.crypto.tickerHTML || '<span style="color:var(--text-dim)">CRYPTO: LOADING...</span>';
    const identityBlock = '<span style="color:var(--accent)">WHAT HAPPENS IN THE NODES STAYS IN THE NODES</span>&nbsp;&nbsp;//&nbsp;&nbsp;<span style="color:var(--v)">SIGNAL_RESTORED</span>';
    const full = weatherBlock + '&nbsp;&nbsp;//&nbsp;&nbsp;' + cryptoBlock + '&nbsp;&nbsp;//&nbsp;&nbsp;' + identityBlock;
    ticker.innerHTML = full + '&nbsp;&nbsp;//&nbsp;&nbsp;' + full;
}

// UTILS
function log(msg) { const box = document.getElementById('sys-log'); if (!box) return; const ts = new Date().toTimeString().split(' ')[0]; const el = document.createElement('div'); el.className = 'log-line'; el.innerHTML = `<span class="ts">${ts}</span>${msg}`; box.insertBefore(el, box.firstChild); if (box.children.length > 30) box.lastChild.remove(); }
function checkMobile() { APP.state.isMobile = /Android|iPhone|iPad|iPod|webOS|BlackBerry/i.test(navigator.userAgent); if (APP.state.isMobile) { APP.render.width = 1920; APP.render.height = 1080; log('MOBILE_MODE'); } }

// RENDER
function initCanvas() {
    APP.render.canvas = $('vj-canvas');
    APP.render.ctx = APP.render.canvas.getContext('2d', { alpha: false }); // Removed desynchronized to prevent grey flickering
    resizeCanvas();
    window.addEventListener('resize', () => { resizeCanvas(); checkMobile(); });
    // Off-screen canvas for proper pixelation
    APP.render.pixelCanvas = document.createElement('canvas');
    APP.render.pixelCanvas.width = 384; APP.render.pixelCanvas.height = 216; // Start small
    APP.render.pixelCtx = APP.render.pixelCanvas.getContext('2d', { alpha: false });
    APP.render.pixelCtx.imageSmoothingEnabled = false;
    log('CANVAS_INIT_4K');
}
function resizeCanvas() { APP.render.canvas.width = APP.render.width; APP.render.canvas.height = APP.render.height; $('res').textContent = `${APP.render.width}x${APP.render.height}`; }

// ═══════════════════════════════════════════════════════════════════════════
// NFT_VAULT — Horizontal Gallery (burned into canvas bottom)
// ═══════════════════════════════════════════════════════════════════════════
function drawNFTVault(ctx, w, h) {
    var assets = APP.user.assets;
    if (!assets || assets.length === 0) return;

    var thumbSize = Math.round(h * 0.08);
    var padding = Math.round(thumbSize * 0.15);
    var barH = thumbSize + padding * 2;
    var barY = h - barH;

    // Gallery bar background — dark glass
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = 'rgba(4, 4, 8, 0.85)';
    ctx.fillRect(0, barY, w, barH);

    // Top accent line
    ctx.fillStyle = 'rgba(0, 243, 255, 0.4)';
    ctx.fillRect(0, barY, w, 1);

    // Clear thumbnail hit areas for this frame
    APP.nftVault.thumbnails = [];

    // Calculate total gallery width for centering
    var totalW = assets.length * (thumbSize + padding) - padding;
    var startX = Math.max(padding, (w - totalW) / 2);

    for (var i = 0; i < assets.length; i++) {
        var asset = assets[i];
        if (!asset.image || !asset.image.complete || asset.image.naturalWidth === 0) continue;

        var tx = startX + i * (thumbSize + padding);
        var ty = barY + padding;

        // Draw thumbnail with border
        ctx.drawImage(asset.image, tx, ty, thumbSize, thumbSize);

        // Accent border
        var isActive = (APP.media.currentElement === asset.image);
        ctx.strokeStyle = isActive ? '#ff3333' : 'rgba(0, 243, 255, 0.6)';
        ctx.lineWidth = isActive ? 2 : 1;
        ctx.strokeRect(tx, ty, thumbSize, thumbSize);

        // Label
        var labelFS = Math.max(8, Math.round(thumbSize * 0.14));
        ctx.font = '700 ' + labelFS + 'px Orbitron, sans-serif';
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        var label = (asset.name || 'NFT').substring(0, 10);
        ctx.fillText(label, tx + thumbSize / 2, ty + thumbSize + 2);

        // Store hit area for click detection
        APP.nftVault.thumbnails.push({
            x: tx, y: ty, w: thumbSize, h: thumbSize,
            index: i
        });
    }

    ctx.restore();
}

// ═══════════════════════════════════════════════════════════════════════════
// SUMMONER LOGIC — NFT click triggers source swap + System Summoning glitch
// ═══════════════════════════════════════════════════════════════════════════
function initSummonerLogic() {
    // Canvas has pointer-events:none so clicks pass through to UI.
    // Listen on #stage (the canvas parent) which DOES receive clicks,
    // then translate clientX/Y to canvas pixel coordinates.
    var stage = $('stage');
    var canvas = APP.render.canvas;
    if (!stage || !canvas) return;

    stage.addEventListener('click', function(e) {
        if (!APP.user.assets || APP.user.assets.length === 0) return;
        if (!APP.nftVault.thumbnails || APP.nftVault.thumbnails.length === 0) return;

        var rect = canvas.getBoundingClientRect();
        var scaleX = APP.render.width / rect.width;
        var scaleY = APP.render.height / rect.height;
        var cx = (e.clientX - rect.left) * scaleX;
        var cy = (e.clientY - rect.top) * scaleY;

        for (var i = 0; i < APP.nftVault.thumbnails.length; i++) {
            var t = APP.nftVault.thumbnails[i];
            if (cx >= t.x && cx <= t.x + t.w && cy >= t.y && cy <= t.y + t.h) {
                summonNFTByIndex(t.index);
                return; // Only summon one per click
            }
        }
    });
}

// Shared summoner — injects NFT into media queue (eject/cycle compatible)
function summonNFTByIndex(index) {
    var asset = APP.user.assets[index];
    if (!asset || !asset.image) return;

    // Clear any lingering render.source override so media queue takes priority
    APP.render.source = null;

    // Check if this NFT is already in the queue — if so, just switch to it
    for (var q = 0; q < APP.media.queue.length; q++) {
        if (APP.media.queue[q].element === asset.image) {
            if (APP.media.currentElement?.tagName === 'VIDEO') APP.media.currentElement.pause();
            APP.media.currentIndex = q;
            APP.media.currentElement = asset.image;
            log('SUMMONER: ' + (asset.name || 'NFT_' + index) + ' FOCUSED');
            _summonGlitch();
            return;
        }
    }

    // Inject into media queue as a new item
    var item = { type: 'image', url: asset.imageUrl || '', element: asset.image, name: 'NFT_' + (asset.name || index) };
    // Append to gif-host at natural size (off-screen) for GIF animation
    var host = $('gif-host');
    if (host && !asset.image.parentNode) host.appendChild(asset.image);

    APP.media.queue.push(item);
    if (APP.media.currentElement?.tagName === 'VIDEO') APP.media.currentElement.pause();
    APP.media.currentIndex = APP.media.queue.length - 1;
    APP.media.currentElement = asset.image;
    updateQueueDisplay();
    if ($('media-dot')) $('media-dot').classList.remove('off');

    log('SUMMONER: ' + (asset.name || 'NFT_' + index) + ' → MEDIA_DECK');
    _summonGlitch();
}

function _summonGlitch() {
    var prevGlitch = APP.vj.glitchSnap;
    var prevRGB = APP.vj.rgbIntensity;
    var prevRGBEnabled = APP.vj.rgbEnabled;
    APP.vj.glitchSnap = 5;
    APP.vj.rgbIntensity = 30;
    APP.vj.rgbEnabled = true;
    triggerChromaticAberration();
    triggerImpact();
    setTimeout(function() {
        APP.vj.glitchSnap = prevGlitch;
        APP.vj.rgbIntensity = prevRGB;
        APP.vj.rgbEnabled = prevRGBEnabled;
    }, 500);
}

function renderLoop(timestamp) {
    APP.render.rafId = requestAnimationFrame(renderLoop);
    APP.render.frameCount++;
    if (timestamp - APP.render.lastFpsUpdate >= 1000) { APP.render.fps = APP.render.frameCount; APP.render.frameCount = 0; APP.render.lastFpsUpdate = timestamp; $('fps-val').textContent = APP.render.fps; }
    
    const ctx = APP.render.ctx; const w = APP.render.width; const h = APP.render.height;
    ctx.imageSmoothingEnabled = false;
    if (!APP.render.canvas._gpuFixed) { APP.render.canvas.style.willChange = 'transform'; APP.render.canvas._gpuFixed = true; }
    
    // --- SEISMIC ENGINE (Random shake on bass - OFF by default) ---
    let finalShakeX = 0, finalShakeY = 0;
    
    if (APP.vj.rumbleEnabled && (APP.audio.isPlaying || APP.audio.videoSource) && APP.audio.kick > 195) {
        const intensity = (APP.audio.kick - 195) / 60 * 10;
        finalShakeX = (Math.random() - 0.5) * intensity;
        finalShakeY = (Math.random() - 0.5) * intensity;
    }

    // Apply transform to BODY
    const targetTransform = (Math.abs(finalShakeX) > 0.2 || Math.abs(finalShakeY) > 0.2) 
        ? `translate3d(${finalShakeX.toFixed(1)}px, ${finalShakeY.toFixed(1)}px, 0)` 
        : '';
    if (document.body.style.transform !== targetTransform) { 
        document.body.style.transform = targetTransform; 
    }

    // --- PUNCH SCALE ENGINE (kick > 195) ---
    if (APP.vj.punchEnabled && (APP.audio.isPlaying || APP.audio.videoSource) && APP.audio.kick > 195) {
        APP.vj.punchScale = 1 + (APP.audio.kick - 195) / 60 * 0.08;
    } else {
        APP.vj.punchScale += (1 - APP.vj.punchScale) * 0.25;
        if (Math.abs(APP.vj.punchScale - 1) < 0.002) APP.vj.punchScale = 1;
    }

    // --- AUTONOMOUS PARTY MODE ---
    if (APP.vj.uiReactivity) {
        if (APP.audio.bassLevel > 220) {
           // Light play handled in analyzeAudio for performance
        }
    }

    // --- CLEAR FRAME ---
    if (APP.vj.trailsEnabled) {
        ctx.fillStyle = 'rgba(0,0,0,' + (1 - APP.vj.trailAlpha) + ')';
        ctx.fillRect(0, 0, w, h);
    } else {
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);
    }
    
    // FILTER STACK - values are decimals (1.0 = 100%), convert to proper CSS
    let filterStr = `brightness(${APP.vj.brightness}) contrast(${APP.vj.contrast}) saturate(${APP.vj.saturation}) hue-rotate(${APP.vj.hue}deg)${APP.vj.invert ? ' invert(1)' : ''}`;
    if (APP.vj.nightVision) filterStr += ' sepia(1) saturate(6) hue-rotate(80deg) brightness(1.4) contrast(1.5)';
    ctx.filter = filterStr;
    
    let source = null;
    if (APP.render.source) source = APP.render.source;
    else if (APP.state.isLive && APP.camera.stream && APP.camera.videoEl) source = APP.camera.videoEl;
    else if (APP.guest.stream && APP.guest.isActive && APP.guest.videoElement) source = APP.guest.videoElement;
    else if (APP.media.currentElement) source = APP.media.currentElement;
    
    if (source) {
        const ready = source.tagName === 'VIDEO' ? source.readyState >= 2 : (source.complete && source.naturalWidth > 0);
        if (ready) {
            // TACTICAL_XY: cursor maps X→RGB shift, Y→pixelation
            var _pxEnabled = APP.vj.pixelateEnabled, _pxSize = APP.vj.pixelSize;
            var _rgbEnabled = APP.vj.rgbEnabled, _rgbIntensity = APP.vj.rgbIntensity;
            if (APP.vj.tacticalXY) {
                _rgbEnabled = true; _rgbIntensity = APP.vj.mouseX * 24;
                _pxSize = Math.max(1, Math.round(APP.vj.mouseY * 16)); _pxEnabled = _pxSize > 1;
            }
            // PUNCH scale
            if (APP.vj.punchScale !== 1) { ctx.save(); ctx.translate(w/2,h/2); ctx.scale(APP.vj.punchScale,APP.vj.punchScale); ctx.translate(-w/2,-h/2); }

            if (_pxEnabled && _pxSize > 1) {
                // OFF-SCREEN BUFFER RENDER
                const size = APP.vj.pixelSize;
                const sw = Math.ceil(w / size);
                const sh = Math.ceil(h / size);
                
                if(APP.render.pixelCanvas.width !== sw) { APP.render.pixelCanvas.width = sw; APP.render.pixelCanvas.height = sh; }
                
                APP.render.pixelCtx.drawImage(source, 0, 0, sw, sh);
                ctx.drawImage(APP.render.pixelCanvas, 0, 0, sw, sh, 0, 0, w, h);
            } else {
                ctx.drawImage(source, 0, 0, w, h);
            }

            if (APP.vj.maskMode) {
                const pulse = 1 + (APP.audio.bassLevel / 255) * 0.5;
                ctx.globalCompositeOperation = 'destination-in';
                ctx.beginPath(); ctx.arc(w/2, h/2, (h/3) * pulse, 0, Math.PI * 2); ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
            }
        }
    }

    // PUNCH scale restore
    if (APP.vj.punchScale !== 1) ctx.restore();

    // --- RGB SHIFT ---
    if (_rgbEnabled && _rgbIntensity > 0) {
        const shift = _rgbIntensity;
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(APP.render.canvas, shift, 0);
        ctx.drawImage(APP.render.canvas, -shift, 0);
        ctx.restore();
    }
    
    // ═══ IDENTITY TRINITY — three independent actors burned into canvas ═══
    ctx.filter = 'none';
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
    var T = APP.trinity;
    
    // ACTOR 1: STATION BUG (text or uploaded image)
    if (T.bug.visible) {
        var bugEl = $('station-bug');
        var bx = T.bug.x * w, by = T.bug.y * h, bScale = T.bug.scale;
        if (bugEl) {
            var bugImg = bugEl.querySelector('img');
            if (bugImg && bugImg.complete && bugImg.naturalWidth > 0) {
                ctx.save();
                var bw = bugImg.naturalWidth * bScale * (w / 1920);
                var bh = bugImg.naturalHeight * bScale * (h / 1080);
                ctx.drawImage(bugImg, bx, by, bw, bh);
                ctx.restore();
            } else if (APP.bug.text) {
                ctx.save();
                var bugFS = Math.max(14, 28 * bScale * (h / 1080));
                ctx.font = '800 ' + bugFS + 'px Orbitron, sans-serif';
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2;
                ctx.fillText(APP.bug.text, bx, by);
                ctx.restore();
            }
        }
    }
    
    // ACTOR 2: 2D LOGO (uploaded image via drawImage — no size cap)
    if (T.logo.visible) {
        var logoImg = $('user-logo-layer');
        if (logoImg && logoImg.src && logoImg.src !== window.location.href && logoImg.naturalWidth > 0) {
            ctx.save();
            var lScale = T.logo.scale;
            var lw = logoImg.naturalWidth * lScale * (w / 1920);
            var lh = logoImg.naturalHeight * lScale * (h / 1080);
            var lx = T.logo.x * w, ly = T.logo.y * h;
            ctx.drawImage(logoImg, lx, ly, lw, lh);
            ctx.restore();
        }
    }
    
    // ACTOR 3: 3D MODEL (renderLoop drives rotation + render on hologram-canvas)
    if (T.holo.visible) {
        var holoCanvas = $('hologram-canvas');
        if (holoCanvas && holoCanvas.width > 0) {
            // Drive 3D animation from renderLoop — single rAF for everything
            if (APP.hologram.mesh && APP.hologram.renderer && APP.hologram.scene && APP.hologram.camera) {
                APP.hologram.mesh.rotation.y += APP.hologram.rotationSpeed;
                // Rotate 3D Logo independently (slower, Y-axis)
                if (APP.hologram.logoGroup && APP.hologram.logoGroup.children.length > 0) {
                    APP.hologram.logoGroup.rotation.y += 0.008;
                }

                // SEISMIC SCALE — lerp toward targetScale (bass*0.6 + MIDI*0.4)
                var bassScale = 1.0;
                if (APP.audio && APP.audio.bassLevel > 0) {
                    bassScale = 1.0 + (APP.audio.bassLevel / 255) * 0.5;
                }
                var midiScale = APP.hologram.targetScale || 1.0;
                var seismicTarget = (bassScale * 0.6) + (midiScale * 0.4);
                var currentS = APP.hologram.mesh.scale.x;
                var lerpedS = currentS + (seismicTarget - currentS) * 0.1;
                APP.hologram.mesh.scale.set(lerpedS, lerpedS, lerpedS);

                // Decay MIDI targetScale back to 1.0
                if (APP.hologram.targetScale > 1.0) {
                    APP.hologram.targetScale += (1.0 - APP.hologram.targetScale) * 0.05;
                    if (APP.hologram.targetScale < 1.01) APP.hologram.targetScale = 1.0;
                }

                APP.hologram.renderer.render(APP.hologram.scene, APP.hologram.camera);
            }
            ctx.save();
            ctx.globalCompositeOperation = 'screen'; // black bg = invisible, lit model = hologram glow
            var hScale = T.holo.scale;
            var hw = holoCanvas.width * hScale * (w / 1920);
            var hh = holoCanvas.height * hScale * (h / 1080);
            var hx = T.holo.x * w, hy = T.holo.y * h;
            try { ctx.drawImage(holoCanvas, hx, hy, hw, hh); } catch(e) {}
            ctx.globalCompositeOperation = 'source-over';
            ctx.restore();
        }
    }


    // ══════════════════════════════════════════════════
    // BURN-IN LOWER THIRD — Premium Broadcast Canvas Render
    // Draws directly to captureStream canvas = ALWAYS in recording
    // ══════════════════════════════════════════════════
    if (APP.lowerThird && APP.lowerThird.visible) {
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;
        ctx.filter = 'none';

        // A. Preset accent + secondary color
        var ltAccent = '#00f3ff';
        var ltGlow = 'rgba(0,243,255,';
        if (APP.lowerThird.preset === 'track') { ltAccent = '#00ff88'; ltGlow = 'rgba(0,255,136,'; }
        else if (APP.lowerThird.preset === 'breaking') { ltAccent = '#ff3333'; ltGlow = 'rgba(255,51,51,'; }

        // B. Read text — textContent works on display:none elements
        var ltTitle = document.getElementById('lt-title-text');
        var ltSub = document.getElementById('lt-subtitle-text');
        var titleText = (ltTitle && ltTitle.textContent && ltTitle.textContent.trim()) ? ltTitle.textContent.trim() : 'LIVE BROADCAST';
        var subText = (ltSub && ltSub.textContent && ltSub.textContent.trim()) ? ltSub.textContent.trim() : '';

        // C. Responsive sizing — scales to any resolution
        var ltMargin = Math.round(w * 0.025);
        var ltBottom = Math.round(h * 0.065);
        var ltPad = Math.round(h * 0.015);
        var titleFS = Math.max(20, Math.round(h * 0.03));
        var subFS = Math.max(12, Math.round(h * 0.016));
        var accentW = Math.max(4, Math.round(h * 0.004));

        // D. Measure text for dynamic box width
        ctx.font = '800 ' + titleFS + 'px Orbitron, sans-serif';
        var titleW = ctx.measureText(titleText).width;
        ctx.font = '500 ' + subFS + 'px "JetBrains Mono", monospace';
        var subW = subText ? ctx.measureText(subText.toUpperCase()).width : 0;
        var contentW = Math.max(titleW, subW);
        var boxW = contentW + ltPad * 4 + accentW;
        var minW = w * 0.25;
        if (boxW < minW) boxW = minW;
        var boxH = ltPad + titleFS + (subText ? 6 + subFS : 0) + ltPad;
        var boxX = ltMargin;
        var boxY = h - ltBottom - boxH;

        // E. Background — dark glass panel
        var bgGrad = ctx.createLinearGradient(boxX, 0, boxX + boxW, 0);
        bgGrad.addColorStop(0, 'rgba(8,8,12,0.95)');
        bgGrad.addColorStop(0.7, 'rgba(8,8,12,0.85)');
        bgGrad.addColorStop(1, 'rgba(8,8,12,0)');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(boxX, boxY, boxW, boxH);

        // F. Bottom accent line — full width colored bar
        ctx.fillStyle = ltAccent;
        ctx.fillRect(boxX, boxY + boxH, boxW * 0.6, 2);
        // Faded tail
        var tailGrad = ctx.createLinearGradient(boxX + boxW * 0.6, 0, boxX + boxW, 0);
        tailGrad.addColorStop(0, ltAccent);
        tailGrad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = tailGrad;
        ctx.fillRect(boxX + boxW * 0.6, boxY + boxH, boxW * 0.4, 2);

        // G. Left accent stripe with neon glow
        ctx.shadowColor = ltAccent;
        ctx.shadowBlur = 16;
        ctx.fillStyle = ltAccent;
        ctx.fillRect(boxX, boxY, accentW, boxH);
        ctx.shadowBlur = 0;

        // H. Top edge hairline
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        ctx.fillRect(boxX + accentW, boxY, boxW - accentW, 1);

        // I. Title — bold white, left-aligned
        ctx.font = '800 ' + titleFS + 'px Orbitron, sans-serif';
        ctx.fillStyle = '#ffffff';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.shadowColor = 'rgba(0,0,0,0.8)';
        ctx.shadowBlur = 6;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        ctx.fillText(titleText, boxX + accentW + ltPad, boxY + ltPad);
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        // J. Subtitle — accent colored, uppercase monospace
        if (subText) {
            ctx.font = '500 ' + subFS + 'px "JetBrains Mono", monospace';
            ctx.fillStyle = ltAccent;
            ctx.globalAlpha = 0.9;
            ctx.fillText(subText.toUpperCase(), boxX + accentW + ltPad, boxY + ltPad + titleFS + 6);
            ctx.globalAlpha = 1;
        }

        // K. Live indicator dot (breaking preset only)
        if (APP.lowerThird.preset === 'breaking') {
            var dotR = Math.max(4, titleFS * 0.18);
            var dotX = boxX + accentW + ltPad + contentW + ltPad;
            var dotY = boxY + ltPad + titleFS * 0.5;
            var pulse = 0.5 + 0.5 * Math.sin(timestamp * 0.005);
            ctx.beginPath();
            ctx.arc(dotX, dotY, dotR, 0, Math.PI * 2);
            ctx.fillStyle = ltGlow + (0.6 + pulse * 0.4) + ')';
            ctx.fill();
            ctx.shadowColor = ltAccent;
            ctx.shadowBlur = 8 + pulse * 8;
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        ctx.restore();
    }

    // ═══ NFT_VAULT — Horizontal Gallery at bottom ═══
    drawNFTVault(ctx, w, h);

    // ═══ PERMANENT SIGNATURE — untouchable, not part of Trinity ═══
    ctx.save();
    var sigFS = Math.max(14, h * 0.012);
    ctx.font = '900 ' + sigFS + 'px Orbitron';
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
    ctx.shadowColor = 'rgba(0,0,0,0.6)'; ctx.shadowBlur = sigFS / 8;
    ctx.fillText('VNGRD', w - (w * 0.01), h - (h * 0.01));
    ctx.restore();
}

function triggerImpact() { document.body.classList.remove('impact-flash'); void document.body.offsetWidth; document.body.classList.add('impact-flash'); setTimeout(() => document.body.classList.remove('impact-flash'), 200); }
// triggerChromaticAberration REMOVED
function impactStutter() { const oT = APP.vj.trailsEnabled, oA = APP.vj.trailAlpha; APP.vj.trailsEnabled = true; APP.vj.trailAlpha = 0.98; setTimeout(() => { APP.vj.trailsEnabled = oT; APP.vj.trailAlpha = oA; }, 500); }
function impactInvert() { APP.vj.invert = true; setTimeout(() => { APP.vj.invert = false; }, 500); }
function impactCrush() { const oRGB = APP.vj.rgbIntensity, oPix = APP.vj.pixelSize, oRE = APP.vj.rgbEnabled, oPE = APP.vj.pixelateEnabled; APP.vj.rgbEnabled = true; APP.vj.pixelateEnabled = true; APP.vj.rgbIntensity = 25; APP.vj.pixelSize = 16; setTimeout(() => { APP.vj.rgbEnabled = oRE; APP.vj.pixelateEnabled = oPE; APP.vj.rgbIntensity = oRGB; APP.vj.pixelSize = oPix; }, 500); }

// SIMPLE DRAGGABLE - DIRECT LEFT/TOP POSITIONING (for non-Trinity DOM elements)
function makeDraggable(el) {
    let isDown = false, iX, iY, cX = 0, cY = 0;
    el.addEventListener('mousedown', e => {
        isDown = true; iX = e.clientX - cX; iY = e.clientY - cY;
        el.style.cursor = 'grabbing'; e.stopPropagation();
    });
    document.addEventListener('mousemove', e => {
        if (!isDown) return; e.preventDefault();
        cX = e.clientX - iX; cY = e.clientY - iY;
        el.style.transform = 'translate3d(' + cX + 'px, ' + cY + 'px, 0)';
    });
    document.addEventListener('mouseup', () => { isDown = false; el.style.cursor = 'grab'; });
}

// ═══ TOUCH-BRIDGE — Unified Mouse + Touch for Trinity ═══
// One-finger drag + two-finger pinch (mobile) / mouse drag + ctrl+wheel pinch (desktop)
(function initTouchBridge() {
    var activeActor = null, offsetX = 0, offsetY = 0;
    var pinchActor = null, lastPinchDist = 0;

    // --- Shared utilities ---
    function getCanvas() { return APP.render.canvas || null; }

    function canvasNorm(clientX, clientY) {
        var c = getCanvas(); if (!c) return null;
        var r = c.getBoundingClientRect();
        return { x: (clientX - r.left) / r.width, y: (clientY - r.top) / r.height };
    }

    function hitTest(pos) {
        var T = APP.trinity, w = APP.render.width, h = APP.render.height;
        if (T.holo.visible) {
            var hc = $('hologram-canvas');
            if (hc && hc.width > 0) {
                var hw = (hc.width * T.holo.scale * (w / 1920)) / w;
                var hh = (hc.height * T.holo.scale * (h / 1080)) / h;
                if (pos.x >= T.holo.x && pos.x <= T.holo.x + hw && pos.y >= T.holo.y && pos.y <= T.holo.y + hh) return 'holo';
            }
        }
        if (T.logo.visible) {
            var li = $('user-logo-layer');
            if (li && li.naturalWidth > 0) {
                var lw = (li.naturalWidth * T.logo.scale * (w / 1920)) / w;
                var lh = (li.naturalHeight * T.logo.scale * (h / 1080)) / h;
                if (pos.x >= T.logo.x && pos.x <= T.logo.x + lw && pos.y >= T.logo.y && pos.y <= T.logo.y + lh) return 'logo';
            }
        }
        if (T.bug.visible) {
            var bw = Math.max(0.08, 0.08 * T.bug.scale);
            var bh = Math.max(0.03, 0.03 * T.bug.scale);
            if (pos.x >= T.bug.x && pos.x <= T.bug.x + bw && pos.y >= T.bug.y && pos.y <= T.bug.y + bh) return 'bug';
        }
        return null;
    }

    function isUIElement(target) {
        return target.closest && (target.closest('.sidebar') || target.closest('#ghost-bar') || target.closest('button') || target.closest('input') || target.closest('#portrait-lock'));
    }

    function clampPos(v) { return Math.max(0, Math.min(0.95, v)); }

    function applyScale(actor, delta) {
        APP.trinity[actor].scale = Math.max(0.1, Math.min(10, APP.trinity[actor].scale + delta));
        if (actor === 'holo') APP.hologram.scale = APP.trinity.holo.scale;
    }

    // ─── MOUSE: drag ───
    document.addEventListener('mousedown', function(e) {
        if (isUIElement(e.target)) return;
        var pos = canvasNorm(e.clientX, e.clientY);
        if (!pos) return;
        var actor = hitTest(pos);
        if (!actor) return;
        activeActor = actor;
        offsetX = pos.x - APP.trinity[actor].x;
        offsetY = pos.y - APP.trinity[actor].y;
        e.preventDefault();
    });
    document.addEventListener('mousemove', function(e) {
        if (!activeActor) return;
        var pos = canvasNorm(e.clientX, e.clientY);
        if (!pos) return;
        APP.trinity[activeActor].x = clampPos(pos.x - offsetX);
        APP.trinity[activeActor].y = clampPos(pos.y - offsetY);
        e.preventDefault();
    });
    document.addEventListener('mouseup', function() { activeActor = null; });

    // ─── MOUSE: ctrl+wheel pinch (Mac trackpad) ───
    document.addEventListener('wheel', function(e) {
        if (!e.ctrlKey) return;
        var pos = canvasNorm(e.clientX, e.clientY);
        if (!pos) return;
        var actor = hitTest(pos);
        if (!actor) return;
        e.preventDefault();
        applyScale(actor, e.deltaY > 0 ? -0.05 : 0.05);
    }, { passive: false });

    // ─── TOUCH: one-finger drag + two-finger pinch ───
    var touchDragActor = null, touchOffX = 0, touchOffY = 0;

    document.addEventListener('touchstart', function(e) {
        if (isUIElement(e.target)) return;

        if (e.touches.length === 1) {
            // ONE FINGER — drag
            var t = e.touches[0];
            var pos = canvasNorm(t.clientX, t.clientY);
            if (!pos) return;
            var actor = hitTest(pos);
            if (!actor) return;
            touchDragActor = actor;
            touchOffX = pos.x - APP.trinity[actor].x;
            touchOffY = pos.y - APP.trinity[actor].y;
            e.preventDefault();
        } else if (e.touches.length === 2) {
            // TWO FINGERS — pinch-to-zoom
            touchDragActor = null;
            var dx = e.touches[0].clientX - e.touches[1].clientX;
            var dy = e.touches[0].clientY - e.touches[1].clientY;
            lastPinchDist = Math.sqrt(dx * dx + dy * dy);
            var mx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            var my = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            var pos = canvasNorm(mx, my);
            if (pos) pinchActor = hitTest(pos);
        }
    }, { passive: false });

    document.addEventListener('touchmove', function(e) {
        if (e.touches.length === 1 && touchDragActor) {
            // ONE FINGER — drag
            var t = e.touches[0];
            var pos = canvasNorm(t.clientX, t.clientY);
            if (!pos) return;
            APP.trinity[touchDragActor].x = clampPos(pos.x - touchOffX);
            APP.trinity[touchDragActor].y = clampPos(pos.y - touchOffY);
            e.preventDefault();
        } else if (e.touches.length === 2 && pinchActor) {
            // TWO FINGERS — pinch-to-zoom
            var dx = e.touches[0].clientX - e.touches[1].clientX;
            var dy = e.touches[0].clientY - e.touches[1].clientY;
            var dist = Math.sqrt(dx * dx + dy * dy);
            var delta = (dist - lastPinchDist) * 0.005;
            applyScale(pinchActor, delta);
            lastPinchDist = dist;
            e.preventDefault();
        }
    }, { passive: false });

    document.addEventListener('touchend', function(e) {
        if (e.touches.length === 0) {
            touchDragActor = null; pinchActor = null; activeActor = null;
            lastPinchDist = 0;
        } else if (e.touches.length === 1) {
            pinchActor = null; lastPinchDist = 0;
            var t = e.touches[0];
            var pos = canvasNorm(t.clientX, t.clientY);
            if (pos) {
                var actor = hitTest(pos);
                if (actor) {
                    touchDragActor = actor;
                    touchOffX = pos.x - APP.trinity[actor].x;
                    touchOffY = pos.y - APP.trinity[actor].y;
                }
            }
        }
    });

    document.addEventListener('touchcancel', function() {
        touchDragActor = null; pinchActor = null; activeActor = null; lastPinchDist = 0;
    });
})();


// ========================================
// V34 IDENTITY HANDLERS
// ========================================

// STATION BUG - Set text
if ($('btn-set-station')) {
    $('btn-set-station').onclick = () => {
        const bug = $('station-bug');
        const text = $('bug-text').value || 'VNGRD';
        if (bug) {
            bug.textContent = text;
            bug.style.display = 'block';
            bug.style.background = 'transparent';
            APP.bug.text = text;
        }
        log('STATION: ' + text.toUpperCase());
    };
}

// STATION BUG - Toggle [X] (visible -> hidden via Trinity state)
if ($('btn-bug-toggle')) {
    $('btn-bug-toggle').onclick = () => {
        APP.trinity.bug.visible = !APP.trinity.bug.visible;
        var bug = $('station-bug');
        if (bug) bug.classList.toggle('hidden', !APP.trinity.bug.visible);
        log(APP.trinity.bug.visible ? 'BUG: VISIBLE' : 'BUG: HIDDEN');
    };
}

// 2D LOGO - Upload
if ($('btn-upload-2d')) {
    $('btn-upload-2d').onclick = () => $('file-2d-logo').click();
}

if ($('file-2d-logo')) {
    $('file-2d-logo').onchange = e => {
        if (e.target.files.length) {
            const file = e.target.files[0];
            const url = URL.createObjectURL(file);
            const logoLayer = $('user-logo-layer');
            if (logoLayer) {
                // display:block BEFORE src — triggers GIF animation on load
                logoLayer.style.display = 'block';
                logoLayer.src = url;
                // ON-SCREEN behind canvas at 10px — browser composites = GIF frames advance
                logoLayer.style.position = 'fixed';
                logoLayer.style.bottom = '0';
                logoLayer.style.left = '0';
                logoLayer.style.width = '10px';
                logoLayer.style.height = '10px';
                logoLayer.style.opacity = '0.01';
                logoLayer.style.pointerEvents = 'none';
                logoLayer.style.zIndex = '-1';
                logoLayer.style.objectFit = 'cover';
                logoLayer.style.background = 'transparent';
                logoLayer.style.border = 'none';
                logoLayer.style.boxShadow = 'none';
            }
            APP.trinity.logo.visible = true;
            log('2D_LOGO: ' + file.name.toUpperCase());
        }
    };
}

// 2D LOGO - Toggle [X] (visible -> hidden -> cleared)
APP.layers.logo2dState = 'empty';

if ($('btn-2d-x')) {
    $('btn-2d-x').onclick = () => {
        const logoLayer = $('user-logo-layer');
        if (!logoLayer) return;
        
        if (APP.trinity.logo.visible) {
            // Visible -> Hidden
            APP.trinity.logo.visible = false;
            logoLayer.style.display = 'none';
            log('2D_LOGO: HIDDEN');
        } else if (logoLayer.src && logoLayer.src !== window.location.href) {
            // Hidden -> Clear
            APP.trinity.logo.visible = false;
            logoLayer.src = '';
            logoLayer.style.display = 'none';
            log('2D_LOGO: CLEARED');
        }
    };
}

// 3D handled exclusively by module script — no inline handlers

// MEDIA & CYCLE LOGIC
function loadMediaFiles(input) {
    const isFirstLoad = APP.media.currentIndex === -1;
    Array.from(input.files).forEach((file, idx) => {
        const url = URL.createObjectURL(file);
        const type = file.type.startsWith('video') ? 'video' : 'image';
        const item = { type, url, element: null, name: file.name };
        if (type === 'video') {
            const vid = document.createElement('video'); vid.src = url; vid.muted = true; vid.loop = !APP.state.isCycle; vid.playsInline = true; vid.preload = 'auto'; item.element = vid; $('media-container').appendChild(vid);
        } else {
            // createObjectURL = native blob ref for GIF animation.
            // gif-host is ON-SCREEN (10px, behind canvas, overflow:hidden, opacity:0.01).
            // Browser composites the image = decoder advances GIF frames.
            // drawImage() reads intrinsic naturalWidth x naturalHeight for full quality.
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.src = url;
            item.element = img;
            var host = $('gif-host');
            if (host) host.appendChild(img);
        }
        APP.media.queue.push(item);
        if (isFirstLoad && idx === 0) rotateMedia();
    });
    updateQueueDisplay(); $('media-dot').classList.remove('off'); log(`MEDIA: +${input.files.length}`);
}


function ensureAudioChain() {
    if (APP.audio.analyzer) return;
    if (!APP.audio.ctx) APP.audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
    var ctx = APP.audio.ctx;
    APP.audio.analyzer = ctx.createAnalyser();
    APP.audio.analyzer.fftSize = 512;
    APP.audio.panner = ctx.createPanner();
    APP.audio.panner.panningModel = 'HRTF';
    APP.audio.panner.distanceModel = 'inverse';
    APP.audio.masterGain = ctx.createGain();
    APP.audio.masterGain.gain.value = 0.9;
    APP.audio.lowShelf = ctx.createBiquadFilter();
    APP.audio.lowShelf.type = 'lowshelf'; APP.audio.lowShelf.frequency.value = 60; APP.audio.lowShelf.gain.value = 0;
    APP.audio.highShelf = ctx.createBiquadFilter();
    APP.audio.highShelf.type = 'highshelf'; APP.audio.highShelf.frequency.value = 12000; APP.audio.highShelf.gain.value = 0;
    APP.audio.compressor = ctx.createDynamicsCompressor();
    APP.audio.compressor.threshold.value = -24; APP.audio.compressor.knee.value = 30; APP.audio.compressor.ratio.value = 1;
    APP.audio.outputLimiter = ctx.createDynamicsCompressor();
    APP.audio.outputLimiter.threshold.setValueAtTime(-1, ctx.currentTime);
    APP.audio.outputLimiter.knee.setValueAtTime(0, ctx.currentTime);
    APP.audio.outputLimiter.ratio.setValueAtTime(20, ctx.currentTime);
    APP.audio.outputLimiter.attack.setValueAtTime(0.001, ctx.currentTime);
    APP.audio.outputLimiter.release.setValueAtTime(0.1, ctx.currentTime);
    APP.audio.duckingGain = ctx.createGain();
    APP.audio.duckingGain.gain.setValueAtTime(1.0, ctx.currentTime);
    APP.audio.stereoGain = ctx.createGain();
    APP.audio.stereoGain.gain.setValueAtTime(1.0, ctx.currentTime);
    APP.audio.dolbyPanner = ctx.createPanner();
    APP.audio.dolbyPanner.panningModel = 'HRTF'; APP.audio.dolbyPanner.distanceModel = 'inverse'; APP.audio.dolbyPanner.refDistance = 1;
    if (APP.audio.dolbyPanner.positionX) { APP.audio.dolbyPanner.positionX.setValueAtTime(0, ctx.currentTime); APP.audio.dolbyPanner.positionY.setValueAtTime(5, ctx.currentTime); APP.audio.dolbyPanner.positionZ.setValueAtTime(-2, ctx.currentTime); }
    try { APP.audio.surroundSplitter = ctx.createChannelSplitter(6); APP.audio.surroundMerger = ctx.createChannelMerger(6); } catch(e) {}
    APP.audio.micAnalyzer = ctx.createAnalyser(); APP.audio.micAnalyzer.fftSize = 256;
    APP.audio.panner.connect(APP.audio.lowShelf).connect(APP.audio.highShelf).connect(APP.audio.compressor).connect(APP.audio.duckingGain).connect(APP.audio.analyzer).connect(APP.audio.masterGain).connect(APP.audio.outputLimiter).connect(ctx.destination);
    APP.audio.masterGain.connect(APP.audio.stereoGain);
    APP.audio.dolbyPanner.connect(APP.audio.outputLimiter);
    APP.audio.vuData = new Uint8Array(APP.audio.analyzer.frequencyBinCount);
    updateVU();
    log('DAW_CHAIN_READY');
}

function connectVideoAudio(vid) {
    if (!vid || vid.tagName !== 'VIDEO') return;
    try {
        if (!APP.audio.ctx) APP.audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (APP.audio.ctx.state === 'suspended') APP.audio.ctx.resume();
        ensureAudioChain();
        disconnectVideoAudio();
        if (!vid._audioSrc) vid._audioSrc = APP.audio.ctx.createMediaElementSource(vid);
        vid.muted = APP.audio.videoMuted;
        vid._audioSrc.connect(APP.audio.panner);
        vid._audioSrc.connect(APP.audio.dolbyPanner);
        APP.audio.videoSource = vid;
        $('btn-mute-vid').textContent = APP.audio.videoMuted ? '\u{1F507}' : '\u{1F50A}';
        if (APP.audio.videoMuted) $('btn-mute-vid').classList.add('on'); else $('btn-mute-vid').classList.remove('on');
        log('VIDEO_AUDIO: ' + (APP.audio.videoMuted ? 'MUTED' : 'ON'));
    } catch (e) { log('VIDEO_AUDIO_ERR: ' + e.message); }
}

function disconnectVideoAudio() {
    var vid = APP.audio.videoSource;
    if (!vid) return;
    try { if (vid._audioSrc) vid._audioSrc.disconnect(); vid.muted = true; } catch(e) {}
    APP.audio.videoSource = null;
}


function rotateMedia() {
    if (APP.media.queue.length === 0) return;
    APP.render.source = null; // Clear override so queue takes priority
    APP.vj.glitchSnap = 3;
    if (APP.media.currentElement?.tagName === 'VIDEO') APP.media.currentElement.pause(); disconnectVideoAudio();
    APP.media.currentIndex = (APP.media.currentIndex + 1) % APP.media.queue.length;
    const item = APP.media.queue[APP.media.currentIndex];
    // Guard: skip items still loading (async FileReader not done yet)
    if (!item.element) { APP.media.currentElement = null; return; }
    APP.media.currentElement = item.element;
    if (item.type === 'video') { item.element.loop = !APP.state.isCycle; item.element.currentTime = 0; item.element.play().catch(() => {});  connectVideoAudio(item.element); }
    checkCycleLogic();
}

function previousMedia() {
    if (APP.media.queue.length === 0) return;
    APP.vj.glitchSnap = 3;
    if (APP.media.currentElement?.tagName === 'VIDEO') APP.media.currentElement.pause(); disconnectVideoAudio();
    APP.media.currentIndex = (APP.media.currentIndex - 1 + APP.media.queue.length) % APP.media.queue.length;
    const item = APP.media.queue[APP.media.currentIndex];
    if (!item.element) { APP.media.currentElement = null; return; }
    APP.media.currentElement = item.element;
    if (item.type === 'video') { item.element.loop = !APP.state.isCycle; item.element.currentTime = 0; item.element.play().catch(() => {});  connectVideoAudio(item.element); }
    checkCycleLogic();
}

function ejectCurrent() {
    if (APP.media.queue.length === 0) return;
    APP.render.source = null; // Clear any override
    const current = APP.media.queue[APP.media.currentIndex];
    if (current.element?.tagName === 'VIDEO') { disconnectVideoAudio(); current.element.pause(); current.element.src = ''; current.element.remove(); }
    if (current.element?.tagName === 'IMG' && current.element.parentNode) { current.element.remove(); }
    if (current.url) URL.revokeObjectURL(current.url);
    APP.media.queue.splice(APP.media.currentIndex, 1);
    if (APP.media.queue.length === 0) { APP.media.currentIndex = -1; APP.media.currentElement = null; $('media-dot').classList.add('off'); APP.render.ctx.fillStyle = '#000'; APP.render.ctx.fillRect(0, 0, APP.render.width, APP.render.height); }
    else { if (APP.media.currentIndex >= APP.media.queue.length) APP.media.currentIndex = 0; const next = APP.media.queue[APP.media.currentIndex]; APP.media.currentElement = next.element; if (next.type === 'video') { next.element.currentTime = 0; next.element.play().catch(() => {}); } }
    updateQueueDisplay();
}

function clearDeck() {
    if(APP.state.isCycle) toggleCycle();
    APP.render.source = null; // Clear any override
    APP.media.queue.forEach(item => {
        if (item.element?.tagName === 'VIDEO') { item.element.pause(); item.element.src = ''; item.element.remove(); }
        if (item.element?.tagName === 'IMG' && item.element.parentNode) { item.element.remove(); }
        if (item.url) URL.revokeObjectURL(item.url);
    });
    APP.media.queue = []; APP.media.currentIndex = -1; APP.media.currentElement = null; $('media-dot').classList.add('off');
    updateQueueDisplay();
    log('DECK_CLEARED');
}

function panicReset() {
    resetAllFX();
    log('PANIC: SILENT_KILL');
}

function toggleCycle() {
    if (APP.media.queue.length === 0) return; 

    APP.state.isCycle = !APP.state.isCycle;
    const btn = $('btn-cycle-toggle');
    const header = $('media-header');
    
    if (APP.state.isCycle) {
        btn.innerHTML = 'CYCLE: ON';
        btn.classList.add('cycle-active'); 
        header.classList.add('scanning');
        $('cycle-badge').classList.add('on');
        checkCycleLogic();
    } else {
        btn.innerHTML = 'CYCLE: OFF';
        btn.classList.remove('cycle-active');
        header.classList.remove('scanning');
        $('cycle-badge').classList.remove('on');
        clearTimeout(APP.state.cycleTimer);
        if (APP.media.currentElement?.tagName === 'VIDEO') APP.media.currentElement.loop = true;
    }
}

function checkCycleLogic() {
    clearTimeout(APP.state.cycleTimer);
    if (!APP.state.isCycle || APP.media.currentIndex === -1) return;
    const current = APP.media.queue[APP.media.currentIndex];
    if (!current) return;
    if (current.type === 'video') { if (current.element) { current.element.loop = false; current.element.onended = () => { if (APP.state.isCycle) rotateMedia(); }; } }
    else { const secs = parseInt($('sl-cycle').value) || 8; APP.state.cycleTimer = setTimeout(() => { if (APP.state.isCycle) rotateMedia(); }, secs * 1000); }
}

function updateQueueDisplay() {
    const count = APP.media.queue.length;
    if($('q-info')) $('q-info').textContent = count; 
    const btn = $('btn-load-media');
    if (count > 0) {
        btn.innerHTML = `MEDIA LOADED [ ${count} ]`;
        btn.classList.add('active-mode');
        $('media-dot').classList.remove('off');
    } else {
        btn.innerHTML = 'LOAD MEDIA';
        btn.classList.remove('active-mode');
        $('media-dot').classList.add('off');
    }
}

// CAMERA
async function initCamera() {
    try {
        APP.camera.stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 3840 }, height: { ideal: 2160 }, frameRate: { ideal: 60, min: 30 } }, audio: false });
        APP.camera.videoEl = document.createElement('video');
        APP.camera.videoEl.srcObject = APP.camera.stream;
        APP.camera.videoEl.muted = true; APP.camera.videoEl.playsInline = true; APP.camera.videoEl.play().catch(() => {});
        APP.camera.mode = 'preview';
        $('btn-init-cam').style.display = 'none';
        $('cam-ctrls').style.display = 'block';
        $('btn-kill').style.display = 'block';
        $('cam-dot').classList.remove('off');
        log('CAM_ONLINE');
        if (!APP.audio.ctx) { APP.audio.ctx = new (window.AudioContext || window.webkitAudioContext)(); }

        // Activate floating camera preview box
        const preview = $('cam-preview-float');
        const previewVid = $('preview-vid-float');
        if (preview && previewVid) {
            previewVid.srcObject = APP.camera.stream;
            preview.classList.add('active');
            APP.camera.previewEl = previewVid;
        }
    } catch (e) { log('CAM_DENIED'); }
}

$('btn-inject').onclick = () => {
    if(!APP.camera.stream) return;
    const btn = $('btn-inject');
    if (APP.loop.recorder && APP.loop.recorder.state === 'recording') { APP.loop.recorder.stop(); return; }
    APP.loop.chunks = [];
    APP.loop.recorder = new MediaRecorder(APP.camera.stream, { mimeType: 'video/webm' }); 
    APP.loop.recorder.ondataavailable = e => APP.loop.chunks.push(e.data);
    APP.loop.recorder.onstop = () => {
        clearInterval(APP.loop.timer);
        const blob = new Blob(APP.loop.chunks, { type: 'video/webm' });
        if(APP.loop.activeUrl) URL.revokeObjectURL(APP.loop.activeUrl);
        APP.loop.activeUrl = URL.createObjectURL(blob);
        const vid = document.createElement('video');
        vid.src = APP.loop.activeUrl;
        vid.muted = true; vid.loop = true; vid.play();
        const item = { type: 'video', url: APP.loop.activeUrl, element: vid, name: 'LOOP_SAMPLE' };
        APP.media.queue.push(item);
        APP.media.currentIndex = APP.media.queue.length - 1;
        APP.media.currentElement = vid;
        APP.state.isLive = false; 
        btn.innerText = 'INJECT LOOP (10s)'; btn.classList.remove('on'); updateQueueDisplay(); log('LOOP_INJECTED');
    };
    APP.loop.recorder.start(); btn.classList.add('on'); APP.loop.counter = 10; btn.innerText = `SAMPLING... ${APP.loop.counter}`;
    APP.loop.timer = setInterval(() => { APP.loop.counter--; btn.innerText = `SAMPLING... ${APP.loop.counter}`; if(APP.loop.counter <= 0) APP.loop.recorder.stop(); }, 1000);
};

function goLive() {
    if (!APP.camera.stream) return;
    const overlay = $('countdown'); const num = $('countdown-num'); const btn = $('btn-go-live');
    overlay.style.display = 'flex'; let count = 3; num.textContent = count; btn.textContent = `LIVE IN ${count}...`; 
    const interval = setInterval(() => {
        count--;
        if (count > 0) { num.textContent = count; btn.textContent = `LIVE IN ${count}...`; }
        else { 
            clearInterval(interval); overlay.style.display = 'none'; APP.state.isLive = true; APP.camera.mode = 'live'; var _pf = $('cam-preview-float'); if (_pf) { _pf.classList.remove('active'); _pf.style.display = 'none'; } 
            $('cam-ctrls').style.display = 'none'; $('live-ctrls').style.display = 'block'; $('tally').style.display = 'block'; $('status-text').textContent = 'LIVE'; $('main-dot').classList.add('live'); 
            document.querySelector('.preview-label').textContent = 'LIVE'; log('LIVE_PODCAST_MODE'); 
        }
    }, 1000);
}

$('btn-rec').onclick = () => {
    const btn = $('btn-rec');
    if(APP.broadcast.isRecording) {
        APP.broadcast.recorder.stop(); APP.broadcast.isRecording = false; btn.innerText = 'SAVING...'; btn.classList.remove('active'); 
        $('rec-status').style.display = 'none'; 
    } else {
        const stream = APP.render.canvas.captureStream(60);
        if(APP.audio.source && APP.audio.ctx) {
            const dest = APP.audio.ctx.createMediaStreamDestination();
            APP.audio.source.connect(dest);
            if(APP.audio.masterGain) APP.audio.masterGain.connect(dest);
            if(APP.audio.micGainNode) APP.audio.micGainNode.connect(dest);
            if(dest.stream.getAudioTracks().length > 0) stream.addTrack(dest.stream.getAudioTracks()[0]);
        }
        APP.broadcast.chunks = [];
        let bcastOpts = { mimeType: 'video/webm;codecs=vp9,opus', videoBitsPerSecond: 15000000, audioBitsPerSecond: 128000 };
        try { APP.broadcast.recorder = new MediaRecorder(stream, bcastOpts); }
        catch(e) { APP.broadcast.recorder = new MediaRecorder(stream, { mimeType: 'video/webm' }); }
        APP.broadcast.recorder.ondataavailable = e => APP.broadcast.chunks.push(e.data);
        APP.broadcast.recorder.onstop = () => {
            const blob = new Blob(APP.broadcast.chunks, { type: 'video/webm' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `VNGRD_BROADCAST_${Date.now()}.webm`; a.click(); btn.innerText = 'REC_BROADCAST'; log('BROADCAST_SAVED');
        };
        APP.broadcast.recorder.start(1000); APP.broadcast.isRecording = true; btn.innerText = '■ STOP & SAVE'; btn.classList.add('active'); 
        $('rec-status').style.display = 'block'; 
    }
};

function endLive() { 
    APP.state.isLive = false; APP.camera.mode = 'preview'; $('live-ctrls').style.display = 'none'; $('cam-ctrls').style.display = 'block'; $('tally').style.display = 'none'; $('status-text').textContent = 'STANDBY'; $('main-dot').classList.remove('live'); $('btn-go-live').textContent = 'GO LIVE [3-2-1]'; var _pf3 = $('cam-preview-float'); if (_pf3 && APP.camera.stream) { _pf3.style.display = ''; _pf3.classList.add('active'); } 
    log('END_LIVE'); 
    $('rec-status').style.display = 'none';
}

function killCamera() { 
    if (APP.camera.stream) APP.camera.stream.getTracks().forEach(t => t.stop()); 
    if (APP.camera.videoEl) { APP.camera.videoEl.srcObject = null; APP.camera.videoEl = null; } 
    APP.camera.mode = 'off'; APP.state.isLive = false; $('live-ctrls').style.display = 'none'; $('cam-ctrls').style.display = 'none'; $('btn-init-cam').style.display = 'block'; $('btn-kill').style.display = 'none'; $('cam-dot').classList.add('off'); $('tally').style.display = 'none'; $('status-text').textContent = 'STANDBY'; $('main-dot').classList.remove('live'); var _pf2 = $('cam-preview-float'); if (_pf2) { _pf2.classList.remove('active'); _pf2.style.display = 'none'; } if (APP.camera.previewEl) { APP.camera.previewEl.srcObject = null; APP.camera.previewEl = null; } log('CAM_OFF'); 
    $('rec-status').style.display = 'none';
}

function showLowerThird(preset) {
    const lt = $('lower-third'); const container = lt.querySelector('.lt-container');
    container.classList.remove('lt-guest', 'lt-track', 'lt-breaking'); container.classList.add(`lt-${preset}`);
    APP.lowerThird.preset = preset; APP.lowerThird.visible = true;
    if (preset === 'track' && APP.audio.currentTrackName) { $('lt-title-text').textContent = APP.audio.currentTrackName; $('lt-subtitle-text').textContent = 'NOW PLAYING'; }
    else if (preset === 'breaking') { $('lt-title-text').textContent = $('lt-title').value || 'BREAKING NEWS'; $('lt-subtitle-text').textContent = $('lt-sub').value || 'LIVE UPDATE'; }
    else { $('lt-title-text').textContent = $('lt-title').value || 'GUEST NAME'; $('lt-subtitle-text').textContent = $('lt-sub').value || 'TITLE / ROLE'; }
    lt.classList.add('visible');
    ['guest', 'track', 'breaking', 'off'].forEach(p => { $(`btn-lt-${p}`).classList.toggle('on', p === preset); });
}
function hideLowerThird() { $('lower-third').classList.remove('visible'); APP.lowerThird.visible = false; ['guest', 'track', 'breaking', 'off'].forEach(p => { $(`btn-lt-${p}`).classList.remove('on'); }); $('btn-lt-off').classList.add('on'); }

// AUDIO ENGINEER IMPLEMENTATION
APP.audio.element = $('audio-el');
function loadAudioFiles(input) { Array.from(input.files).forEach(file => { APP.audio.playlist.push({ url: URL.createObjectURL(file), name: file.name.replace(/\.[^.]+$/, '') }); }); $('audio-dot').classList.remove('off'); if (!APP.audio.isPlaying && APP.audio.playlist.length) { disconnectVideoAudio(); playTrack(0); } log(`AUDIO: +${input.files.length}`); }

function playTrack(idx) {
    if (!APP.audio.playlist.length) return;
    if (idx !== undefined) APP.audio.currentTrack = idx;
    else if (APP.audio.currentTrack === -1) APP.audio.currentTrack = 0;
    const track = APP.audio.playlist[APP.audio.currentTrack];
    APP.audio.currentTrackName = track.name;
    APP.audio.element.src = track.url;
    
    // Ensure Context
    if (!APP.audio.ctx) APP.audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
    
    APP.audio.element.play().then(() => { 
        APP.audio.isPlaying = true; 
        $('track-info').textContent = track.name.toUpperCase(); 
        if (APP.lowerThird.visible && APP.lowerThird.preset === 'track') $('lt-title-text').textContent = track.name; 
        log(`PLAY: ${track.name}`); 
        updatePlayIcon();
    });
    if (!APP.audio.isConnected) setupAudioChain();
}

function nextTrack() {
    if (!APP.audio.playlist.length) return;
    APP.audio.currentTrack = (APP.audio.currentTrack + 1) % APP.audio.playlist.length;
    playTrack(APP.audio.currentTrack);
}

function prevTrack() {
    if (!APP.audio.playlist.length) return;
    APP.audio.currentTrack = (APP.audio.currentTrack - 1 + APP.audio.playlist.length) % APP.audio.playlist.length;
    playTrack(APP.audio.currentTrack);
}

function togglePlayPause() {
    if (!APP.audio.playlist.length) return;
    if (APP.audio.element.paused) {
        if (APP.audio.element.src) APP.audio.element.play();
        else playTrack();
    } else {
        APP.audio.element.pause();
    }
    APP.audio.isPlaying = !APP.audio.element.paused;
    updatePlayIcon();
}

function updatePlayIcon() {
    const icon = $('icon-play-state');
    if(APP.audio.isPlaying) {
        icon.innerHTML = '<path fill="currentColor" d="M3 2h2v8H3zm4 0h2v8H7z"/>';
    } else {
        icon.innerHTML = '<path fill="currentColor" d="M3 2v8l7-4z"/>';
    }
}

function setupAudioChain() {
    const ctx = APP.audio.ctx;
    if (APP.audio.source) APP.audio.source.disconnect();
    APP.audio.source = ctx.createMediaElementSource(APP.audio.element);
    APP.audio.analyzer = ctx.createAnalyser();
    APP.audio.analyzer.fftSize = 512;
    APP.audio.masterGain = ctx.createGain();
    APP.audio.masterGain.gain.value = 0.9;
    
    // 3D Spatial
    APP.audio.panner = ctx.createPanner();
    APP.audio.panner.panningModel = 'HRTF';
    APP.audio.panner.distanceModel = 'inverse';
    
    // Dolby Emulation (EQ + Comp)
    APP.audio.lowShelf = ctx.createBiquadFilter();
    APP.audio.lowShelf.type = "lowshelf";
    APP.audio.lowShelf.frequency.value = 60; 
    APP.audio.lowShelf.gain.value = 0; 
    APP.audio.highShelf = ctx.createBiquadFilter();
    APP.audio.highShelf.type = "highshelf";
    APP.audio.highShelf.frequency.value = 12000;
    APP.audio.highShelf.gain.value = 0; 
    APP.audio.compressor = ctx.createDynamicsCompressor();
    APP.audio.compressor.threshold.value = -24; 
    APP.audio.compressor.knee.value = 30;
    APP.audio.compressor.ratio.value = 1; 

    // ═══ Phase 2: OUTPUT LIMITER (Hard 0dB ceiling) ═══
    APP.audio.outputLimiter = ctx.createDynamicsCompressor();
    APP.audio.outputLimiter.threshold.setValueAtTime(-1, ctx.currentTime);
    APP.audio.outputLimiter.knee.setValueAtTime(0, ctx.currentTime);
    APP.audio.outputLimiter.ratio.setValueAtTime(20, ctx.currentTime);
    APP.audio.outputLimiter.attack.setValueAtTime(0.001, ctx.currentTime);
    APP.audio.outputLimiter.release.setValueAtTime(0.1, ctx.currentTime);

    // ═══ Phase 2: SIDE-CHAIN DUCKING GAIN ═══
    APP.audio.duckingGain = ctx.createGain();
    APP.audio.duckingGain.gain.setValueAtTime(1.0, ctx.currentTime);

    // ═══ Phase 2: TRIPLE-PATH STEREO TAP ═══
    APP.audio.stereoGain = ctx.createGain();
    APP.audio.stereoGain.gain.setValueAtTime(1.0, ctx.currentTime);

    // ═══ Phase 2: DOLBY HRTF PATH ═══
    APP.audio.dolbyPanner = ctx.createPanner();
    APP.audio.dolbyPanner.panningModel = 'HRTF';
    APP.audio.dolbyPanner.distanceModel = 'inverse';
    APP.audio.dolbyPanner.refDistance = 1;
    if (APP.audio.dolbyPanner.positionX) {
        APP.audio.dolbyPanner.positionX.setValueAtTime(0, ctx.currentTime);
        APP.audio.dolbyPanner.positionY.setValueAtTime(5, ctx.currentTime);
        APP.audio.dolbyPanner.positionZ.setValueAtTime(-2, ctx.currentTime);
    }

    // ═══ Phase 2: SURROUND 5.1 SPLITTER ═══
    try {
        APP.audio.surroundSplitter = ctx.createChannelSplitter(6);
        APP.audio.surroundMerger = ctx.createChannelMerger(6);
    } catch(e) { /* 5.1 not supported */ }

    // ═══ Phase 2: Mic analyzer for ducking ═══
    APP.audio.micAnalyzer = ctx.createAnalyser();
    APP.audio.micAnalyzer.fftSize = 256;

    // Upgraded routing: Source -> Panner -> EQ -> Comp -> Ducking -> Analyzer -> MasterGain -> Limiter -> Destination
    APP.audio.source
        .connect(APP.audio.panner)
        .connect(APP.audio.lowShelf)
        .connect(APP.audio.highShelf)
        .connect(APP.audio.compressor)
        .connect(APP.audio.duckingGain)
        .connect(APP.audio.analyzer)
        .connect(APP.audio.masterGain)
        .connect(APP.audio.outputLimiter)
        .connect(ctx.destination);

    // Stereo monitoring tap
    APP.audio.masterGain.connect(APP.audio.stereoGain);

    // Dolby HRTF parallel path
    APP.audio.source.connect(APP.audio.dolbyPanner);
    APP.audio.dolbyPanner.connect(APP.audio.outputLimiter);

    APP.audio.vuData = new Uint8Array(APP.audio.analyzer.frequencyBinCount); 
    APP.audio.isConnected = true;
    log('DAW_ENGINE: TRIPLE_PATH + LIMITER + DUCKING');
    updateVU();
}

function setAudioMode(mode) {
    if(!APP.audio.ctx) return;
    const now = APP.audio.ctx.currentTime;
    clearInterval(APP.audio.spatialInterval);
    
    APP.audio.panner.positionX.value = 0;
    APP.audio.panner.positionZ.value = 0;
    APP.audio.lowShelf.gain.setTargetAtTime(0, now, 0.1);
    APP.audio.highShelf.gain.setTargetAtTime(0, now, 0.1);
    APP.audio.compressor.ratio.setTargetAtTime(1, now, 0.1); 
    
    if (mode === 'stereo') { log('AUDIO: PURE STEREO'); }
    else if (mode === 'spatial') {
        log('AUDIO: 3D ROTATION');
        let angle = 0;
        APP.audio.spatialInterval = setInterval(() => {
            angle += 0.02;
            APP.audio.panner.positionX.value = Math.sin(angle);
            APP.audio.panner.positionZ.value = Math.cos(angle);
        }, 16);
    }
    else if (mode === 'dolby') {
        log('AUDIO: DOLBY CINEMA DSP');
        APP.audio.lowShelf.gain.setTargetAtTime(4, now, 0.1);
        APP.audio.highShelf.gain.setTargetAtTime(4, now, 0.1);
        APP.audio.compressor.ratio.setTargetAtTime(12, now, 0.1);
        APP.audio.compressor.threshold.setTargetAtTime(-30, now, 0.1);
        APP.audio.compressor.attack.setTargetAtTime(0.003, now, 0.1);
    }
    
    APP.audio.spatialMode = mode;
    ['stereo', 'spatial', 'dolby'].forEach(m => {
        const btn = $(`btn-${m}`);
        if(m === mode) btn.classList.add('active-mode');
        else btn.classList.remove('active-mode');
    });
}

function updateVU() {
    requestAnimationFrame(updateVU);
    if (!APP.audio.analyzer || (!APP.audio.isPlaying && !APP.audio.videoSource)) return;
    APP.audio.analyzer.getByteFrequencyData(APP.audio.vuData);
    const bars = $('vu').children;
    if (bars.length === 0) { const vu = $('vu'); for (let i = 0; i < 16; i++) { const b = document.createElement('div'); b.className = 'vu-bar'; vu.appendChild(b); } }
    // Map 256 bins across 16 bars
    for (let i = 0; i < bars.length; i++) bars[i].style.height = Math.max(2, (APP.audio.vuData[i * 16] / 255) * 28) + 'px';

    // KICK SENSOR: bins 0-9 (sub-bass)
    var kickSum = 0; for (var k = 0; k < 10; k++) kickSum += APP.audio.vuData[k];
    APP.audio.kick = kickSum / 10;

    // HIGH SENSOR: bins 100-149 (treble)
    var highSum = 0; for (var h = 100; h < 150; h++) highSum += APP.audio.vuData[h];
    APP.audio.highs = highSum / 50;

    // Legacy bassLevel
    APP.audio.bassLevel = APP.audio.kick;

    // PARTY reactive: only on highs > 175
    if (APP.vj.uiReactivity && APP.audio.highs > 175) {
        document.body.style.boxShadow = 'inset 0 0 ' + (APP.audio.highs / 2) + 'px var(--accent)';
    } else if (APP.vj.uiReactivity) {
        document.body.style.boxShadow = 'none';
    }
}

$('btn-save-session').onclick = () => {
    // Capture 2D Logo as Base64
    var logo64 = null;
    var logoEl = $('user-logo-layer');
    if (logoEl && logoEl.src && logoEl.src !== window.location.href && logoEl.naturalWidth > 0) {
        try {
            var tmpC = document.createElement('canvas');
            tmpC.width = logoEl.naturalWidth;
            tmpC.height = logoEl.naturalHeight;
            tmpC.getContext('2d').drawImage(logoEl, 0, 0);
            logo64 = tmpC.toDataURL('image/png');
        } catch(e) { log('LOGO_CAPTURE_ERR'); }
    }
    // Capture Lower Third text
    var ltTitleEl = $('lt-title-text');
    var ltSubEl = $('lt-subtitle-text');
    var ltTitle = (ltTitleEl && ltTitleEl.textContent) ? ltTitleEl.textContent : '';
    var ltSub = (ltSubEl && ltSubEl.textContent) ? ltSubEl.textContent : '';

    const session = {
        vj: APP.vj,
        theme: APP.state.theme,
        bug: APP.bug.text,
        layers: APP.layers,
        hologramScale: APP.hologram.scale,
        logo2d: logo64,
        lowerThird: { title: ltTitle, subtitle: ltSub, preset: APP.lowerThird.preset, visible: APP.lowerThird.visible },
        timestamp: Date.now()
    };
    localStorage.setItem('VNGRD_SESSION', JSON.stringify(session));
    log('RAM_SECURED');
    if(confirm("SESSION SECURED IN INTERNAL RAM.\n\nDOWNLOAD PHYSICAL BACKUP (.VGD)?")) {
        const blob = new Blob([JSON.stringify(session)], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `VNGRD_SESSION_${Date.now()}.vgd`; a.click();
        log('BACKUP_SAVED');
    }
};

// VGD FILE IMPORT
$('btn-import-dna').onclick = () => $('file-vgd').click();
$('file-vgd').onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
        try {
            const s = JSON.parse(ev.target.result);
            // Dispose existing 3D scene before importing new state
            if (APP.hologram && APP.hologram.scene) {
                if (APP.hologram.mesh) {
                    APP.hologram.scene.remove(APP.hologram.mesh);
                    APP.hologram.mesh.traverse(function(c) { if (c.isMesh) { if (c.geometry) c.geometry.dispose(); if (c.material) c.material.dispose(); } });
                }
                if (APP.hologram.renderer) APP.hologram.renderer.dispose();
                APP.hologram.mesh = null; APP.hologram.renderer = null; APP.hologram.scene = null; APP.hologram.camera = null;
            }
            // Restore state
            if (s.theme) setTheme(s.theme);
            if (s.bug) { APP.bug.text = s.bug; $('bug-text').value = s.bug; $('station-bug').textContent = s.bug; }
            if (s.vj) { APP.vj = { ...APP.vj, ...s.vj }; }
            if (s.layers) {
                APP.layers = { ...APP.layers, ...s.layers };
                APP.trinity.logo.scale = APP.layers.logoScale || 1.0;
                APP.trinity.bug.scale = APP.layers.bugScale || 1.5;
            }
            if (s.hologramScale) APP.hologram.scale = s.hologramScale;
            // Restore 2D Logo from Base64 — validate before assigning to prevent ERR_INVALID_URL
            if (s.logo2d) {
                var logoLayer = $('user-logo-layer');
                if (logoLayer) {
                    logoLayer.style.display = 'block';
                    logoLayer.style.position = 'fixed';
                    logoLayer.style.bottom = '0';
                    logoLayer.style.left = '0';
                    logoLayer.style.width = '10px';
                    logoLayer.style.height = '10px';
                    logoLayer.style.opacity = '0.01';
                    logoLayer.style.zIndex = '-1';
                    logoLayer.style.objectFit = 'cover';
                    logoLayer.src = s.logo2d;
                    APP.trinity.logo.visible = true;
                    log('2D_LOGO: RESTORED_FROM_VGD');
                }
            }
            // Restore Lower Third text + state
            if (s.lowerThird) {
                if (s.lowerThird.title && $('lt-title-text')) $('lt-title-text').textContent = s.lowerThird.title;
                if (s.lowerThird.subtitle && $('lt-subtitle-text')) $('lt-subtitle-text').textContent = s.lowerThird.subtitle;
                if (s.lowerThird.title && $('lt-title')) $('lt-title').value = s.lowerThird.title;
                if (s.lowerThird.subtitle && $('lt-sub')) $('lt-sub').value = s.lowerThird.subtitle;
                if (s.lowerThird.preset) APP.lowerThird.preset = s.lowerThird.preset;
                APP.lowerThird.visible = !!s.lowerThird.visible;
                log('LOWER_THIRD: RESTORED_FROM_VGD');
            }
            // Restore VJ sliders
            if ($('sl-b')) $('sl-b').value = Math.round(APP.vj.brightness * 100);
            if ($('sl-c')) $('sl-c').value = Math.round(APP.vj.contrast * 100);
            if ($('sl-s')) $('sl-s').value = Math.round(APP.vj.saturation * 100);
            if ($('sl-h')) $('sl-h').value = APP.vj.hue;
            log('VGD_IMPORTED: ' + file.name.toUpperCase());
            alert('Session restored from ' + file.name);
        } catch(err) { log('VGD_IMPORT_ERR: ' + err.message); alert('Invalid VGD file'); }
    };
    reader.readAsText(file);
    e.target.value = '';
};

function isValidDataURI(str) {
    // Reject null, empty, or corrupt data URIs
    if (!str || typeof str !== 'string') return false;
    // Must start with data:image/ — reject data:; or data:application/ etc
    if (!str.startsWith('data:image/')) return false;
    // Must have ;base64, marker
    if (str.indexOf(';base64,') === -1) return false;
    // Must have actual base64 data after the comma (at least 100 chars for a real image)
    var commaIdx = str.indexOf(',');
    if (commaIdx === -1 || str.length - commaIdx < 100) return false;
    return true;
}
function loadFromMemory() {
    const data = localStorage.getItem('VNGRD_SESSION');
    if(!data) return;
    try {
        const s = JSON.parse(data);
        if(s.theme) setTheme(s.theme);
        if(s.bug) { APP.bug.text = s.bug; if ($('bug-text')) $('bug-text').value = s.bug; var _bugEl = $('station-bug'); if (_bugEl) _bugEl.textContent = s.bug; }
        if(s.vj) { APP.vj = { ...APP.vj, ...s.vj }; }
        if(s.layers) { APP.layers = { ...APP.layers, ...s.layers }; APP.trinity.logo.scale = APP.layers.logoScale || 1.0; APP.trinity.bug.scale = APP.layers.bugScale || 1.5; }
        // Restore 2D Logo from Base64 — strict validation to prevent net::ERR_INVALID_URL
        if (s.logo2d) {
            if (isValidDataURI(s.logo2d)) {
                var _ll = $('user-logo-layer');
                if (_ll) { _ll.style.display = 'block'; _ll.style.position = 'fixed'; _ll.style.bottom = '0'; _ll.style.left = '0'; _ll.style.width = '10px'; _ll.style.height = '10px'; _ll.style.opacity = '0.01'; _ll.style.zIndex = '-1'; _ll.style.objectFit = 'cover'; _ll.src = s.logo2d; APP.trinity.logo.visible = true; }
            } else {
                // Corrupt logo data — purge it from the saved session
                log('MEMORY: CORRUPT_LOGO_PURGED');
                s.logo2d = null;
                localStorage.setItem('VNGRD_SESSION', JSON.stringify(s));
            }
        }
        // Restore Lower Third
        if (s.lowerThird) {
            if (s.lowerThird.title && $('lt-title-text')) $('lt-title-text').textContent = s.lowerThird.title;
            if (s.lowerThird.subtitle && $('lt-subtitle-text')) $('lt-subtitle-text').textContent = s.lowerThird.subtitle;
            if (s.lowerThird.preset) APP.lowerThird.preset = s.lowerThird.preset;
            APP.lowerThird.visible = !!s.lowerThird.visible;
        }
        log('MEMORY_RESTORED');
    } catch(e) { log('MEMORY_CORRUPT'); }
}

function startNFTRecording() {
    if (APP.nft.isRecording) { stopNFTRecording(); return; }
    try {
        const canvasStream = APP.render.canvas.captureStream(60);
        if (APP.audio.source && APP.audio.ctx) {
            const nftDest = APP.audio.ctx.createMediaStreamDestination();
            APP.audio.source.connect(nftDest);
            if (APP.audio.masterGain) APP.audio.masterGain.connect(nftDest);
            if (APP.audio.micGainNode) APP.audio.micGainNode.connect(nftDest);
            if (nftDest.stream.getAudioTracks().length > 0) canvasStream.addTrack(nftDest.stream.getAudioTracks()[0]);
        }
        let nftRecorderOpts = { mimeType: 'video/webm;codecs=vp9,opus', videoBitsPerSecond: 5000000, audioBitsPerSecond: 128000 };
        try { APP.nft.recorder = new MediaRecorder(canvasStream, nftRecorderOpts); }
        catch(e) { APP.nft.recorder = new MediaRecorder(canvasStream, { mimeType: 'video/webm' }); }
        APP.nft.chunks = [];
        APP.nft.recorder.ondataavailable = e => APP.nft.chunks.push(e.data);
        APP.nft.recorder.onstop = finalizeNFT;
        APP.nft.recorder.start(1000);
        APP.nft.isRecording = true; APP.nft.startTime = Date.now();
        $('btn-nft-30').textContent = '■ STOP REC'; $('btn-nft-30').classList.add('on'); $('nft-hud').classList.add('active');
        updateNFTTimer();
        setTimeout(() => { if (APP.nft.isRecording) stopNFTRecording(); }, 30000);
        log('NFT_REC_START');
    } catch (e) { log('NFT_REC_ERR'); }
}
function stopNFTRecording() { 
    if (!APP.nft.isRecording) return; 
    APP.nft.recorder.stop(); 
    APP.nft.isRecording = false; 
    
    // UI - Keep the ID btn-nft-30 so the click still works, but change what the user sees
    $('btn-nft-30').textContent = 'CAPTURE_VGD_CLIP'; 
    $('btn-nft-30').classList.remove('on'); 
    $('nft-hud').classList.remove('active'); 
    
    log('VGD_REC_STOP'); 
}

function updateNFTTimer() { 
    if (!APP.nft.isRecording) return; 
    
    const elapsed = Date.now() - APP.nft.startTime; 
    const totalSeconds = Math.floor(elapsed / 1000);
    const mins = Math.floor(totalSeconds / 60);
    const secs = totalSeconds % 60;
    
    // Dynamic timer that handles 30s, 30m, or 3 hours
    $('nft-timer').textContent = `${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`; 
    
    // Progress bar stays full/active instead of stopping at 30s
    $('nft-fill').style.width = `100%`;
    
    requestAnimationFrame(updateNFTTimer); 
}

function finalizeNFT() { 
    const blob = new Blob(APP.nft.chunks, { type: 'video/webm' }); 
    const url = URL.createObjectURL(blob); 
    const a = document.createElement('a'); 
    a.href = url; 
    
    // THE FIX: Save as VGD, not NFT
    a.download = `VNGRD_VGD_${Date.now()}.webm`; 
    
    a.click(); 
    APP.nft.chunks = []; 
    log('VGD_EXPORTED'); 
}

function openProjector() { 
    if (APP.projector.isOpen) return; 
    APP.projector.stream = APP.render.canvas.captureStream(60); 
    APP.projector.window = window.open('', 'DRIS_Projector', 'width=1280,height=720,menubar=no,toolbar=no'); 
    APP.projector.window.document.write('<!DOCTYPE html><html><body style="margin:0;background:#000;overflow:hidden"><video id="pf" autoplay muted playsinline style="width:100vw;height:100vh;object-fit:contain"></video><script>document.getElementById("pf").srcObject = window.opener.APP.projector.stream;<\/script></body></html>'); 
    APP.projector.isOpen = true; 
    $('btn-projector').classList.add('on'); 
    log('PROJECTOR_OPEN'); 
}
// --- KINETIC SNAP ENGINE ---
function triggerIndustrialSnap(nextImageUrl) {
    const stage = document.getElementById('main-stage-img'); 
    if (!stage) return;

    stage.classList.remove('kinetic-shutter');
    void stage.offsetWidth; // Force CSS restart
    stage.classList.add('kinetic-shutter');

    setTimeout(() => {
        stage.src = nextImageUrl;
        log('SYSTEM: FRAME_CAPTURED');
    }, 200); 
}

// THE TRIGGER: This ensures the projector logic and snap logic coexist
if (typeof log === 'function') log('PROJECTOR_SYSTEM_LINKED');
// UI
function setTheme(theme) { document.body.className = document.body.className.replace(/theme-\w+/g, '').replace('system-failure', ''); if (theme !== 'cyan') document.body.classList.add(`theme-${theme}`); APP.state.theme = theme; document.querySelectorAll('.pal').forEach(p => p.classList.toggle('on', p.dataset.t === theme)); log(`THEME: ${theme}`); }
// toggleVHS replaced with VHS_AGGRESSIVE
// toggleCRT replaced with SCAN_TEAR
function toggleFullscreen() { APP.state.isFullscreen = !APP.state.isFullscreen; document.body.classList.toggle('fullscreen', APP.state.isFullscreen); $('btn-fs').classList.toggle('on', APP.state.isFullscreen); log('FULLSCREEN'); }

function morphLogo() { const logo = $('main-logo'); APP.ui.morphs.forEach(m => logo.classList.remove(m)); APP.ui.logoMorph = (APP.ui.logoMorph + 1) % APP.ui.morphs.length; logo.classList.add(APP.ui.morphs[APP.ui.logoMorph]); }
function updateClock() { $('clock').textContent = new Date().toTimeString().split(' ')[0]; const s = Math.floor((Date.now() - APP.state.startTime) / 1000); $('uptime').textContent = `${String(Math.floor(s/3600)).padStart(2,'0')}:${String(Math.floor((s%3600)/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`; }

// EMERGENCY
$('btn-panic').onclick = panicReset;
$('btn-clear-deck').onclick = clearDeck;
$('btn-eject').onclick = ejectCurrent;

// SYSTEM FAILURE MODE - Timed chaos sequence that auto-stops (5 seconds)
$('btn-psychosis').onclick = () => {
    if (APP.state.psychosis) return; // Prevent double-triggering
    
    APP.state.psychosis = true;
    document.body.classList.add('system-failure');
    $('btn-psychosis').classList.add('active-mode');
    log('CRITICAL: SYSTEM FAILURE DETECTED');
    
    // Store original states
    const origRGB = APP.vj.rgbEnabled;
    const origRGBIntensity = APP.vj.rgbIntensity;
    const origPixelate = APP.vj.pixelateEnabled;
    const origPixelSize = APP.vj.pixelSize;
    const origHue = APP.vj.hue;
    const origTrails = APP.vj.trailsEnabled;
    const origTrailAlpha = APP.vj.trailAlpha;
    
    let tick = 0;
    const totalTicks = 100; // 5 seconds at 50ms
    
    const chaos = setInterval(() => {
        tick++;
        
        // Phase 1: Hue rotation + RGB (0-35)
        if (tick <= 35) {
            APP.vj.hue = (tick * 10) % 360;
            APP.vj.rgbEnabled = true;
            APP.vj.rgbIntensity = 5 + Math.floor(Math.random() * 12);
        }
        // Phase 2: Pixelate + trails + wobble (35-70)
        else if (tick <= 70) {
            APP.vj.pixelateEnabled = tick % 3 !== 0;
            APP.vj.pixelSize = 2 + Math.floor(Math.random() * 8);
            APP.vj.trailsEnabled = true;
            APP.vj.trailAlpha = 0.65 + Math.random() * 0.25;
            // Wobble effect
            const wobbleX = Math.sin(tick * 0.4) * 10;
            const wobbleY = Math.cos(tick * 0.5) * 8;
            document.body.style.transform = `translate(${wobbleX}px, ${wobbleY}px)`;
        }
        // Phase 3: Recovery + invert flashes (70-100)
        else {
            APP.vj.rgbIntensity = Math.max(0, APP.vj.rgbIntensity - 0.8);
            APP.vj.pixelSize = Math.max(1, APP.vj.pixelSize - 0.3);
            if (tick % 5 === 0) APP.vj.invert = !APP.vj.invert;
            if (tick > 85) document.body.style.transform = '';
        }
        
        // End sequence
        if (tick >= totalTicks) {
            clearInterval(chaos);
            
            // Restore everything
            APP.vj.rgbEnabled = origRGB;
            APP.vj.rgbIntensity = origRGBIntensity;
            APP.vj.pixelateEnabled = origPixelate;
            APP.vj.pixelSize = origPixelSize;
            APP.vj.hue = origHue;
            APP.vj.trailsEnabled = origTrails;
            APP.vj.trailAlpha = origTrailAlpha;
            APP.vj.invert = false;
            document.body.style.transform = '';
            
            APP.state.psychosis = false;
            document.body.classList.remove('system-failure');
            $('btn-psychosis').classList.remove('active-mode');
            log('SYSTEM RESTORED');
        }
    }, 50);
};

// RESET ALL FX — clears IMPACT_RACK flags + restores VJ defaults
function resetAllFX() {
    // SILENT KILL — direct booleans, zero toggle calls, zero flash artifacts
    APP.fx.stutter = false; APP.fx.crush = false; APP.fx.invert = false;
    APP.fx.echo = false; APP.fx.rgbSplit = 0; APP.fx.freezeFrame = null;
    APP.vj.brightness = 1.0; APP.vj.contrast = 1.0; APP.vj.saturation = 1.0; APP.vj.hue = 0;
    APP.vj.trailsEnabled = false; APP.vj.trailAlpha = 0.92;
    APP.vj.rgbEnabled = false; APP.vj.rgbIntensity = 0;
    APP.vj.pixelateEnabled = false; APP.vj.pixelSize = 1;
    APP.vj.invert = false; APP.vj.maskMode = false;
    APP.vj.rumbleEnabled = false; APP.vj.uiReactivity = false;
    APP.vj.punchEnabled = false; APP.vj.punchScale = 1.0;
    APP.vj.nightVision = false; APP.vj.tacticalXY = false;
    APP.state.psychosis = false;
    // DOM: clear without triggering handlers
    document.body.style.transform = '';
    document.body.style.filter = '';
    document.body.style.boxShadow = '';
    document.body.classList.remove('vhs-aggressive','scan-tear','night-vision','vhs','crt','system-failure','party-active');
    document.querySelectorAll('.btn.on,.btn.fx-active,.btn.active-mode').forEach(function(el){ el.classList.remove('on','fx-active','active-mode'); });
    if (APP.render && APP.render.canvas) APP.render.canvas.style.filter = 'none';
    if (APP.partyInterval) { clearInterval(APP.partyInterval); APP.partyInterval = null; }
    setTheme('cyan');
    log('RESET: SILENT_KILL');
}

// PRO_FX: btn-reset delegates to resetAllFX (safe — no slider refs)
if ($('btn-reset')) $('btn-reset').onclick = resetAllFX;


// ═══════════════════════════════════════════════════════════════════════════
// Phase 2: SIDE-CHAIN DUCKING ENGINE
// ═══════════════════════════════════════════════════════════════════════════
function initMicDucking(micStream) {
    if (!APP.audio.ctx || !micStream) return;
    try {
        APP.audio.micSource = APP.audio.ctx.createMediaStreamSource(micStream);
        APP.audio.micSource.connect(APP.audio.micAnalyzer);
        APP.audio.duckingActive = true;
        monitorDucking();
        log('DUCKING: ARMED_-20dB');
    } catch (e) { log('DUCKING_ERR: ' + e.message); }
}

function monitorDucking() {
    if (!APP.audio.duckingActive || !APP.audio.micAnalyzer) return;
    requestAnimationFrame(monitorDucking);
    const buf = new Float32Array(APP.audio.micAnalyzer.frequencyBinCount);
    APP.audio.micAnalyzer.getFloatTimeDomainData(buf);
    let sum = 0;
    for (let i = 0; i < buf.length; i++) sum += buf[i] * buf[i];
    const db = 20 * Math.log10(Math.max(Math.sqrt(sum / buf.length), 1e-10));
    const now = APP.audio.ctx.currentTime;
    // setTargetAtTime: exponential approach = zero pops/clicks in 15Mbps recording
    if (db > -20) {
        APP.audio.duckingGain.gain.setTargetAtTime(0.25, now, 0.05);
    } else {
        APP.audio.duckingGain.gain.setTargetAtTime(1.0, now, 0.15);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Phase 3: WEB3 SOVEREIGN DNA
// ═══════════════════════════════════════════════════════════════════════════
// ═══ SHARED WALLET HELPERS ═══
var _walletChainNames = {
    '0x1': 'ETH', '0x89': 'MATIC', '0xa86a': 'AVAX', '0x38': 'BSC',
    '0xa4b1': 'ARB', '0xa': 'OP', '0x2105': 'BASE', '0xaa36a7': 'SEP'
};

function walletNetworkName(chainId) {
    return _walletChainNames[chainId] || 'NET:' + parseInt(chainId, 16);
}

function connectWalletUI(address, chainId) {
    var network = walletNetworkName(chainId);
    var short = address.slice(0, 6) + '...' + address.slice(-4);
    // Sync both state objects
    APP.wallet = { connected: true, address: address, chainId: chainId, nfts: APP.wallet.nfts || [] };
    APP.web3.address = address;
    APP.web3.isConnected = true;
    APP.web3.mode = 'sovereign';
    APP.layerSaver.allReady = true;
    enableRecordButtons(true);
    // Update badge
    $('wallet-badge').style.borderColor = 'var(--g)';
    $('wallet-badge').style.color = 'var(--g)';
    $('wallet-badge').innerHTML = '<span class="dot" style="background:var(--g);box-shadow:0 0 6px var(--g)"></span>' + network + ':' + short;
    return { network: network, short: short };
}

function disconnectWalletUI() {
    APP.wallet = { connected: false, address: null, chainId: null, nfts: [] };
    APP.web3.address = null;
    APP.web3.isConnected = false;
    APP.web3.mode = 'guest';
    APP.user.assets = [];
    APP.nftVault.thumbnails = [];
    $('wallet-badge').style.borderColor = 'var(--o)';
    $('wallet-badge').style.color = 'var(--o)';
    $('wallet-badge').innerHTML = '<span class="dot off"></span>WALLET';
    $('vault-dot').classList.add('off');
    $('nft-vault-list').innerHTML = 'CONNECT_WALLET_FIRST';
    $('nft-count').textContent = 'ASSETS: 0';
    checkLayerReadiness();
    log('WALLET: DISCONNECTED');
}

function autoScanNFTs() {
    var btn = $('btn-scan-nfts');
    if (btn) setTimeout(function() { btn.click(); }, 300);
}

async function initWeb3() {
    try {
        if (typeof window.ethereum !== 'undefined') {
            APP.web3.provider = window.ethereum;

            // Register global listeners ONCE at init — survives page lifetime
            window.ethereum.on('accountsChanged', function(accounts) {
                if (!accounts || accounts.length === 0) {
                    disconnectWalletUI();
                } else {
                    // Account switched — reconnect with new address
                    var chainId = APP.wallet.chainId || '0x1';
                    window.ethereum.request({ method: 'eth_chainId' }).then(function(cid) {
                        var info = connectWalletUI(accounts[0], cid);
                        log('WALLET: SWITCHED TO ' + info.short);
                        autoScanNFTs();
                    }).catch(function() {
                        connectWalletUI(accounts[0], chainId);
                        autoScanNFTs();
                    });
                }
            });

            window.ethereum.on('chainChanged', function(newChainId) {
                if (APP.wallet.connected && APP.wallet.address) {
                    APP.wallet.chainId = newChainId;
                    var network = walletNetworkName(newChainId);
                    var short = APP.wallet.address.slice(0, 6) + '...' + APP.wallet.address.slice(-4);
                    $('wallet-badge').innerHTML = '<span class="dot" style="background:var(--g);box-shadow:0 0 6px var(--g)"></span>' + network + ':' + short;
                    log('NETWORK: SWITCHED TO ' + network);
                    autoScanNFTs();
                }
            });

            // Passive check — only picks up accounts if MetaMask is already authorized
            var accounts = await window.ethereum.request({ method: 'eth_accounts' });
            if (accounts.length > 0) {
                var chainId = await window.ethereum.request({ method: 'eth_chainId' });
                var info = connectWalletUI(accounts[0], chainId);
                log('WEB3: SOVEREIGN [' + info.short + ']');
                autoScanNFTs();
            } else {
                APP.web3.mode = 'guest';
                log('WEB3: GUEST_MODE (CONNECT VIA WALLET BADGE)');
            }
        } else {
            log('WEB3_ERR: NO_INJECTED_PROVIDER');
        }
    } catch (e) {
        log('WEB3_ERR: CONNECTION_REJECTED');
    }
}

async function signVideoDNA(videoBlob) {
    const result = { hash: null, signature: null, timestamp: Date.now(), address: APP.web3.address || 'guest', mode: APP.web3.mode };
    try {
        const ab = await videoBlob.arrayBuffer();
        const hashBuf = await window.crypto.subtle.digest('SHA-256', ab);
        result.hash = Array.from(new Uint8Array(hashBuf)).map(b => b.toString(16).padStart(2, '0')).join('');
        
        // FIX: Ensure provider exists before calling request
        if (APP.web3.mode === 'sovereign' && APP.web3.isConnected && window.ethereum) {
            const msg = 'VNGRD_DNA_SEAL:' + result.hash + ':' + result.timestamp;
            // Use window.ethereum directly if APP.web3.provider is flaky
            result.signature = await window.ethereum.request({ method: 'personal_sign', params: [msg, APP.web3.address] });
            log('DNA: SEALED + ETH_SIG');
        } else {
            localStorage.setItem('vngrd_last_hash', result.hash);
            log('DNA: SEALED_SHA256 (GUEST)');
        }
    } catch (e) { 
        console.error(e);
        log('DNA_SEAL_ERR: ' + e.message); 
    }
    return result;
}

function injectDNAHeader(dna, seal) {
    if (!dna || !seal) return dna;
    dna.sovereign = {
        hash: seal.hash, signature: seal.signature, timestamp: seal.timestamp,
        address: seal.address, mode: seal.mode,
        traits: { resolution: APP.render.width + 'x' + APP.render.height, codec: 'vp9+opus', bitrate: '15Mbps', spatialMode: APP.audio.spatialMode, theme: APP.state.theme, version: 'VNGRD_23.5_SERVERLESS' }
    };
    return dna;
}

// ═══════════════════════════════════════════════════════════════════════════
// Phase 4: PODCASTER PORTAL UI + MIDI Visual/Audio Mapping
// ═══════════════════════════════════════════════════════════════════════════
function portalCamPreview() {
    // Preview is now inline in the CAMERA_4K sidebar section — no repositioning needed
    const cam = $('cam-preview-float');
    if (!cam) return;
    log('PORTAL: CAM_INLINE');
}

function triggerVisualEffect(note, velocity) {
    const i = velocity / 127;
    if (note >= 36 && note <= 39) { [impactStutter, impactInvert, impactCrush, triggerSeismic][(note - 36)]?.(); }
    else if (note >= 40 && note <= 47) { setTheme(['cyan','magenta','gold','purple','green'][(note - 40) % 5]); }
    else if (note >= 48 && note <= 59) { APP.vj.rgbIntensity = Math.round(i * 30); APP.vj.rgbEnabled = i > 0.1; }
    else if (note >= 60 && i > 0.5) { rotateMedia(); }
}

function setMidiAudioFilter(cc, value) {
    const n = value / 127;
    if (cc === 1) APP.vj.brightness = 0.2 + n * 1.8;
    else if (cc === 7 && APP.audio.masterGain) APP.audio.masterGain.gain.setValueAtTime(n, APP.audio.ctx.currentTime);
    else if (cc === 71) APP.vj.contrast = 0.2 + n * 1.8;
    else if (cc === 74) APP.vj.hue = Math.round(n * 360);
    else if (cc === 91) { APP.vj.trailAlpha = 0.8 + n * 0.19; APP.vj.trailsEnabled = n > 0.05; }
}

// ═══════════════════════════════════════════════════════════════════════════
// Phase 5: LAYER SAVER (yPodcaster Protection)
// ═══════════════════════════════════════════════════════════════════════════
async function checkLayerReadiness() {
    try {
        const [tex, font] = await Promise.all([
            Promise.resolve(!!(APP.render.canvas && APP.render.ctx)),
            document.fonts ? document.fonts.ready.then(() => true).catch(() => true) : Promise.resolve(true)
        ]);
        // Audio check: pass if ctx exists OR if wallet is connected (studio unlocked)
        const audio = !!(APP.audio.ctx && APP.audio.ctx.state !== 'closed') || (APP.wallet && APP.wallet.connected);
        APP.layerSaver.textureReady = tex;
        APP.layerSaver.fontReady = font;
        APP.layerSaver.audioReady = audio;
        APP.layerSaver.allReady = tex && font;
        if (APP.layerSaver.allReady) {
            log('LAYER_SAVER: ALL_READY');
            enableRecordButtons(true);
        } else {
            const missing = [];
            if (!tex) missing.push('TEXTURE');
            if (!font) missing.push('FONT');
            log('LAYER_SAVER: MISSING [' + missing.join(', ') + ']');
            enableRecordButtons(false);
        }
        return APP.layerSaver.allReady;
    } catch (e) { enableRecordButtons(false); return false; }
}

function enableRecordButtons(enabled) {
    ['btn-nft-30', 'btn-broadcast'].forEach(id => {
        const btn = $(id);
        if (btn) { btn.disabled = !enabled; btn.style.opacity = enabled ? '1' : '0.3'; }
    });
}

// ═══════════════════════════════════════════════════════════════════════════
// Phase 1: COMPOSITOR INTEGRATION
// ═══════════════════════════════════════════════════════════════════════════
function initCompositor() {
    if (!window.Compositor) { log('COMPOSITOR: NOT_LOADED'); return; }
    APP.compositor = new Compositor({
        width: APP.render.width,
        height: APP.render.height,
        fps: 60,
        bitrate: 15000000,
        audioBitrate: 128000
    });
    APP.compositor.setLayer('overlay', APP.render.canvas);
    if (APP.camera.stream) {
        const vid = $('preview-vid') || APP.camera.videoEl;
        if (vid) APP.compositor.setLayer('camera', vid);
    }
    // Feed hologram canvas as 3D scene
    const holoCanvas = $('hologram-canvas');
    if (holoCanvas) APP.compositor.setLayer('scene3D', holoCanvas);

    APP.compositor.initRecorder(APP.audio.ctx, APP.audio.masterGain);
    APP.compositor.onWorkerMessage((type, payload) => {
        if (type === 'STATUS') log('COMPOSITOR: ' + payload);
    });
    APP.compositor.startRecording(1000);
    log('COMPOSITOR: 15Mbps_VP9_PIPELINE_ACTIVE');
}

document.addEventListener('DOMContentLoaded', () => {
    log('DRIS//core_VNGRD_v23.5_SYSTEM_FAILURE');
    checkMobile(); initCanvas(); ghostInit(); fetchCrypto(); setInterval(fetchCrypto, 600000);
    loadFromMemory();
    // Phase 1: Initialize Compositor
    initCompositor();
    // Phase 3: Initialize Web3 (Hybrid Gate)
    initWeb3();
    // Phase 4: Portal UI
    portalCamPreview();
    // Phase 5: Layer Saver
    checkLayerReadiness();
 
    // Hide DOM overlays — Trinity actors are drawn directly on canvas
    var _sb = $('station-bug'); if (_sb) _sb.style.opacity = '0';
    // GIF ANIMATION FIX: user-logo-layer must be ON-SCREEN and composited
    // by the browser for frame advancement. Position behind canvas (z-index:-1)
    // at bottom-left, 10px visible footprint. drawImage() reads current frame.
    var _ul = $('user-logo-layer');
    if (_ul) {
        _ul.style.position = 'fixed';
        _ul.style.bottom = '0';
        _ul.style.left = '0';
        _ul.style.width = '10px';
        _ul.style.height = '10px';
        _ul.style.opacity = '0.01';
        _ul.style.pointerEvents = 'none';
        _ul.style.zIndex = '-1';
        _ul.style.objectFit = 'cover';
    }
    
    requestAnimationFrame(renderLoop);
    initSummonerLogic();
    updateClock(); setInterval(updateClock, 1000); morphLogo(); setTimeout(morphLogo, 4000);

    // AUTO-MIDI: Probe for MIDI on load, link to seismic trigger
    autoInitMIDI();
    
    // Wire UI
    $('btn-init-cam').onclick = initCamera; $('btn-go-live').onclick = goLive; $('btn-end').onclick = endLive; $('btn-kill').onclick = killCamera;
    
    // MIC TOGGLE — routes mic into broadcast recording + triggers ducking
    $('btn-mic').onclick = async () => {
        const btn = $('btn-mic');
        if (APP.camera.micStream) {
            // Turn OFF mic
            APP.camera.micStream.getTracks().forEach(t => t.stop());
            APP.camera.micStream = null;
            APP.audio.duckingActive = false;
            if (APP.audio.micGainNode) { APP.audio.micGainNode.disconnect(); APP.audio.micGainNode = null; }
            btn.classList.remove('on');
            btn.textContent = 'MIC';
            log('MIC: OFF');
            return;
        }
        try {
            if (!APP.audio.ctx) APP.audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
            APP.camera.micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, sampleRate: 48000 } });
            // Create mic source and route to audio context for monitoring + recording
            const micSource = APP.audio.ctx.createMediaStreamSource(APP.camera.micStream);
            APP.audio.micGainNode = APP.audio.ctx.createGain();
            APP.audio.micGainNode.gain.value = 1.0;
            micSource.connect(APP.audio.micGainNode);
            APP.audio.micGainNode.connect(APP.audio.ctx.destination);
            // Arm ducking
            initMicDucking(APP.camera.micStream);
            btn.classList.add('on');
            btn.textContent = 'MIC [ON]';
            log('MIC: ARMED_48kHz');
            // Re-check layer readiness with audio context now available
            checkLayerReadiness();
        } catch(e) { log('MIC_ERR: ' + e.message); }
    };
    
    // --- COMPACT MEDIA DECK WIRING ---
    $('btn-load-media').onclick = () => $('file-media').click();
    $('btn-cycle-toggle').onclick = toggleCycle;

    // Keep Navigation
    $('btn-rotate').onclick = rotateMedia; 
    $('btn-prev').onclick = previousMedia;
    $('file-media').onchange = e => loadMediaFiles(e.target);
    
    // Live Time Update
    // Cycle slider handler
    $('sl-cycle').oninput = e => {
        $('val-cycle').textContent = e.target.value + 's';
        if(APP.state.isCycle) {
            checkCycleLogic();
        }
    };
    
    // Show slider when cycle is on
    const origToggleCycle = toggleCycle;
    toggleCycle = function() {
        origToggleCycle();
        $('cycle-slider-wrap').style.display = APP.state.isCycle ? 'block' : 'none';
    };

    $('btn-lt-guest').onclick = () => showLowerThird('guest'); $('btn-lt-track').onclick = () => showLowerThird('track'); $('btn-lt-breaking').onclick = () => showLowerThird('breaking'); $('btn-lt-off').onclick = hideLowerThird;
    $('lt-title').oninput = e => { if (APP.lowerThird.visible) $('lt-title-text').textContent = e.target.value; };
    $('lt-sub').oninput = e => { if (APP.lowerThird.visible) $('lt-subtitle-text').textContent = e.target.value; };
    $('btn-audio').onclick = () => $('file-audio').click(); $('file-audio').onchange = e => loadAudioFiles(e.target);

    $('btn-mute-vid').onclick = () => {
        APP.audio.videoMuted = !APP.audio.videoMuted;
        var vid = APP.audio.videoSource;
        if (vid) { vid.muted = APP.audio.videoMuted; }
        $('btn-mute-vid').textContent = APP.audio.videoMuted ? '\u{1F507}' : '\u{1F50A}';
        if (APP.audio.videoMuted) $('btn-mute-vid').classList.add('on'); else $('btn-mute-vid').classList.remove('on');
        log('VIDEO_MUTE: ' + (APP.audio.videoMuted ? 'ON' : 'OFF'));
    };
    
    // NEW COMPACT AUDIO
    $('btn-next-track').onclick = nextTrack; 
    $('btn-prev-track').onclick = prevTrack;
    $('btn-play-pause').onclick = togglePlayPause;
    
    // PRO_FX wiring (faders removed — buttons only)
    if ($('btn-stutter')) $('btn-stutter').onclick = impactStutter;
    if ($('btn-invert')) $('btn-invert').onclick = impactInvert;
    if ($('btn-crush')) $('btn-crush').onclick = impactCrush;
    if ($('btn-trails')) $('btn-trails').onclick = () => { APP.vj.trailsEnabled = !APP.vj.trailsEnabled; $('btn-trails').classList.toggle('on'); };
    if ($('btn-rgb')) $('btn-rgb').onclick = () => { APP.vj.rgbEnabled = !APP.vj.rgbEnabled; APP.vj.rgbIntensity = APP.vj.rgbEnabled ? 12 : 0; $('btn-rgb').classList.toggle('on'); };
    if ($('btn-pixelate')) $('btn-pixelate').onclick = () => { APP.vj.pixelateEnabled = !APP.vj.pixelateEnabled; APP.vj.pixelSize = APP.vj.pixelateEnabled ? 8 : 1; $('btn-pixelate').classList.toggle('on'); };
    if ($('btn-vhs')) $('btn-vhs').onclick = function() { document.body.classList.toggle('vhs-aggressive'); this.classList.toggle('fx-active'); log('VHS_AGG'); };
    if ($('btn-crt')) $('btn-crt').onclick = function() { document.body.classList.toggle('scan-tear'); this.classList.toggle('fx-active'); log('SCAN_TEAR'); };
    if ($('btn-night-vision')) $('btn-night-vision').onclick = function() {
        APP.vj.nightVision = !APP.vj.nightVision;
        document.body.classList.toggle('night-vision', APP.vj.nightVision);
        this.classList.toggle('fx-active', APP.vj.nightVision);
        log('NIGHT_VIS: ' + (APP.vj.nightVision ? 'ON' : 'OFF'));
    };
    if ($('btn-tactical-xy')) $('btn-tactical-xy').onclick = function() {
        APP.vj.tacticalXY = !APP.vj.tacticalXY;
        this.classList.toggle('fx-active', APP.vj.tacticalXY);
        log('TACT_XY: ' + (APP.vj.tacticalXY ? 'ON' : 'OFF'));
    };
    if ($('btn-punch')) $('btn-punch').onclick = function() {
        if (APP.vj.punchEnabled) {
            APP.vj.punchEnabled = false; APP.vj.punchScale = 1.0;
            this.classList.remove('fx-active'); log('PUNCH: DISARMED');
        } else {
            APP.vj.punchScale = 1.06;
            var self = this;
            setTimeout(function() { APP.vj.punchScale = 1.0; APP.vj.punchEnabled = true; self.classList.add('fx-active'); log('PUNCH: ARMED'); }, 150);
        }
    };
    if ($('btn-fs')) $('btn-fs').onclick = toggleFullscreen;
    document.querySelectorAll('.pal').forEach(p => p.onclick = () => setTheme(p.dataset.t));
    $('btn-projector').onclick = openProjector;
    
    // PARTY MODE TRIGGER - Rapid morphs + light effects
    $('btn-ui-react').onclick = function() {
        if (APP.vj.uiReactivity) {
            APP.vj.uiReactivity = false;
            this.classList.remove('fx-active');
            document.body.classList.remove('party-active');
            document.body.style.boxShadow = '';
            if (APP.partyInterval) { clearInterval(APP.partyInterval); APP.partyInterval = null; }
            log('PARTY: DISARMED');
        } else {
            // ONE-SHOT 150ms flash feedback, then arm
            document.body.style.filter = 'brightness(2) contrast(1.2)';
            var self = this;
            setTimeout(function() {
                document.body.style.filter = '';
                APP.vj.uiReactivity = true;
                self.classList.add('fx-active');
                document.body.classList.add('party-active');
                // Continuous reactive party interval
                APP.partyInterval = setInterval(function() {
                    if (!APP.vj.uiReactivity) { clearInterval(APP.partyInterval); return; }
                    if (APP.audio.highs > 175) {
                        if (Math.random() > 0.7) { var themes=['cyan','magenta','green','purple','gold']; setTheme(themes[Math.floor(Math.random()*themes.length)]); }
                        if (Math.random() > 0.5) morphLogo();
                    }
                }, 300);
                log('PARTY: ARMED (highs>175)');
            }, 150);
        }
    };
    
    // SEISMIC — one-shot preview then armed
    $('btn-rumble').onclick = function() {
        if (APP.vj.rumbleEnabled) {
            APP.vj.rumbleEnabled = false;
            this.classList.remove('fx-active');
            document.body.style.transform = '';
            log('SEISMIC: DISARMED');
        } else {
            document.body.style.transform = 'translate3d(4px,-3px,0)';
            var self = this;
            setTimeout(function() { document.body.style.transform = ''; APP.vj.rumbleEnabled = true; self.classList.add('fx-active'); log('SEISMIC: ARMED (kick>195)'); }, 150);
        }
    };
    
    // WALLET CONNECTION (Header badge) — uses shared helpers from initWeb3
    // Listeners are registered once in initWeb3() — no duplicates here
    $('wallet-badge').onclick = async () => {
        if (APP.wallet && APP.wallet.connected) {
            if (confirm('Disconnect wallet?')) {
                disconnectWalletUI();
            }
            return;
        }

        if (typeof window.ethereum === 'undefined') {
            log('NO_METAMASK');
            alert('MetaMask not detected. Please install the MetaMask browser extension from metamask.io');
            window.open('https://metamask.io/download/', '_blank');
            return;
        }

        try {
            // eth_requestAccounts — always triggers MetaMask popup for authorization
            var accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
            if (!accounts || accounts.length === 0) { log('WALLET: NO_ACCOUNTS'); return; }
            var chainId = await window.ethereum.request({ method: 'eth_chainId' });
            var info = connectWalletUI(accounts[0], chainId);
            log('WALLET: ' + info.network + ' ' + info.short);

            // Fetch balance (optional, non-blocking)
            try {
                var balance = await window.ethereum.request({ method: 'eth_getBalance', params: [accounts[0], 'latest'] });
                var ethBalance = (parseInt(balance, 16) / 1e18).toFixed(4);
                log('BALANCE: ' + ethBalance + ' ' + (info.network === 'ETH' ? 'ETH' : 'native'));
            } catch (e) { /* Balance fetch optional */ }

            // Auto-scan NFTs after fresh connection
            autoScanNFTs();

        } catch (e) {
            if (e.code === 4001) {
                log('WALLET: USER_REJECTED');
            } else {
                log('WALLET_ERROR: ' + e.message);
            }
        }
    };
    
    $('btn-stereo').onclick = () => setAudioMode('stereo');
    $('btn-spatial').onclick = () => setAudioMode('spatial');
    $('btn-dolby').onclick = () => setAudioMode('dolby');

    // LOGO CLICK INTERACTION - Light flash + morph (like reference site)
    $('main-logo').onmousedown = () => {
        // Light flash effect
        document.body.style.filter = 'brightness(2) contrast(1.2)';
        document.querySelectorAll('.sidebar').forEach(s => s.style.boxShadow = '0 0 30px var(--accent)');
        setTimeout(() => {
            document.body.style.filter = '';
            document.querySelectorAll('.sidebar').forEach(s => s.style.boxShadow = '');
        }, 100);
        
        // Morph logo
        morphLogo();
    };

    // Final UI and Input Handlers
    document.addEventListener('keydown', e => {
        if (e.target.tagName === 'INPUT') return;
        if (e.key === 'g' || e.key === 'G') toggleGhost();
        if (e.key === 'h' || e.key === 'H') toggleFullscreen();
        if (e.key === 'Escape') { $('btn-panic').click(); } 
        if (e.key === ' ') { e.preventDefault(); rotateMedia(); }
    });

    // Ensure uploaded logos are interactable
    $('file-layer-logo').onchange = e => {
        if (e.target.files.length) {
            const url = URL.createObjectURL(e.target.files[0]);
            const img = $('user-logo-layer');
            // display:block before src — triggers GIF animation on load
            img.style.display = 'block';
            img.src = url;
            // ON-SCREEN behind canvas — browser composites = GIF frames advance
            img.style.position = 'fixed';
            img.style.bottom = '0';
            img.style.left = '0';
            img.style.width = '10px';
            img.style.height = '10px';
            img.style.opacity = '0.01';
            img.style.pointerEvents = 'none';
            img.style.zIndex = '-1';
            img.style.objectFit = 'cover';
            APP.trinity.logo.visible = true;
            log('IDENTITY_LAYER_LOADED');
        }
    };

    // ========================================
    // MIDI_HOST WITH LEARN MODE & PASSTHROUGH
    // ========================================
    
    // MIDI LEARN MODE - Click element + hit MIDI to bind
    if ($('btn-midi-learn')) {
        $('btn-midi-learn').onclick = () => {
            APP.midi.learnMode = !APP.midi.learnMode;
            document.body.classList.toggle('midi-learn-active', APP.midi.learnMode);
            $('btn-midi-learn').textContent = APP.midi.learnMode ? 'LEARN MODE: ON' : 'LEARN MODE: OFF';
            $('btn-midi-learn').classList.toggle('on', APP.midi.learnMode);
            log('MIDI_LEARN: ' + (APP.midi.learnMode ? 'ACTIVE' : 'OFF'));
            
            if (APP.midi.learnMode) {
                // Add click listeners to learnable elements
                document.querySelectorAll('[data-midi-target]').forEach(el => {
                    el.addEventListener('click', midiLearnClick);
                });
            } else {
                document.querySelectorAll('[data-midi-target]').forEach(el => {
                    el.removeEventListener('click', midiLearnClick);
                });
                APP.midi.learnTarget = null;
            }
        };
    }
    
    function midiLearnClick(e) {
        if (!APP.midi.learnMode) return;
        e.preventDefault();
        e.stopPropagation();
        
        const target = e.currentTarget.dataset.midiTarget;
        APP.midi.learnTarget = { element: e.currentTarget, target: target };
        log('MIDI_LEARN: Waiting for MIDI input for ' + target.toUpperCase());
        e.currentTarget.style.outline = '2px solid var(--v)';
    }
    
    // INSTRUMENT PASSTHROUGH - Synthesizer
    if ($('btn-midi-passthru')) {
        $('btn-midi-passthru').onclick = () => {
            APP.midi.passthrough = !APP.midi.passthrough;
            $('btn-midi-passthru').textContent = APP.midi.passthrough ? 'INSTRUMENT: ON' : 'INSTRUMENT: OFF';
            $('btn-midi-passthru').classList.toggle('on', APP.midi.passthrough);
            log('MIDI_INSTRUMENT: ' + (APP.midi.passthrough ? 'ACTIVE' : 'OFF'));
            
            // Initialize synth context
            if (APP.midi.passthrough && !APP.midi.synthCtx) {
                APP.midi.synthCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
                APP.midi.synthGain = APP.midi.synthCtx.createGain();
                APP.midi.synthGain.connect(APP.midi.synthCtx.destination);
            }
        };
    }
    
    // Play synthesized note
    function playSynthNote(note, velocity) {
        if (!APP.midi.passthrough || !APP.midi.synthCtx) return;
        
        const freq = 440 * Math.pow(2, (note - 69) / 12); // MIDI to frequency
        const osc = APP.midi.synthCtx.createOscillator();
        const gain = APP.midi.synthCtx.createGain();
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        const vol = (velocity / 127) * 0.3;
        gain.gain.setValueAtTime(vol, APP.midi.synthCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, APP.midi.synthCtx.currentTime + 0.5);
        
        osc.connect(gain);
        gain.connect(APP.midi.synthGain);
        osc.start();
        osc.stop(APP.midi.synthCtx.currentTime + 0.5);
    }
    
    // --- MIDI CONTROLLER ---
    $('btn-midi').onclick = async () => {
        if (!navigator.requestMIDIAccess) {
            log('WEBMIDI_NOT_SUPPORTED');
            alert('WebMIDI not supported in this browser. Try Chrome or Edge.');
            return;
        }
        
        try {
            const midiAccess = await navigator.requestMIDIAccess({ sysex: false });
            APP.midi.access = midiAccess;
            APP.midi.inputs = [];
            APP.midi.outputs = [];
            
            const inputs = Array.from(midiAccess.inputs.values());
            const outputs = Array.from(midiAccess.outputs.values());
            
            if (inputs.length === 0) {
                log('NO_MIDI_DEVICES');
                alert('No MIDI devices found. Connect a MIDI controller and try again.');
                return;
            }
            
            log('MIDI: ' + inputs.length + ' inputs, ' + outputs.length + ' outputs');
            $('btn-midi').classList.add('on');
            $('btn-midi').textContent = 'MIDI ACTIVE';
            $('midi-status').textContent = inputs[0].name;
            $('midi-status').style.color = 'var(--g)';
            if ($('midi-dot')) $('midi-dot').classList.remove('off');
            
            // Handle MIDI input messages
            inputs.forEach(input => {
                APP.midi.inputs.push(input);
                input.onmidimessage = (msg) => {
                    const [status, note, velocity] = msg.data;
                    const cmd = status >> 4;
                    const channel = status & 0x0F;
                    
                    // MIDI LEARN - Bind to waiting target
                    if (APP.midi.learnMode && APP.midi.learnTarget && velocity > 0) {
                        const key = (cmd === 11) ? 'cc' + note : 'note' + note;
                        APP.midi.bindings[key] = {
                            element: APP.midi.learnTarget.element,
                            target: APP.midi.learnTarget.target,
                            type: (cmd === 11) ? 'cc' : 'note'
                        };
                        APP.midi.learnTarget.element.classList.add('midi-bound');
                        APP.midi.learnTarget.element.style.outline = '';
                        updateMidiBindingsDisplay();
                        log('MIDI_BOUND: ' + key + ' -> ' + APP.midi.learnTarget.target);
                        APP.midi.learnTarget = null;
                        return;
                    }
                    
                    // Note On (cmd 9) with velocity > 0
                    if (cmd === 9 && velocity > 0) {
                        // INSTRUMENT PASSTHROUGH
                        if (APP.midi.passthrough) {
                            playSynthNote(note, velocity);
                        }
                        
                        // Check for learned binding
                        const binding = APP.midi.bindings['note' + note];
                        if (binding) {
                            triggerMidiBinding(binding, velocity);
                        }
                        
                        // KINETIC TRIGGERS - Velocity scales impact
                        const intensity = velocity / 127;
                        
                        // Drum pads / low notes - trigger DIEGETIC DESTRUCTION
                        if (note < 48) {
                            // Scale impact with velocity
                            if (APP.shooting.active && typeof fireWeaponAt === 'function') {
                                const x = Math.random() * window.innerWidth;
                                const y = Math.random() * window.innerHeight;
                                fireWeaponAt(x, y, intensity);
                            }
                            
                            // Seismic shake scaled to velocity
                            const shake = intensity * 30;
                            document.body.style.transform = `translate(${(Math.random()-0.5)*shake}px, ${(Math.random()-0.5)*shake}px)`;
                            setTimeout(() => document.body.style.transform = '', 50);

                            // Punch 3D hologram scale on drum hits
                            if (APP.hologram) {
                                APP.hologram.targetScale = 1.0 + (velocity / 127.0);
                            }
                        }
                        
                        // Higher notes - trigger effects
                        if (velocity > 80) {
                            if (note >= 60 && note < 64) impactStutter();
                            else if (note >= 64 && note < 68) impactInvert();
                            else if (note >= 68 && note < 72) impactCrush();
                            else if (note >= 72) { rotateMedia(); triggerImpact(); }
                        }
                        
                        // ALL Note-On: punch hologram scale
                        if (APP.hologram && note >= 48) {
                            APP.hologram.targetScale = 1.0 + (velocity / 127.0) * 0.5;
                        }

                        // Theme changes on specific notes
                        if (note === 36) setTheme('cyan');
                        if (note === 37) setTheme('magenta');
                        if (note === 38) setTheme('green');
                        if (note === 39) setTheme('purple');
                        if (note === 40) setTheme('gold');
                    }
                    
                    // Note Off - stop synth
                    if (cmd === 8 || (cmd === 9 && velocity === 0)) {
                        // Note off handling if needed
                    }
                    
                    // Control Change (cmd 11) - sliders/knobs
                    if (cmd === 11) {
                        const val = velocity / 127;

                        // Check for learned binding
                        const binding = APP.midi.bindings['cc' + note];
                        if (binding) {
                            triggerMidiCCBinding(binding, val);
                        }
                        
                        // Default CC mappings
                        if (note === 1 || note === 74) { APP.vj.brightness = 0.5 + val; if ($('sl-b')) $('sl-b').value = APP.vj.brightness * 100; }
                        if (note === 2 || note === 71) { APP.vj.contrast = 0.5 + val; if ($('sl-c')) $('sl-c').value = APP.vj.contrast * 100; }
                        if (note === 3 || note === 76) { APP.vj.saturation = val * 2; if ($('sl-s')) $('sl-s').value = APP.vj.saturation * 100; }
                        if (note === 4 || note === 77) { APP.vj.hue = val * 360; if ($('sl-h')) $('sl-h').value = APP.vj.hue; }
                        // CC 20/21 — reserved (weather FX stripped)
                    }
                    
                    // Pitch Bend - control hue
                    if (cmd === 14) {
                        const bend = ((velocity << 7) | note) - 8192;
                        APP.vj.hue = (bend / 8192) * 180 + 180;
                    }
                };
            });
            
            // Store outputs
            outputs.forEach(output => APP.midi.outputs.push(output));
            
        } catch (e) {
            log('MIDI_ERROR: ' + e.message);
            alert('MIDI access denied: ' + e.message);
        }
    };
    
    function triggerMidiBinding(binding, velocity) {
        const el = binding.element;
        const target = binding.target;
        const intensity = velocity / 127;
        
        switch(target) {
            case 'stutter': impactStutter(); break;
            case 'invert': impactInvert(); break;
            case 'crush': impactCrush(); break;
            case 'shatter': if (typeof createGlassFracture === 'function') createGlassFracture(window.innerWidth/2, window.innerHeight/2); break;
            case 'lens-drip': el.click(); break;
            case 'heat-haze': el.click(); break;
            default: if (el.click) el.click();
        }
    }
    
    function triggerMidiCCBinding(binding, val) {
        const el = binding.element;
        const target = binding.target;
        
        if (el.tagName === 'INPUT' && el.type === 'range') {
            const min = parseFloat(el.min);
            const max = parseFloat(el.max);
            el.value = min + (max - min) * val;
            el.dispatchEvent(new Event('input'));
        }
    }
    
    function updateMidiBindingsDisplay() {
        const container = $('midi-bindings');
        if (!container) return;
        
        const bindings = Object.entries(APP.midi.bindings);
        if (bindings.length === 0) {
            container.textContent = '';
            return;
        }
        
        container.innerHTML = bindings.map(([key, val]) => `${key}:${val.target}`).join(' | ');
    }

    // --- AUTO-MIDI INIT: Probe on load, link to seismic ---
    async function autoInitMIDI() {
        if (!navigator.requestMIDIAccess) {
            log('MIDI_PROBE: NOT_SUPPORTED');
            return;
        }
        try {
            const midiAccess = await navigator.requestMIDIAccess({ sysex: false });
            const inputs = Array.from(midiAccess.inputs.values());
            if (inputs.length === 0) {
                log('MIDI_PROBE: NO_DEVICES');
                return;
            }
            APP.midi.access = midiAccess;
            APP.midi.inputs = [];
            APP.midi.outputs = [];

            log('MIDI_AUTO: ' + inputs.length + ' DEVICE(S) DETECTED');
            $('btn-midi').classList.add('on');
            $('btn-midi').textContent = 'MIDI ACTIVE';
            $('midi-status').textContent = inputs[0].name;
            $('midi-status').style.color = 'var(--g)';
            if ($('midi-dot')) $('midi-dot').classList.remove('off');

            inputs.forEach(input => {
                APP.midi.inputs.push(input);
                input.onmidimessage = (msg) => {
                    const [status, note, velocity] = msg.data;
                    const cmd = status >> 4;

                    // MIDI LEARN passthrough
                    if (APP.midi.learnMode && APP.midi.learnTarget && velocity > 0) {
                        const key = (cmd === 11) ? 'cc' + note : 'note' + note;
                        APP.midi.bindings[key] = {
                            element: APP.midi.learnTarget.element,
                            target: APP.midi.learnTarget.target,
                            type: (cmd === 11) ? 'cc' : 'note'
                        };
                        APP.midi.learnTarget.element.classList.add('midi-bound');
                        APP.midi.learnTarget.element.style.outline = '';
                        updateMidiBindingsDisplay();
                        log('MIDI_BOUND: ' + key + ' -> ' + APP.midi.learnTarget.target);
                        APP.midi.learnTarget = null;
                        return;
                    }

                    // Note On → SEISMIC + hologram punch
                    if (cmd === 9 && velocity > 0) {
                        if (APP.midi.passthrough) playSynthNote(note, velocity);
                        const binding = APP.midi.bindings['note' + note];
                        if (binding) triggerMidiBinding(binding, velocity);
                        const intensity = velocity / 127;

                        // Low notes → seismic shake + hologram punch
                        if (note < 48) {
                            const shake = intensity * 30;
                            document.body.classList.add('seismic-active');
                            document.body.style.transform = `translate(${(Math.random()-0.5)*shake}px, ${(Math.random()-0.5)*shake}px)`;
                            setTimeout(() => { document.body.style.transform = ''; document.body.classList.remove('seismic-active'); }, 100);
                            if (APP.hologram) APP.hologram.targetScale = 1.0 + intensity;
                        }

                        // High-vel triggers
                        if (velocity > 80) {
                            if (note >= 60 && note < 64) impactStutter();
                            else if (note >= 64 && note < 68) impactInvert();
                            else if (note >= 68 && note < 72) impactCrush();
                            else if (note >= 72) { rotateMedia(); triggerImpact(); }
                        }
                        if (APP.hologram && note >= 48) APP.hologram.targetScale = 1.0 + intensity * 0.5;
                        if (note >= 36 && note <= 40) setTheme(['cyan','magenta','green','purple','gold'][note - 36]);
                    }

                    // CC → VJ sliders
                    if (cmd === 11) {
                        const val = velocity / 127;
                        const binding = APP.midi.bindings['cc' + note];
                        if (binding) triggerMidiCCBinding(binding, val);
                        if (note === 1 || note === 74) { APP.vj.brightness = 0.5 + val; if ($('sl-b')) $('sl-b').value = APP.vj.brightness * 100; }
                        if (note === 2 || note === 71) { APP.vj.contrast = 0.5 + val; if ($('sl-c')) $('sl-c').value = APP.vj.contrast * 100; }
                        if (note === 3 || note === 76) { APP.vj.saturation = val * 2; if ($('sl-s')) $('sl-s').value = APP.vj.saturation * 100; }
                        if (note === 4 || note === 77) { APP.vj.hue = val * 360; if ($('sl-h')) $('sl-h').value = APP.vj.hue; }
                    }

                    // Pitch bend → hue
                    if (cmd === 14) {
                        const bend = ((velocity << 7) | note) - 8192;
                        APP.vj.hue = (bend / 8192) * 180 + 180;
                    }
                };
            });

            Array.from(midiAccess.outputs.values()).forEach(o => APP.midi.outputs.push(o));
            log('MIDI_AUTO: SIGNAL_RESTORED');
        } catch (e) {
            log('MIDI_PROBE_FAIL: ' + e.message);
        }
    }

    // --- WebXR VR MODE ---
    $('btn-vr').onclick = async () => {
        if (!navigator.xr) {
            log('WEBXR_NOT_SUPPORTED');
            alert('WebXR not supported. Try a VR-capable browser like Oculus Browser, Firefox Reality, or Chrome with a VR headset.');
            return;
        }
        
        try {
            const supported = await navigator.xr.isSessionSupported('immersive-vr');
            if (!supported) {
                // Try inline mode for phones/cardboard
                const inlineSupported = await navigator.xr.isSessionSupported('inline');
                if (inlineSupported) {
                    log('VR: Inline mode available');
                    alert('Full VR not available. For phone VR, open in a WebXR-compatible browser.');
                } else {
                    log('NO_VR_SUPPORT');
                    alert('No VR headset detected. Connect a VR device and try again.');
                }
                return;
            }
            
            log('VR: Starting immersive session');
            $('btn-vr').classList.add('on');
            $('btn-vr').textContent = 'EXIT VR';
            
            const session = await navigator.xr.requestSession('immersive-vr', {
                requiredFeatures: ['local-floor'],
                optionalFeatures: ['bounded-floor', 'hand-tracking']
            });
            
            APP.vr = { session, active: true };
            
            // Create WebGL context for VR
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl2', { xrCompatible: true });
            
            await gl.makeXRCompatible();
            
            const baseLayer = new XRWebGLLayer(session, gl);
            session.updateRenderState({ baseLayer });
            
            const refSpace = await session.requestReferenceSpace('local-floor');
            
            // VR render loop
            session.requestAnimationFrame(function vrLoop(time, frame) {
                if (!APP.vr.active) return;
                
                session.requestAnimationFrame(vrLoop);
                
                const pose = frame.getViewerPose(refSpace);
                if (pose) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, baseLayer.framebuffer);
                    
                    for (const view of pose.views) {
                        const viewport = baseLayer.getViewport(view);
                        gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
                        
                        // Draw the VJ canvas content to VR
                        gl.clearColor(0, 0, 0, 1);
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        
                        // Copy canvas to WebGL texture
                        const texture = gl.createTexture();
                        gl.bindTexture(gl.TEXTURE_2D, texture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, APP.render.canvas);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                }
            });
            
            session.addEventListener('end', () => {
                APP.vr.active = false;
                $('btn-vr').classList.remove('on');
                $('btn-vr').textContent = 'ENTER VR';
                log('VR: Session ended');
            });
            
        } catch (e) {
            log('VR_ERROR: ' + e.message);
            $('btn-vr').classList.remove('on');
            $('btn-vr').textContent = 'ENTER VR';
        }
    };

    $('btn-nft-30').onclick = startNFTRecording;

    // ========================================
    // ========================================
    // KINETIC_MATERIAL_IMPACTS + WEAPON_STATE_ISOLATION
    // STRUCTURAL_INTEGRITY + ACOUSTIC_SYNTHESIS
    // ========================================
    
    // ACOUSTIC SYNTHESIS - NO EXTERNAL FILES
    function getAudioCtx() {
        if (!APP.shooting.audioCtx) {
            APP.shooting.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        return APP.shooting.audioCtx;
    }
    
    // GLASS SHATTER: High-pitch 3800Hz sine snap
    function playGlassShatter() {
        const ctx = getAudioCtx();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(3800, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1800, ctx.currentTime + 0.05);
        
        gain.gain.setValueAtTime(0.5, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);
        
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + 0.1);
    }
    
    // METAL TINK: Short 1600Hz square wave
    function playMetalTink() {
        const ctx = getAudioCtx();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        
        osc.type = 'square';
        osc.frequency.setValueAtTime(1600, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + 0.03);
        
        gain.gain.setValueAtTime(0.25, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.06);
        
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + 0.08);
    }
    
    // TERMINAL SMASH: Filtered white noise + 5kHz-to-200Hz sweep
    function playTerminalSmash() {
        const ctx = getAudioCtx();
        
        // White noise
        const bufferSize = ctx.sampleRate * 0.5;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        
        const noise = ctx.createBufferSource();
        noise.buffer = buffer;
        
        // Filter sweep
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(5000, ctx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.4);
        filter.Q.value = 5;
        
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.6, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(ctx.destination);
        noise.start(ctx.currentTime);
        noise.stop(ctx.currentTime + 0.5);
        
        // Impact sweep
        const osc = ctx.createOscillator();
        const oscGain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(200, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(40, ctx.currentTime + 0.3);
        oscGain.gain.setValueAtTime(0.5, ctx.currentTime);
        oscGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
        osc.connect(oscGain);
        oscGain.connect(ctx.destination);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + 0.35);
    }
    
   
    
    // STRUCTURAL INTEGRITY SYSTEM
    function updateIntegrityBar() {
        const bar = $('integrity-bar');
        const fill = $('integrity-fill');
        const text = $('integrity-text');
        
        if (!bar || !fill || !text) return;
        
        bar.classList.add('active');
        fill.style.width = APP.glassIntegrity + '%';
        text.textContent = 'INTEGRITY: ' + APP.glassIntegrity + '%';
        
        // Color based on integrity
        if (APP.glassIntegrity > 60) {
            fill.style.background = 'linear-gradient(90deg, var(--g) 0%, var(--g) 100%)';
        } else if (APP.glassIntegrity > 30) {
            fill.style.background = 'linear-gradient(90deg, var(--y) 0%, var(--y) 100%)';
        } else {
            fill.style.background = 'linear-gradient(90deg, var(--r) 0%, var(--r) 100%)';
        }
    }
    
    function triggerTerminalShatter() {
        APP.lensShattered = true;
        document.body.classList.add('lens-shattered');
        playTerminalSmash();
        
        // All fractures fall off screen
        APP.shooting.fractures.forEach(f => {
            f.style.animation = 'fracture-fall 1s forwards';
        });
        
        log('TERMINAL_SHATTER: LENS_FAILURE');
        
        setTimeout(() => {
            $('glass-fracture-layer').innerHTML = '';
            APP.shooting.fractures = [];
        }, 1000);
    }
    
    function repairLens() {
        if (!APP.lensShattered && APP.glassIntegrity >= 100) return;
        
        playHydraulicHiss();
        APP.glassIntegrity = 100;
        APP.lensShattered = false;
        document.body.classList.remove('lens-shattered');
        updateIntegrityBar();
        
        // Clear all damage
        APP.shooting.bullets.forEach(b => b.remove());
        APP.shooting.bullets = [];
        APP.shooting.fractures.forEach(f => f.remove());
        APP.shooting.fractures = [];
        APP.shooting.dents.forEach(d => d.classList.remove('dented'));
        APP.shooting.dents = [];
        $('glass-fracture-layer').innerHTML = '';
        
        log('LENS_REPAIR: INTEGRITY_RESTORED');
        
        setTimeout(() => {
            if (!APP.shooting.active) {
                $('integrity-bar').classList.remove('active');
            }
        }, 2000);
    }
    
    function startRepairTimer() {
        if (APP.shooting.repairTimer) {
            clearTimeout(APP.shooting.repairTimer);
        }
        APP.shooting.repairTimer = setTimeout(() => {
            if (APP.glassIntegrity < 100 || APP.lensShattered) {
                repairLens();
            }
        }, 15000); // 15 second auto-repair
    }
    
    // GLASS FRACTURE WITH 20S PURGE
    function createGlassFracture(x, y) {
        const stage = $('stage');
        const rect = stage.getBoundingClientRect();
        const localX = x - rect.left;
        const localY = y - rect.top;
        
        const fracture = document.createElement('div');
        fracture.className = 'glass-fracture';
        fracture.style.left = localX + 'px';
        fracture.style.top = localY + 'px';
        
        const numCracks = 5 + Math.floor(Math.random() * 6);
        let svg = '<svg width="100" height="100" style="position:absolute;left:-50px;top:-50px;mix-blend-mode:lighter;">';
        
        for (let i = 0; i < numCracks; i++) {
            const angle = (i / numCracks) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
            const len = 20 + Math.random() * 35;
            let path = `M50,50 `;
            let cx = 50, cy = 50;
            const segments = 3 + Math.floor(Math.random() * 3);
            
            for (let s = 0; s < segments; s++) {
                const segLen = len / segments;
                const jitter = (Math.random() - 0.5) * 12;
                cx += Math.cos(angle + jitter * 0.1) * segLen;
                cy += Math.sin(angle + jitter * 0.1) * segLen;
                path += `L${cx.toFixed(1)},${cy.toFixed(1)} `;
            }
            
            svg += `<path d="${path}" class="fracture-glow" fill="none"/>`;
            svg += `<path d="${path}" class="fracture-line" fill="none"/>`;
        }
        
        svg += '<circle cx="50" cy="50" r="4" fill="rgba(255,255,255,0.9)" filter="blur(2px)"/>';
        svg += '<circle cx="50" cy="50" r="2" fill="#fff"/>';
        svg += '</svg>';
        
        fracture.innerHTML = svg;
        $('glass-fracture-layer').appendChild(fracture);
        APP.shooting.fractures.push(fracture);
        
        playGlassShatter();
        
        // 20S MEMORY PURGE
        setTimeout(() => {
            fracture.style.opacity = '0';
            fracture.style.transition = 'opacity 0.5s';
            setTimeout(() => {
                fracture.remove();
                const idx = APP.shooting.fractures.indexOf(fracture);
                if (idx > -1) APP.shooting.fractures.splice(idx, 1);
            }, 500);
        }, 20000);
    }
    
    // METAL DENT
    function createMetalDent(el) {
        if (!el.classList.contains('dented')) {
            el.classList.add('dented');
            APP.shooting.dents.push(el);
        }
        playMetalTink();
    }
    
    // BULLET HOLE WITH 20S PURGE
    function createBulletHole(x, y) {
        const hole = document.createElement('div');
        hole.className = 'bullet-hole';
        hole.style.left = (x - 10) + 'px';
        hole.style.top = (y - 10) + 'px';
        document.body.appendChild(hole);
        APP.shooting.bullets.push(hole);
        
        const smoke = document.createElement('div');
        smoke.className = 'smoke-puff';
        smoke.style.left = (x - 20) + 'px';
        smoke.style.top = (y - 20) + 'px';
        document.body.appendChild(smoke);
        setTimeout(() => smoke.remove(), 1500);
        
        // 20S PURGE
        setTimeout(() => {
            hole.style.opacity = '0';
            hole.style.transition = 'opacity 0.5s';
            setTimeout(() => {
                hole.remove();
                const idx = APP.shooting.bullets.indexOf(hole);
                if (idx > -1) APP.shooting.bullets.splice(idx, 1);
            }, 500);
        }, 20000);
    }
    
    // FIRE WEAPON - CORE FUNCTION WITH THROTTLE AND INTEGRITY
    function fireWeapon(x, y) {
        // 100MS THROTTLE
        const now = Date.now();
        if (now - APP.shooting.lastFireTime < APP.shooting.fireThrottle) return;
        APP.shooting.lastFireTime = now;
        
        // INTEGRITY DAMAGE
        APP.glassIntegrity = Math.max(0, APP.glassIntegrity - 2);
        updateIntegrityBar();
        startRepairTimer();
        
        // Check for terminal shatter
        if (APP.glassIntegrity <= 0 && !APP.lensShattered) {
            triggerTerminalShatter();
            return;
        }
        
        const stage = $('stage');
        const stageRect = stage.getBoundingClientRect();
        const target = document.elementFromPoint(x, y);
        
        // Material detection
        const isGlass = x >= stageRect.left && x <= stageRect.right &&
                        y >= stageRect.top && y <= stageRect.bottom;
        
        const isMetal = target && (
            target.classList.contains('btn') ||
            target.closest('.sidebar') ||
            target.closest('#top-bar') ||
            target.closest('#bottom-bar')
        );
        
        if (isGlass && !isMetal) {
            createGlassFracture(x, y);
        } else if (isMetal) {
            const metalEl = target.classList.contains('btn') ? target : 
                           (target.closest('.sidebar') || target.closest('#top-bar') || target.closest('#bottom-bar'));
            if (metalEl) createMetalDent(metalEl);
            createBulletHole(x, y);
        } else {
            createBulletHole(x, y);
            playMetalTink();
        }
        
        // Screen shake
        document.body.style.transform = `translate(${(Math.random()-0.5)*8}px, ${(Math.random()-0.5)*8}px)`;
        setTimeout(() => document.body.style.transform = '', 40);
    }
    
    // WEAPON STATE ISOLATION - GLOBAL CAPTURE PHASE LISTENER
    function weaponGlobalInterceptor(e) {
        if (!APP.shooting.active) return;
        
        // Allow clicking the weapon toggle button
        const target = e.target;
        if (target.id === 'btn-shooting' || target.closest('#btn-shooting')) {
            return; // Let the click through
        }
        
        // PREVENT ALL OTHER CLICKS - Complete input safety
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        
        // Fire weapon at click location
        fireWeapon(e.clientX, e.clientY);
    }
    
    // MACHINE GUN - 100MS RAPID FIRE ON MOUSEDOWN
    let machineGunActive = false;
    
    function startMachineGun(e) {
        if (!APP.shooting.active) return;
        
        const target = e.target;
        if (target.id === 'btn-shooting' || target.closest('#btn-shooting')) {
            return;
        }
        
        e.preventDefault();
        machineGunActive = true;
        APP.shooting.lastX = e.clientX;
        APP.shooting.lastY = e.clientY;
        
        fireWeapon(e.clientX, e.clientY);
        
        APP.shooting.machineGunInterval = setInterval(() => {
            if (machineGunActive && APP.shooting.active) {
                const jitterX = APP.shooting.lastX + (Math.random() - 0.5) * 20;
                const jitterY = APP.shooting.lastY + (Math.random() - 0.5) * 20;
                fireWeapon(jitterX, jitterY);
            }
        }, 100);
    }
    
    function stopMachineGun() {
        machineGunActive = false;
        if (APP.shooting.machineGunInterval) {
            clearInterval(APP.shooting.machineGunInterval);
            APP.shooting.machineGunInterval = null;
        }
    }
    
    function trackMouse(e) {
        APP.shooting.lastX = e.clientX;
        APP.shooting.lastY = e.clientY;
    }
    
    $('btn-shooting').onclick = () => {
        APP.shooting.active = !APP.shooting.active;
        $('btn-shooting').classList.toggle('on', APP.shooting.active);
        document.body.classList.toggle('shooting-mode', APP.shooting.active);
        
        if (APP.shooting.active) {
            log('MACHINE_GUN: ARMED');
            updateIntegrityBar();
            
            // WEAPON STATE ISOLATION - Capture phase for complete input safety
            window.addEventListener('click', weaponGlobalInterceptor, true);
            document.addEventListener('mousemove', trackMouse);
            document.addEventListener('mousedown', startMachineGun);
            document.addEventListener('mouseup', stopMachineGun);
            
        } else {
            stopMachineGun();
            window.removeEventListener('click', weaponGlobalInterceptor, true);
            document.removeEventListener('mousemove', trackMouse);
            document.removeEventListener('mousedown', startMachineGun);
            document.removeEventListener('mouseup', stopMachineGun);
            
            // Clear repair timer but keep damage visible
            if (APP.shooting.repairTimer) {
                clearTimeout(APP.shooting.repairTimer);
                APP.shooting.repairTimer = null;
            }
            
            // Hide integrity bar after delay
            setTimeout(() => {
                if (!APP.shooting.active) {
                    $('integrity-bar').classList.remove('active');
                }
            }, 3000);
            
            log('MACHINE_GUN: OFF');
        }
    };

    // --- P2P / E2E CALL (FIXED) ---

// Helper to reset buttons to default state
const resetP2PButtons = () => {
    $('btn-call-guest').textContent = 'CALL';
    $('btn-call-guest').style.borderColor = 'var(--text-main)';
    $('btn-call-guest').style.color = 'var(--text-main)';
    
    $('btn-init-peer').textContent = 'INIT';
    $('btn-init-peer').style.display = 'inline-block';
    
    // Clear the temp incoming call object
    if (APP.peer) APP.peer.incomingCall = null;
};

$('btn-init-peer').onclick = () => {
    if (APP.peer && APP.peer.peer) {
        log('PEER: Already initialized');
        return;
    }
    
    try {
        const peerId = 'VNGRD-' + Math.random().toString(36).substr(2, 8).toUpperCase();
        APP.peer = {
            peer: new Peer(peerId),
            call: null,
            incomingCall: null, // Staging area for ringing calls
            localStream: null
        };
        
        APP.peer.peer.on('open', (id) => {
            $('peer-id-display').value = id;
            if ($('guest-dot')) $('guest-dot').classList.remove('off');
            $('call-status').textContent = 'READY TO CALL';
            $('call-status').style.color = 'var(--g)';
            log('PEER: ' + id);
        });
        
        APP.peer.peer.on('error', (err) => {
            log('PEER ERROR: ' + err.type);
            $('call-status').textContent = 'ERR: ' + err.type;
            $('call-status').style.color = 'var(--r)';
        });
        
        // --- INCOMING CALL HANDLER (Non-Blocking) ---
        APP.peer.peer.on('call', (call) => {
            log('INCOMING_CALL FROM ' + call.peer);
            
            // 1. Store the call object but DO NOT answer yet
            APP.peer.incomingCall = call;
            
            // 2. Update UI to "Ringing" Mode
            $('call-status').textContent = 'RINGING... (' + call.peer + ')';
            $('call-status').style.color = 'var(--y)'; // Yellow for caution
            
            // 3. Turn the "CALL" button into an "ACCEPT" button
            const btnCall = $('btn-call-guest');
            btnCall.textContent = 'ACCEPT CALL';
            btnCall.style.borderColor = 'var(--g)';
            btnCall.style.color = 'var(--g)';
            
            // 4. Play a ring sound if you have one (optional)
            // new Audio('assets/ring.mp3').play().catch(e => {});
        });
        
    } catch (e) {
        log('PEER INIT ERROR: ' + e.message);
    }
};

$('btn-copy-id').onclick = () => {
    const idField = $('peer-id-display');
    if (idField && idField.value) {
        navigator.clipboard.writeText(idField.value);
        const originalText = $('btn-copy-id').textContent;
        $('btn-copy-id').textContent = '✓ COPIED';
        setTimeout(() => $('btn-copy-id').textContent = originalText, 2000);
    }
};

// --- UNIFIED CALL / ANSWER BUTTON ---
$('btn-call-guest').onclick = async () => {
    if (!APP.peer || !APP.peer.peer) {
        alert('CLICK_INIT_FIRST');
        return;
    }

    // SCENARIO A: ANSWERING AN INCOMING CALL
    if (APP.peer.incomingCall) {
        try {
            log('ANSWERING CALL...');
            $('call-status').textContent = 'CONNECTING...';
            
            // 1. Get Local Media (Now allowed because user clicked button)
            const audioConstraints = APP.inputDevices.selectedId 
                ? { deviceId: { exact: APP.inputDevices.selectedId } } 
                : true;

            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: true, 
                audio: audioConstraints 
            });
            
            APP.peer.localStream = stream;
            
            // 2. Answer the staged call
            const call = APP.peer.incomingCall;
            call.answer(stream);
            
            // 3. Handle the stream when it arrives
            handleCallStream(call);
            
            // 4. Cleanup UI
            APP.peer.incomingCall = null; // Clear staging
            
        } catch (e) {
            log('ANSWER ERROR: ' + e.message);
            resetP2PButtons();
        }
        return;
    }

    // SCENARIO B: MAKING A NEW CALL
    const remoteId = $('remote-peer-id').value.trim();
    if (!remoteId) {
        alert('ENTER_GUEST_ID_TO_CALL');
        return;
    }
    
    try {
        $('call-status').textContent = 'CALLING...';
        $('call-status').style.color = 'var(--y)';
        
        const audioConstraints = APP.inputDevices.selectedId 
            ? { deviceId: { exact: APP.inputDevices.selectedId } } 
            : true;
        
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: true, 
            audio: audioConstraints 
        });
        APP.peer.localStream = stream;
        
        const call = APP.peer.peer.call(remoteId, stream);
        handleCallStream(call);
        
    } catch (e) {
        log('CALL_ERROR: ' + e.message);
        $('call-status').textContent = 'FAILED: ' + e.message;
        $('call-status').style.color = 'var(--r)';
    }
};

// Shared Logic for both Incoming and Outgoing calls
function handleCallStream(call) {
    call.on('stream', (remoteStream) => {
        // Ensure Video Element Exists
        if (!APP.guest.videoElement) {
            APP.guest.videoElement = document.createElement('video');
            APP.guest.videoElement.autoplay = true;
            APP.guest.videoElement.playsInline = true;
            // Optionally append to DOM if not already handled elsewhere
            // document.body.appendChild(APP.guest.videoElement); 
        }
        
        APP.guest.videoElement.srcObject = remoteStream;
        APP.guest.stream = remoteStream;
        APP.guest.isActive = true;
        
        // If you have the DAW Audio Chain logic:
        // if (typeof connectVideoAudio === 'function') connectVideoAudio(APP.guest.videoElement);

        $('call-status').textContent = 'CONNECTED';
        $('call-status').style.color = 'var(--g)';
        
        // Reset button to "CALL" state (or change to "MUTE" if you prefer)
        $('btn-call-guest').textContent = 'CALL (ACTIVE)';
        
        log('CALL_ESTABLISHED_WITH: ' + call.peer);
    });
    
    call.on('close', () => {
        endCallCleanup();
    });
    
    call.on('error', (err) => {
        log('CALL_ERROR: ' + err);
        endCallCleanup();
    });
    
    APP.peer.call = call;
}

$('btn-hangup').onclick = () => {
    if (APP.peer && APP.peer.call) {
        APP.peer.call.close();
    }
    // Also reject if it was just ringing
    if (APP.peer && APP.peer.incomingCall) {
        APP.peer.incomingCall.close();
        log('INCOMING CALL REJECTED');
    }
    endCallCleanup();
};

function endCallCleanup() {
    if (APP.peer && APP.peer.localStream) {
        APP.peer.localStream.getTracks().forEach(t => t.stop());
    }
    
    APP.guest.isActive = false;
    APP.guest.stream = null;
    APP.peer.call = null;
    APP.peer.incomingCall = null;
    
    $('call-status').textContent = 'DISCONNECTED';
    $('call-status').style.color = 'var(--text-dim)';
    
    resetP2PButtons();
    log('CALL_ENDED_CLEANUP');
}
    // ========================================
    // ========================================
    // PRO-AUDIO: 48KHZ RAW DIRECT PATH
    // NO ECHO/NOISE PROCESSING
    // ========================================
    async function scanAudioInputDevices() {
        try {
            // Request permission with basic constraints first
            await navigator.mediaDevices.getUserMedia({ audio: true });
            
            const devices = await navigator.mediaDevices.enumerateDevices();
            const audioInputs = devices.filter(d => d.kind === 'audioinput');
            
            APP.inputDevices.list = audioInputs;
            
            const select = $('audio-input-select');
            select.innerHTML = '<option value="">SELECT_DEVICE...</option>';
            
            audioInputs.forEach((device, idx) => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.textContent = device.label || `INPUT_${idx + 1}`;
                select.appendChild(option);
            });
            
            log('SCAN: ' + audioInputs.length + ' AUDIO_INPUTS');
            return audioInputs;
        } catch (e) {
            log('SCAN_ERROR: ' + e.message);
            return [];
        }
    }
    
    // 48KHZ RAW DIRECT PATH - DISABLE ALL BROWSER PROCESSING
    async function switchAudioInput(deviceId) {
        if (APP.inputDevices.stream) {
            APP.inputDevices.stream.getTracks().forEach(t => t.stop());
        }
        
        try {
            // PRO-AUDIO CONSTRAINTS: 48kHz, NO PROCESSING
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    deviceId: { exact: deviceId },
                    sampleRate: { ideal: 48000 },
                    sampleSize: { ideal: 24 },
                    channelCount: { ideal: 2 },
                    // DISABLE ALL BROWSER PROCESSING FOR RAW SIGNAL
                    echoCancellation: { exact: false },
                    noiseSuppression: { exact: false },
                    autoGainControl: { exact: false }
                }
            });
            
            APP.inputDevices.stream = stream;
            APP.inputDevices.selectedId = deviceId;
            
            // Create high-quality AudioContext at 48kHz
            if (!APP.audio.ctx || APP.audio.ctx.sampleRate !== 48000) {
                APP.audio.ctx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
            }
            
            const source = APP.audio.ctx.createMediaStreamSource(stream);
            APP.inputDevices.analyzer = APP.audio.ctx.createAnalyser();
            APP.inputDevices.analyzer.fftSize = 512; // Higher resolution
            APP.inputDevices.analyzer.smoothingTimeConstant = 0.3;
            source.connect(APP.inputDevices.analyzer);
            
            // Start input level monitoring with seismic
            monitorInputLevel();
            
            log('PRO_AUDIO: 48KHZ_RAW // ' + deviceId.substring(0, 8));
        } catch (e) {
            // Fallback without exact constraints
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        deviceId: { exact: deviceId },
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });
                APP.inputDevices.stream = stream;
                APP.inputDevices.selectedId = deviceId;
                
                if (!APP.audio.ctx) {
                    APP.audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                const source = APP.audio.ctx.createMediaStreamSource(stream);
                APP.inputDevices.analyzer = APP.audio.ctx.createAnalyser();
                APP.inputDevices.analyzer.fftSize = 512;
                source.connect(APP.inputDevices.analyzer);
                
                monitorInputLevel();
                log('INPUT_SWITCHED: ' + deviceId.substring(0, 8));
            } catch (e2) {
                log('INPUT_ERROR: ' + e2.message);
            }
        }
    }
    
    // SEISMIC SHAKE TRIGGER THRESHOLD
    let seismicTimeout = null;
    
    function monitorInputLevel() {
        if (!APP.inputDevices.analyzer) return;
        
        const dataArray = new Uint8Array(APP.inputDevices.analyzer.frequencyBinCount);
        const bassArray = new Uint8Array(16); // Low frequencies only
        
        function update() {
            if (!APP.inputDevices.analyzer) return;
            
            APP.inputDevices.analyzer.getByteFrequencyData(dataArray);
            
            // Overall level
            const avg = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
            const level = Math.min(100, (avg / 128) * 100);
            
            // Bass level (first 16 bins = low frequencies)
            for (let i = 0; i < 16; i++) bassArray[i] = dataArray[i];
            const bassAvg = bassArray.reduce((a, b) => a + b, 0) / bassArray.length;
            const bassLevel = Math.min(100, (bassAvg / 128) * 100);
            
            $('input-level-bar').style.width = level + '%';
            
            // SEISMIC SHAKE on loud bass or mic input
            if (bassLevel > 70 || level > 80) {
                if (!seismicTimeout) {
                    document.body.classList.add('seismic-active');
                    seismicTimeout = setTimeout(() => {
                        document.body.classList.remove('seismic-active');
                        seismicTimeout = null;
                    }, 150);
                }
            }
            
            // Voice reactivity - WHITE_FLASH
            if (APP.atmosphere.voiceReact && level > 60) {
                document.body.classList.add('voice-flash');
                setTimeout(() => document.body.classList.remove('voice-flash'), 80);
                
            }
            
            requestAnimationFrame(update);
        }
        update();
    }
    
    $('btn-scan-inputs').onclick = scanAudioInputDevices;
    $('audio-input-select').onchange = (e) => {
        if (e.target.value) {
            switchAudioInput(e.target.value);
        }
    };

    // ========================================
    // SATELLITE_WEATHER_DATA (FX STRIPPED)
    // GEO_HANDSHAKE + OPEN-METEO API
    // ========================================

    // GEO_HANDSHAKE: Get real coordinates
   async function initAtmosphere() {
    log('GEO_HANDSHAKE: ACQUIRING...');
    const geoStatus = $('geo-status');
    if (geoStatus) geoStatus.textContent = 'GEO: ACQUIRING...';
    
    return new Promise((resolve) => {
        if (!navigator.geolocation) {
            log('GEO: NOT_SUPPORTED');
            resolve(false);
            return;
        }
        
        // This triggers the real browser popup
        navigator.geolocation.getCurrentPosition(
            async (position) => {
                APP.atmosphere.latitude = position.coords.latitude;
                APP.atmosphere.longitude = position.coords.longitude;
                log(`GPS_LOCKED: ${APP.atmosphere.latitude.toFixed(2)}`);
                await fetchSatelliteWeather();
                resolve(true);
            },
            async (error) => {
                log('GPS_DENIED: FALLBACK_ENGAGED');
                // Use the IP lookup ONLY if the user said NO to GPS
                try {
                    const res = await fetch('https://ipapi.co/json/');
                    const data = await res.json();
                    APP.atmosphere.latitude = data.latitude;
                    APP.atmosphere.longitude = data.longitude;
                    APP.atmosphere.city = data.city.toUpperCase();
                    await fetchSatelliteWeather();
                } catch (e) {
                    APP.atmosphere.latitude = 52.52; // Absolute backup
                    APP.atmosphere.longitude = 13.41;
                    await fetchSatelliteWeather();
                }
                resolve(false);
            },
            { enableHighAccuracy: true, timeout: 8000 }
        );
    });
}
    
    // Fetch weather from Open-Meteo with reverse geocoding
    async function fetchSatelliteWeather() {
        try {
            const lat = APP.atmosphere.latitude || 52.52;
            const lon = APP.atmosphere.longitude || 13.41;
            
            // Weather data
            const weatherResp = await fetch(
                `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=weathercode`
            );
            const weather = await weatherResp.json();
            
            const temp = weather.current_weather.temperature;
            const weatherCode = weather.current_weather.weathercode;
            const windSpeed = weather.current_weather.windspeed;
            
            APP.atmosphere.temperature = temp;
            APP.atmosphere.weatherCode = weatherCode;
            
            // Weather code interpretation
            const weatherMap = {
                0: 'CLEAR', 1: 'MAINLY_CLEAR', 2: 'PARTLY_CLOUDY', 3: 'OVERCAST',
                45: 'FOG', 48: 'RIME_FOG',
                51: 'LIGHT_DRIZZLE', 53: 'DRIZZLE', 55: 'DENSE_DRIZZLE',
                61: 'LIGHT_RAIN', 63: 'RAIN', 65: 'HEAVY_RAIN',
                71: 'LIGHT_SNOW', 73: 'SNOW', 75: 'HEAVY_SNOW',
                80: 'LIGHT_SHOWERS', 81: 'SHOWERS', 82: 'VIOLENT_SHOWERS',
                95: 'THUNDERSTORM', 96: 'HAIL_STORM', 99: 'HEAVY_HAIL'
            };
            
            const condition = weatherMap[weatherCode] || 'UNKNOWN';
            APP.atmosphere.metar = `${temp}C // ${condition} // ${windSpeed}KMH`;
            
            // Check if raining
            APP.atmosphere.isRaining = [51, 53, 55, 61, 63, 65, 80, 81, 82, 95, 96, 99].includes(weatherCode);
            
            // Reverse geocoding for city name
            try {
                const geoResp = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json`
                );
                const geo = await geoResp.json();
                APP.atmosphere.city = (geo.address?.city || geo.address?.town || geo.address?.village || 'UNKNOWN').toUpperCase();
                APP.atmosphere.country = (geo.address?.country_code || '').toUpperCase();
            } catch (e) {
                APP.atmosphere.city = 'UNKNOWN';
            }
            
            // Update geo status
            const geoStatus = $('geo-status');
            if (geoStatus) geoStatus.textContent = `GEO: ${APP.atmosphere.city} [${APP.atmosphere.country}]`;
            
            // Update ticker with METAR data
            updateTickerWithMetar();
            
            // Update UI with weather data (FX stripped)
            updateWeatherUI(condition, APP.atmosphere.isRaining);
            
            log(`SATELLITE: [${APP.atmosphere.city}] ${APP.atmosphere.metar}`);
            
        } catch (e) {
            log('SATELLITE_ERROR: ' + e.message);
            const weatherStatus = $('weather-status');
            if (weatherStatus) weatherStatus.textContent = 'WEATHER: ERROR';
        }
    }
    
    // Update ticker with fresh weather data (feeds into cycle engine)
    function updateTickerWithMetar() {
        updateTickerCycle();
        if (APP.atmosphere.city) log(`REAL_TIME_SYNC: ${APP.atmosphere.city} @ ${APP.atmosphere.temperature}°C`);
    }
    

    
    
    
    
    // Update weather UI status displays (data only, no FX)
    function updateWeatherUI(condition, isRaining) {
        const weatherStatus = $('weather-status');
        const atmosDot = $('atmos-dot');
        if (weatherStatus) weatherStatus.textContent = 'WEATHER: ' + condition.toUpperCase();
        if (atmosDot) atmosDot.classList.toggle('off', !isRaining);
        if ($('weather-fx')) $('weather-fx').textContent = isRaining ? 'RAIN_DETECTED (DATA ONLY)' : 'CLEAR (DATA ONLY)';
    }
    

    

    
    
    
    
    
    

    
    // Initialize satellite atmosphere on load (10-minute polling)
    initAtmosphere();
    setInterval(fetchSatelliteWeather, 600000); // 10 min refresh

    // ========================================
    // NFT_VAULT: SCAN WALLET ASSETS (ETH + TEZOS)
    // ========================================

    // Helper: resolve IPFS URLs to gateway
    function resolveNFTUrl(url) {
        if (!url) return '';
        if (url.startsWith('ipfs://')) return 'https://ipfs.io/ipfs/' + url.slice(7);
        if (url.startsWith('https://ipfs.io/')) return url;
        return url;
    }

    // Helper: build vault HTML + populate APP.user.assets from a flat array
    function renderVaultList(allNfts) {
        APP.user.assets = [];
        APP.wallet.nfts = allNfts;
        var html = '';
        var assetIdx = 0;
        allNfts.forEach(function(nft) {
            var imageUrl = resolveNFTUrl(nft.imageUrl);
            if (imageUrl) {
                var img = new Image();
                img.crossOrigin = 'anonymous';
                img.src = imageUrl;
                APP.user.assets.push({ name: nft.name, imageUrl: imageUrl, image: img });
                html += '<div class="nft-vault-item" data-nft-index="' + assetIdx + '" style="margin:2px 0;padding:3px 4px;color:var(--accent);cursor:pointer;border:1px solid transparent;transition:border-color 0.15s;" onmouseenter="this.style.borderColor=\'var(--accent)\'" onmouseleave="this.style.borderColor=\'transparent\'">' + nft.name.substring(0, 20) + ' <span style="color:var(--text-dim);font-size:7px;">[' + nft.chain + ']</span></div>';
                assetIdx++;
            } else {
                html += '<div style="margin:2px 0;color:var(--text-dim);">' + nft.name.substring(0, 20) + ' [' + nft.chain + ']</div>';
            }
        });
        return html;
    }

    // Scan ETH via Alchemy
    async function scanETHNfts(address) {
        var alchemyKey = (window.VNGRD_CONFIG && window.VNGRD_CONFIG.ALCHEMY_KEY)
            || (document.querySelector('meta[name="alchemy-key"]') ? document.querySelector('meta[name="alchemy-key"]').content : null)
            || 'demo';
        var results = [];
        var resp = await fetch('https://eth-mainnet.g.alchemy.com/nft/v2/' + alchemyKey + '/getNFTs?owner=' + address + '&pageSize=20');
        var data = await resp.json();
        if (data.ownedNfts) {
            data.ownedNfts.forEach(function(nft) {
                var name = nft.title || (nft.contract && nft.contract.name) || 'UNKNOWN';
                var imageUrl = (nft.media && nft.media[0] && nft.media[0].gateway)
                    || (nft.metadata && nft.metadata.image)
                    || '';
                results.push({ name: name, imageUrl: imageUrl, chain: 'ETH' });
            });
        }
        return results;
    }

    // Scan Tezos via TzKT (free, no key needed, CORS-enabled)
    $('btn-scan-nfts').onclick = async () => {
        let tezAddr = $('tezos-addr') ? $('tezos-addr').value.trim() : '';
        
        // --- 1. RESOLVE .TEZ DOMAIN ---
        if (tezAddr.endsWith('.tez')) {
            log('NFT_VAULT: RESOLVING ' + tezAddr + '...');
            try {
                // Query the Tezos Domains API
                const domainResp = await fetch('https://api.tezos.domains/v1/domains/' + tezAddr);
                const domainData = await domainResp.json();
                
                if (domainData && domainData.address) {
                    tezAddr = domainData.address;
                    log('NFT_VAULT: RESOLVED TO ' + tezAddr);
                } else {
                    log('NFT_VAULT: DOMAIN_NOT_FOUND');
                }
            } catch (e) {
                log('NFT_VAULT: RESOLVE_ERROR');
            }
        }

        var hasEth = APP.wallet.connected && APP.wallet.address;
        var hasTez = tezAddr && tezAddr.startsWith('tz');

        if (!hasEth && !hasTez) {
            $('nft-vault-list').innerHTML = 'INVALID_ADDR_OR_NOT_CONNECTED';
            return;
        }

        // --- 2. SYSTEM PURGE (FX CLEANSE) ---
        // This stops the "FX on load" bug and helps recover FPS before the scan
        if (typeof panicReset === 'function') {
            panicReset();
            log('SYSTEM: FX_PURGE_COMPLETE');
        }

        $('nft-vault-list').innerHTML = 'SCANNING...';
        log('NFT_VAULT: SCANNING...');

        var allNfts = [];
        var errors = [];
        var promises = [];

        // Scan in parallel
        if (hasEth) {
            promises.push(scanETHNfts(APP.wallet.address).then(function(r) { 
                allNfts = allNfts.concat(r); 
                log('NFT_VAULT: ETH_FOUND ' + r.length); 
            }).catch(function(e) { 
                errors.push('ETH:' + e.message); 
            }));
        }

        if (hasTez) {
            promises.push(scanTezosNfts(tezAddr).then(function(r) { 
                allNfts = allNfts.concat(r); 
                log('NFT_VAULT: TEZ_FOUND ' + r.length); 
            }).catch(function(e) { 
                errors.push('TEZ:' + e.message); 
            }));
        }

        await Promise.all(promises);

        // --- 3. RENDER & UPDATE ---
        if (allNfts.length > 0) {
            // Ensure global VAULT_NFTS is updated for the click listener
            window.VAULT_NFTS = allNfts; 
            var html = renderVaultList(allNfts);
            $('nft-vault-list').innerHTML = html;
            $('nft-count').textContent = 'ASSETS: ' + allNfts.length;
            $('vault-dot').classList.remove('off');
            log('NFT_VAULT: ' + allNfts.length + ' ASSETS_LOADED');
        } else {
            $('nft-vault-list').innerHTML = errors.length > 0 ? 'SCAN_ERROR' : 'NO_NFTS_FOUND';
            $('nft-count').textContent = 'ASSETS: 0';
        }
    };

        $('nft-vault-list').innerHTML = 'SCANNING...';
        log('NFT_VAULT: SCANNING...');

        var allNfts = [];
        var errors = [];

        // Scan in parallel
        var promises = [];
        if (hasEth) promises.push(scanETHNfts(APP.wallet.address).then(function(r) { allNfts = allNfts.concat(r); log('NFT_VAULT: ETH_FOUND ' + r.length); }).catch(function(e) { errors.push('ETH:' + e.message); log('NFT_VAULT: ETH_FAIL ' + e.message); }));
        if (hasTez) promises.push(scanTezosNfts(tezAddr).then(function(r) { allNfts = allNfts.concat(r); log('NFT_VAULT: TEZ_FOUND ' + r.length); }).catch(function(e) { errors.push('TEZ:' + e.message); log('NFT_VAULT: TEZ_FAIL ' + e.message); }));

        await Promise.all(promises);

        if (allNfts.length > 0) {
            var html = renderVaultList(allNfts);
            $('nft-vault-list').innerHTML = html;
            $('nft-count').textContent = 'ASSETS: ' + allNfts.length;
            $('vault-dot').classList.remove('off');
            log('NFT_VAULT: ' + allNfts.length + ' TOTAL ASSETS LOADED');
        } else {
            var msg = '';
            if (errors.length > 0) {
                msg = 'SCAN_ERR: ' + errors.join(', ');
            } else if (hasEth && !hasTez) {
                msg = 'NO_ETH_NFTS — ENTER tz1... ABOVE FOR TEZOS';
            } else {
                msg = 'NO_NFTS_FOUND';
            }
            $('nft-vault-list').innerHTML = msg;
            $('nft-count').textContent = 'ASSETS: 0';
        }
    };

    // NFT_VAULT — Event delegation: clicking a sidebar NFT item summons it to canvas
    $('nft-vault-list').addEventListener('click', function(e) {
        var item = e.target.closest('.nft-vault-item');
        if (!item) return;
        var idx = parseInt(item.getAttribute('data-nft-index'), 10);
        if (!isNaN(idx) && typeof summonNFTByIndex === 'function') {
            summonNFTByIndex(idx);
        }
    });

    // ========================================
    // v19 FEATURE PACK: TRANSITIONS + AI
    // ========================================

    // v19 SMOOTH TRANSITIONS — crossfade layers for AI/media swap
    const v19_Transitions = {
        init: () => {
            const style = document.createElement('style');
            style.innerHTML = `
                .vngrd-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                    background-size: cover; background-position: center;
                    transition: opacity 1.5s cubic-bezier(0.4, 0, 0.2, 1);
                    opacity: 0; z-index: 1; pointer-events: none; }
                .vngrd-layer.active { opacity: 1; z-index: 2; }
            `;
            document.head.appendChild(style);
            log('V19_TRANSITIONS: ONLINE');
        },
        swap: (imgUrl) => {
            const stage = $('stage');
            if (!stage) return;
            const active = stage.querySelector('.vngrd-layer.active');
            const next = document.createElement('div');
            next.className = 'vngrd-layer';
            next.style.backgroundImage = `url('${imgUrl}')`;
            stage.appendChild(next);
            void next.offsetWidth;
            next.classList.add('active');
            if (active) {
                active.classList.remove('active');
                setTimeout(() => active.remove(), 1600);
            }
        }
    };

    // v19 AI GENERATOR — Pollinations (primary, CORS-native) + Lexica (fallback)
    // Injects generated image into media queue (eject/cycle compatible)
    function injectAIImage(blobUrl, label) {
        var img = new Image();
        img.crossOrigin = 'anonymous';
        img.src = blobUrl;
        return new Promise(function(ok, fail) {
            img.onload = function() {
                APP.render.source = null; // Clear override so queue takes priority
                APP.neural.lastImage = blobUrl;
                APP.media.queue.push({ type: 'image', url: blobUrl, element: img, name: label });
                APP.media.currentIndex = APP.media.queue.length - 1;
                APP.media.currentElement = img;
                updateQueueDisplay();
                if ($('media-dot')) $('media-dot').classList.remove('off');
                // Glitch-flash feedback
                var stage = $('stage');
                if (stage) { stage.style.transition = 'none'; stage.style.filter = 'brightness(3) saturate(2)'; setTimeout(function() { stage.style.transition = 'filter 0.5s'; stage.style.filter = ''; }, 100); }
                ok();
            };
            img.onerror = function() { fail(new Error('IMG_DECODE_FAIL')); };
        });
    }

    const v19_AI = {
        generate: async (prompt) => {
            const status = $('ai-status');
            const btn = $('btn-generate-ai');
            if (!prompt) { if (status) status.textContent = 'ENTER_PROMPT'; return; }
            if (APP.neural.generating) return;
            APP.neural.generating = true;
            if (status) { status.textContent = 'RENDERING...'; status.style.color = 'var(--v)'; }
            if (btn) btn.classList.add('on');
            if ($('neural-dot')) $('neural-dot').classList.remove('off');
            log('NEURAL: GENERATING >> ' + prompt);

            // Helper: try fetch with multiple CORS proxies
            async function proxyFetch(url) {
                var proxies = [
                    'https://api.allorigins.win/raw?url=' + encodeURIComponent(url),
                    'https://corsproxy.io/?' + encodeURIComponent(url),
                    'https://api.codetabs.com/v1/proxy?quest=' + encodeURIComponent(url)
                ];
                for (var p = 0; p < proxies.length; p++) {
                    try {
                        var r = await fetch(proxies[p]);
                        if (r.ok) return r;
                    } catch(e) { /* try next proxy */ }
                }
                throw new Error('ALL_PROXIES_FAILED');
            }

            // Strategy 1: Pollinations (CORS-native text-to-image, multiple endpoint formats)
            async function tryPollinations() {
                if (status) status.textContent = 'POLLINATIONS: RENDERING...';
                var seed = Math.floor(Math.random() * 999999);
                // Try current API format first, then legacy format
                var fullPrompt = prompt;
                var urls = [
                    `https://image.pollinations.ai/prompt/${encodeURIComponent(fullPrompt)}?width=1024&height=1024&model=flux&nologo=true&seed=${seed}`
                ];
                for (var u = 0; u < urls.length; u++) {
                    try {
                        var res = await fetch(urls[u]);
                        if (!res.ok) continue;
                        var blob = await res.blob();
                        if (blob.size < 1000 || !blob.type.startsWith('image/')) continue;
                        return URL.createObjectURL(blob);
                    } catch(e) { /* try next */ }
                }
                throw new Error('POLL_ALL_FAIL');
            }

            // Strategy 2: Lexica search via CORS proxy
            async function tryLexica() {
                if (status) status.textContent = 'LEXICA: SEARCHING...';
                var res = await proxyFetch('https://lexica.art/api/v1/search?q=' + encodeURIComponent(prompt));
                var data = await res.json();
                if (!data.images || data.images.length === 0) throw new Error('NO_RESULTS');
                var pick = data.images[Math.floor(Math.random() * Math.min(10, data.images.length))];
                var imgUrl = pick.src || pick.srcSmall;
                if (!imgUrl) throw new Error('NO_SRC');
                if (status) status.textContent = 'DOWNLOADING...';
                var imgRes = await proxyFetch(imgUrl);
                var blob = await imgRes.blob();
                return URL.createObjectURL(blob);
            }

            // Strategy 3: Unsplash search (photo search by keyword, CORS-native)
            async function tryUnsplash() {
                if (status) status.textContent = 'UNSPLASH: SEARCHING...';
                // Unsplash Source API — random photo matching query, no key needed
                var url = 'https://source.unsplash.com/1280x720/?' + encodeURIComponent(prompt) + '&sig=' + Date.now();
                var res = await fetch(url);
                if (!res.ok) throw new Error('UNSPLASH_' + res.status);
                var blob = await res.blob();
                if (blob.size < 1000) throw new Error('UNSPLASH_EMPTY');
                return URL.createObjectURL(blob);
            }

            var strategies = [
                { name: 'POLLINATIONS', fn: tryPollinations },
                { name: 'LEXICA', fn: tryLexica },
                { name: 'UNSPLASH', fn: tryUnsplash }
            ];

            var success = false;
            for (var s = 0; s < strategies.length; s++) {
                try {
                    var blobUrl = await strategies[s].fn();
                    await injectAIImage(blobUrl, 'AI_' + prompt.substring(0, 20).replace(/\s+/g, '_'));
                    if (status) { status.textContent = strategies[s].name + ' → MEDIA DECK'; status.style.color = 'var(--g)'; }
                    log('NEURAL: ' + strategies[s].name + '_INJECTED');
                    success = true;
                    break;
                } catch(err) {
                    log('NEURAL: ' + strategies[s].name + '_FAIL (' + err.message + ')');
                    if (s < strategies.length - 1) log('NEURAL: TRYING → ' + strategies[s + 1].name);
                }
            }

            if (!success) {
                if (status) { status.textContent = 'ALL_SOURCES_FAILED'; status.style.color = 'var(--r)'; }
                log('NEURAL_ERROR: ALL_STRATEGIES_EXHAUSTED');
            }

            setTimeout(() => { APP.neural.generating = false; if (btn) btn.classList.remove('on'); }, 1000);
        }
    };

    // Wire AI generate button
    if ($('btn-generate-ai')) {
        $('btn-generate-ai').onclick = () => {
            const prompt = $('ai-prompt') ? $('ai-prompt').value.trim() : '';
            v19_AI.generate(prompt);
        };

    // TACTICAL_XY mouse tracking
    document.addEventListener('mousemove', function(e) {
        APP.vj.mouseX = e.clientX / window.innerWidth;
        APP.vj.mouseY = e.clientY / window.innerHeight;
    });

    // Collapsible sections with arrow indicators
    ['session-lab-body', 'p2p-call-body', 'midi-host-body', 'nft-vault-body'].forEach(function(id) {
        var el = $(id);
        if (!el) return;
        var head = el.previousElementSibling;
        if (!head) return;
        var arrow = head.querySelector('.sec-arrow');
        head.onclick = function() {
            var isOpen = head.classList.toggle('open');
            el.style.maxHeight = isOpen ? '500px' : '0';
            el.style.padding = isOpen ? '10px 12px' : '0 12px';
            if (arrow) arrow.textContent = isOpen ? '\u25BE' : '\u25B8';
        };
    });
    }

    // Init v19 transitions
    v19_Transitions.init();

    // --- DRAG INITIALIZATION (mid-script) ---
    makeLogSafeDraggable($('sys-log'));


    
    
    
    

    // initHologram() REMOVED — single 3D engine lives in module script
    // Widget-layer is hidden by default; only the module btn-inject-3d activates it
    
    // Widget-layer wheel/drag handlers REMOVED — Touch-Bridge handles all scaling
    
    // Initialize hologram after a short delay
    // initHologram() call REMOVED — function no longer exists

    
    

    
    // Shatter all button
    if ($('btn-shatter-all')) {
        $('btn-shatter-all').onclick = () => {
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                if (typeof createGlassFracture === 'function') createGlassFracture(x, y);
            }
            log('SHATTER_ALL: TRIGGERED');
        };
    }
    
    // ========================================
    // CAMERA PREVIEW - FLOATING BOX
    // ========================================
    function updateCameraPreview() {
        const preview = $('cam-preview-float');
        const previewVid = $('preview-vid-float');
        
        if (APP.camera.stream && preview && previewVid) {
            previewVid.srcObject = APP.camera.stream;
            preview.classList.add('active');
            APP.camera.previewEl = previewVid;
        }
    }
    
    // Hook into camera init
    const originalInitCamera = window.initCamera;
    window.initCamera = async function() {
        if (typeof originalInitCamera === 'function') {
            await originalInitCamera();
        }
        setTimeout(updateCameraPreview, 500);
    };
    
    // ========================================
    // GEODATA TICKER INJECTION
    // ========================================
    function injectGeoToTicker() {
        const ticker = $('ticker-text');
        if (!ticker || !APP.atmosphere.city) return;
        
        const geoData = `[LOC: ${APP.atmosphere.city.toUpperCase()}] // [LAT: ${APP.atmosphere.latitude?.toFixed(2) || '?'}] // [LON: ${APP.atmosphere.longitude?.toFixed(2) || '?'}]`;
        
        // Prepend geo data to ticker
        if (!ticker.textContent.includes('[LOC:')) {
            ticker.textContent = geoData + ' // ' + ticker.textContent;
        }
    }
    
    // ========================================
    // PRO-AUDIO: SPATIAL PANNING + PITCH RANDOMIZATION
    // ========================================
    function playImpactSoundWithSpatial(x, y) {
        if (!APP.shooting.audioCtx) return;
        
        const ctx = APP.shooting.audioCtx;
        
        // Create oscillator for tink
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const panner = ctx.createStereoPanner();
        
        // PITCH RANDOMIZATION (+/- 20%)
        const basePitch = 1600;
        const pitchVariation = basePitch * 0.2 * (Math.random() * 2 - 1);
        osc.frequency.value = basePitch + pitchVariation;
        osc.type = 'square';
        
        // SPATIAL PANNING (X-axis)
        const panValue = (x / window.innerWidth) * 2 - 1; // -1 to 1
        panner.pan.value = panValue;
        
        // Volume scaled
        gain.gain.setValueAtTime(0.3, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.05);
        
        osc.connect(gain);
        gain.connect(panner);
        panner.connect(ctx.destination);
        
        osc.start();
        osc.stop(ctx.currentTime + 0.05);
    }
    
    // Override playMetalTink to use spatial panning
    const originalPlayMetalTink = window.playMetalTink;
    window.playMetalTink = function(x, y) {
        playImpactSoundWithSpatial(x || window.innerWidth/2, y || window.innerHeight/2);
    };

    // Trinity drag is now canvas-space (initTrinityDrag) — no DOM drag needed

    // KEEP THIS: Initialize geo ticker injection
    setTimeout(injectGeoToTicker, 3000);
    
    // Initialize geo ticker injection
    setTimeout(injectGeoToTicker, 3000);

}); // THIS IS THE END of the startup block. Do not put code after this line.
// --- TACTICAL FX ELITE BRIDGE ---
window.toggleFX = function(fxName) {
    console.log("ACTIVATE_FX: " + fxName);
    const target = document.body;
    const className = `fx-${fxName}`;
    
    // List of all possible tactical classes to clear
    const allFX = [
        'fx-signal-loss', 'fx-thermal', 'fx-neural', 
        'fx-cyber-rot', 'fx-ghost', 'fx-void', 'fx-failure'
    ];
    
    if (target.classList.contains(className)) {
        target.classList.remove(className);
        console.log("FX_OFF: " + fxName);
    } else {
        // Remove ANY other active tactical FX first so they don't stack messily
        target.classList.remove(...allFX);
        target.classList.add(className);
        console.log("FX_ON: " + fxName);
    }
};window.toggleFX = function(fxName) {
    const target = document.body;
    const className = `fx-${fxName}`;
    
    // Clear only our specific tactical classes
    const allFX = ['fx-scan', 'fx-tear', 'fx-bloom', 'fx-chroma', 'fx-punch'];
    
    if (target.classList.contains(className)) {
        target.classList.remove(className);
    } else {
        target.classList.remove(...allFX);
        target.classList.add(className);
        console.log("MANIPULATION_ACTIVE: " + fxName.toUpperCase());
    }
};

// Ensure this matches your existing Hard Reset
window.triggerHardReset = function() {
    console.log("SYSTEM_EVENT: HARD_RESET");
    
    // 1. Clear EVERY possible FX class
    const allPossibleFX = [
        'fx-scan', 'fx-tear', 'fx-bloom', 'fx-chroma', 'fx-punch', 
        'fx-signal-loss', 'fx-thermal', 'fx-cyber-rot', 'fx-neural', 'fx-failure'
    ];
    document.body.classList.remove(...allPossibleFX);
    
    // 2. Run the CRT Collapse Animation
    document.body.classList.remove('anim-hard-reset');
    void document.body.offsetWidth; // Force CSS refresh
    document.body.classList.add('anim-hard-reset');
    
    // 3. Remove the animation class after it finishes
    setTimeout(() => document.body.classList.remove('anim-hard-reset'), 600);
};</script>
<script>
// ══════════════════════════════════════════════════
// SMART 3D LOADER (Fixes 'Always Cube' Bug)
// ══════════════════════════════════════════════════
(function() {
    var btn = document.getElementById('btn-inject-3d');
    if (!btn) return;

    btn.onclick = function() {
        // A. Critical Checks
        if (typeof THREE === 'undefined') { alert('Error: Three.js not loaded.'); return; }
        var holoCanvas = document.getElementById('hologram-canvas');
        if (!holoCanvas) { alert('Error: hologram-canvas missing.'); return; }

        // B. Setup Scene & Lights
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
        camera.position.z = 5;
        scene.add(new THREE.AmbientLight(0xffffff, 1.5));
        var dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // C. Setup Renderer — opaque black bg + screen blend = bulletproof hologram
        holoCanvas.width = 512; holoCanvas.height = 512;
        var renderer = new THREE.WebGLRenderer({ canvas: holoCanvas, antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(512, 512, false); renderer.setClearColor(0x000000, 1);

        // D. GLOBAL INIT: Assign scene/camera/renderer to APP immediately
        window.APP = window.APP || {};
        window.APP.hologram = window.APP.hologram || {};
        window.APP.hologram.scene = scene;
        window.APP.hologram.camera = camera;
        window.APP.hologram.renderer = renderer;

        // E. FILE HUNTER: Target the CORRECT 3D file input by ID
        var fileInput = document.getElementById('file-3d-model');
        var file = (fileInput && fileInput.files.length > 0) ? fileInput.files[0] : null;

        function loadModelFile(f) {
            var ext = f.name.split('.').pop().toLowerCase();
            var reader = new FileReader();

            if (ext === 'obj') {
                // OBJ files are text-based (e.g. MagicaVoxel exports)
                reader.onload = function(e) {
                    if (typeof THREE.OBJLoader === 'undefined') { alert("OBJLoader missing!"); addFallbackCube(); return; }
                    var loader = new THREE.OBJLoader();
                    try {
                        var obj = loader.parse(e.target.result);
                        autoScaleAndInject(obj);
                    } catch(err) { console.error('OBJ parse error:', err); addFallbackCube(); }
                };
                reader.readAsText(f);
            } else if (ext === 'stl') {
                // STL files are binary geometry
                reader.onload = function(e) {
                    if (typeof THREE.STLLoader === 'undefined') { alert("STLLoader missing!"); addFallbackCube(); return; }
                    var loader = new THREE.STLLoader();
                    try {
                        var geometry = loader.parse(e.target.result);
                        var mesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.3, roughness: 0.6 }));
                        autoScaleAndInject(mesh);
                    } catch(err) { console.error('STL parse error:', err); addFallbackCube(); }
                };
                reader.readAsArrayBuffer(f);
            } else {
                // GLB/GLTF/VGD/JSON → GLTFLoader
                reader.onload = function(e) {
                    if (typeof THREE.GLTFLoader === 'undefined') { alert("GLTFLoader missing!"); addFallbackCube(); return; }
                    var loader = new THREE.GLTFLoader();
                    loader.parse(e.target.result, '', function(gltf) {
                        autoScaleAndInject(gltf.scene);
                    }, function(err) { console.error('GLTF parse error:', err); addFallbackCube(); });
                };
                reader.readAsArrayBuffer(f);
            }

            function autoScaleAndInject(mesh) {
                var box = new THREE.Box3().setFromObject(mesh);
                var size = box.getSize(new THREE.Vector3()).length();
                var center = box.getCenter(new THREE.Vector3());
                mesh.position.sub(center); // center the model
                var scale = 3 / size;
                mesh.scale.set(scale, scale, scale);
                mesh.layers.set(0);
                mesh.traverse(function(child) { if (child.isMesh) child.layers.set(0); });
                finalizeInjection(scene, camera, renderer, mesh);
            }
        }

        if (file) {
            loadModelFile(file);
        } else if (fileInput) {
            // Show fallback cube immediately so the 3D viewport is always visible
            addFallbackCube();
            // Then open file dialog — on selection, replace the cube with the loaded model
            fileInput.onchange = function() {
                if (fileInput.files.length > 0) {
                    // Remove fallback cube before loading new model
                    if (window.APP.hologram.mesh) {
                        scene.remove(window.APP.hologram.mesh);
                        window.APP.hologram.mesh = null;
                    }
                    loadModelFile(fileInput.files[0]);
                }
            };
            fileInput.click();
            return;
        } else {
            addFallbackCube();
        }

        function addFallbackCube() {
            var cube = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshNormalMaterial({wireframe:true}));
            finalizeInjection(scene, camera, renderer, cube);
        }

        function finalizeInjection(scene, camera, renderer, mesh) {
            scene.add(mesh);
            // Global State Update
            window.APP = window.APP || {};
            window.APP.hologram = window.APP.hologram || {};
            window.APP.trinity = window.APP.trinity || { holo: {} };

            window.APP.hologram.scene = scene;
            window.APP.hologram.camera = camera;
            window.APP.hologram.renderer = renderer;
            window.APP.hologram.mesh = mesh;
            window.APP.hologram.baseScale = mesh.scale.x;
            window.APP.hologram.rotationSpeed = 0.02;
            window.APP.hologram.targetScale = 1.0;

            // Create 3D Logo Group (bottom-left, non-overlapping)
            if (!window.APP.hologram.logoGroup) {
                var logoGroup = new THREE.Group();
                logoGroup.position.set(-2.5, -2.2, 0);
                logoGroup.scale.set(0.4, 0.4, 0.4);
                scene.add(logoGroup);
                window.APP.hologram.logoGroup = logoGroup;
            }

            // Restore widget-layer visibility (btn-3d-x sets display:none)
            var wl = document.getElementById('widget-layer');
            if (wl) wl.style.display = 'block';

            window.APP.trinity.holo.x = 0.35;
            window.APP.trinity.holo.y = 0.25;
            window.APP.trinity.holo.scale = 1.0;
            window.APP.trinity.holo.visible = true;
            // Render Trigger + Layer Fix
            mesh.layers.set(0);
            mesh.traverse(function(child) { if (child.isMesh) child.layers.set(0); });
            renderer.render(scene, camera);
            // rAF wake — force the scene alive
            requestAnimationFrame(function() { renderer.render(scene, camera); });
            if (window.log) log('3D_INJECTED');
        }
    };
})();
</script>
<script>
// ══════════════════════════════════════════════════
// 3D LOGO INJECTOR — loads into APP.hologram.logoGroup
// ══════════════════════════════════════════════════
(function() {
    // Reuse the file-2d-logo input for 3D logo when holding Shift
    // Or provide a dedicated function callable from console
    window.inject3DLogo = function(file) {
        if (!window.APP || !window.APP.hologram || !window.APP.hologram.scene) {
            console.warn('3D Logo: Inject a 3D model first to create the scene.');
            return;
        }
        var scene = window.APP.hologram.scene;
        // Ensure logoGroup exists
        if (!window.APP.hologram.logoGroup) {
            var g = new THREE.Group();
            g.position.set(-2.5, -2.2, 0);
            g.scale.set(0.4, 0.4, 0.4);
            scene.add(g);
            window.APP.hologram.logoGroup = g;
        }
        var logoGroup = window.APP.hologram.logoGroup;
        // Clear existing logo children
        while (logoGroup.children.length > 0) {
            var child = logoGroup.children[0];
            logoGroup.remove(child);
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        }
        if (!file) {
            // Default: small rotating VNGRD text cube
            var cubeGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            var cubeMat = new THREE.MeshStandardMaterial({ color: 0x00f3ff, wireframe: true, emissive: 0x003344 });
            var cube = new THREE.Mesh(cubeGeo, cubeMat);
            logoGroup.add(cube);
            if (window.log) log('3D_LOGO: DEFAULT_CUBE');
            return;
        }
        var ext = file.name.split('.').pop().toLowerCase();
        var reader = new FileReader();
        if (ext === 'obj') {
            reader.onload = function(e) {
                if (typeof THREE.OBJLoader === 'undefined') return;
                var obj = new THREE.OBJLoader().parse(e.target.result);
                autoScaleLogo(obj, logoGroup);
            };
            reader.readAsText(file);
        } else if (ext === 'stl') {
            reader.onload = function(e) {
                if (typeof THREE.STLLoader === 'undefined') return;
                var geo = new THREE.STLLoader().parse(e.target.result);
                var mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x00f3ff, metalness: 0.5, roughness: 0.4 }));
                autoScaleLogo(mesh, logoGroup);
            };
            reader.readAsArrayBuffer(file);
        } else {
            reader.onload = function(e) {
                if (typeof THREE.GLTFLoader === 'undefined') return;
                new THREE.GLTFLoader().parse(e.target.result, '', function(gltf) {
                    autoScaleLogo(gltf.scene, logoGroup);
                }, function(err) { console.error('3D Logo load error:', err); });
            };
            reader.readAsArrayBuffer(file);
        }
    };
    function autoScaleLogo(mesh, group) {
        var box = new THREE.Box3().setFromObject(mesh);
        var size = box.getSize(new THREE.Vector3()).length();
        var center = box.getCenter(new THREE.Vector3());
        mesh.position.sub(center);
        var s = 2.5 / size;
        mesh.scale.set(s, s, s);
        group.add(mesh);
        if (window.log) log('3D_LOGO: INJECTED');
    }
})();
</script>
<script type="module">
// --- AUDIO ROTATION SYSTEM ---
const V_PLAYLIST = {
    tracks: [],
    index: 0,
    player: document.getElementById('audio-el')
};

// Connect your file input to the handler
document.getElementById('file-audio').addEventListener('change', function(e) {
    handleAudioPlaylist(e.target.files);
});

// Auto-advance when song ends
V_PLAYLIST.player.addEventListener('ended', () => {
    if (V_PLAYLIST.tracks.length > 0) {
        V_PLAYLIST.index = (V_PLAYLIST.index + 1) % V_PLAYLIST.tracks.length;
        runVanguardTrack();
    }
});

function handleAudioPlaylist(files) {
    // DO NOT reset V_PLAYLIST.tracks = [] here
    const isFirstLoad = V_PLAYLIST.tracks.length === 0;

    Array.from(files).forEach(f => {
        if (f.type.startsWith('audio/')) {
            // APPEND to the existing array
            V_PLAYLIST.tracks.push(URL.createObjectURL(f));
        }
    });

    if (V_PLAYLIST.tracks.length > 0) {
        log(`QUEUE_UPDATE: ${V_PLAYLIST.tracks.length} TOTAL_TRACKS`);
        
        // Only trigger the player if nothing is playing yet
        if (isFirstLoad) {
            V_PLAYLIST.index = 0;
            runVanguardTrack();
        }
    }
}

function runVanguardTrack() {
    const url = V_PLAYLIST.tracks[V_PLAYLIST.index];
    V_PLAYLIST.player.src = url;
    V_PLAYLIST.player.play();
    
    // UPDATED: Target the audio module label instead of the bottom ticker
    const trackID = `TRACK_0${V_PLAYLIST.index + 1}`;
    const audioLabel = document.querySelector('.audio-engine .module-header') || $('audio-status');
    
    if (audioLabel) {
        audioLabel.textContent = `AUDIO_ENGINE // ${trackID}`;
    }
    
    log(`AUDIO_SYNC: ${trackID}_STARTED`);
}


// --- INTEGRATED AUDIO DUCKING & UI CONTROLS ---

// 1. SIMPLEST HIDE BUTTON
if ($('btn-3d-x')) {
    $('btn-3d-x').onclick = () => {
        // Dispose mesh geometry+material
        if (APP.hologram && APP.hologram.mesh && APP.hologram.scene) {
            APP.hologram.scene.remove(APP.hologram.mesh);
            APP.hologram.mesh.traverse(function(c) {
                if (c.isMesh) {
                    if (c.geometry) c.geometry.dispose();
                    if (c.material) c.material.dispose();
                }
            });
            APP.hologram.mesh = null;
        }
        // Dispose renderer (releases WebGL context)
        if (APP.hologram && APP.hologram.renderer) {
            APP.hologram.renderer.dispose();
            APP.hologram.renderer = null;
        }
        // Clear scene/camera so next load creates fresh
        if (APP.hologram) {
            APP.hologram.scene = null;
            APP.hologram.camera = null;
        }
        // Hide widget-layer (keep canvas element intact for re-use)
        var layer = $('widget-layer');
        if (layer) layer.style.display = 'none';
        // Update Trinity state
        APP.trinity.holo.visible = false;
        log('SYSTEM: 3D_DISPOSED');
    };
}

// 2. MASTER DUCKING FUNCTION
const applyAudioDuck = (isActive) => {
    // Priority: Ducking Gain Node -> Master Gain Node
    const gainNode = (APP.audio && APP.audio.duckingGain) ? APP.audio.duckingGain : (APP.audio && APP.audio.masterGain ? APP.audio.masterGain : null);
    
    if (gainNode) {
        const now = APP.audio.ctx ? APP.audio.ctx.currentTime : 0;
        const targetValue = isActive ? 0.25 : 1.0; // -12dB dip for broadcast
        
        // Professional fade (50ms) to avoid "pops" in the 15Mbps recording
        gainNode.gain.setTargetAtTime(targetValue, now, 0.05);
        console.log(isActive ? "CORE: BROADCAST_DUCKING_ON" : "CORE: BROADCAST_DUCKING_OFF");
    }
    if (typeof log === 'function') log(isActive ? 'DUCKING: ACTIVE [-12dB]' : 'DUCKING: RESTORED [0dB]');
};

// 1. FORCE INJECT COLORS
const style = document.createElement('style');
style.innerHTML = `
  .tick-up { color: #00ff00 !important; font-weight: bold; text-shadow: 0 0 5px #00ff00; }
  .tick-down { color: #ff0000 !important; font-weight: bold; text-shadow: 0 0 5px #ff0000; }
`;
document.head.appendChild(style);

// 2. FORCE REFRESH TICKER WITH COLORS
async function updateTickerLive() {
    try {
        const res = await fetch('https://api.binance.com/api/v3/ticker/24hr?symbol=BTCUSDT');
        const data = await res.json();
        const price = parseFloat(data.lastPrice).toFixed(2);
        const change = parseFloat(data.priceChangePercent);
        const colorClass = change >= 0 ? 'tick-up' : 'tick-down';
        const arrow = change >= 0 ? '▲' : '▼';

        const ticker = document.getElementById('ticker-text');
        if (ticker) {
            ticker.innerHTML = `BTC: $${price} <span class="${colorClass}">(${arrow}${change}%)</span> // [SIGNAL_STABLE]`;
        }
    } catch (e) {
        console.error("Ticker update failed", e);
    }
}

// Initial triggers
updateTickerLive();
setInterval(updateTickerLive, 600000); // 10 minute poll to save CPU

//  EVENT INTERCEPTOR (Priority Phase)
document.addEventListener('click', (e) => {
    const btn = e.target.closest('button');
    if (!btn) return;
    
    const id = btn.id;
    if (id === 'btn-go-live') applyAudioDuck(true);
    if (id === 'btn-end' || id === 'btn-end-live' || id === 'btn-kill') applyAudioDuck(false);
}, true);

// --- TACTICAL FX GLOBAL BRIDGE ---
// --- TACTICAL FX MASTER BRIDGE (v4.0 PERSISTENT) ---
window.toggleFX = function(fxName) {
    const target = document.body;
    const className = `fx-${fxName}`;
    const allFX = ['fx-scan', 'fx-tear', 'fx-bloom', 'fx-chroma', 'fx-punch'];
    
    // Find the specific button to "light it up"
    const btn = Array.from(document.querySelectorAll('.btn')).find(b => 
        b.getAttribute('onclick')?.includes(`'${fxName}'`)
    );

    if (target.classList.contains(className)) {
        // TURN OFF
        target.classList.remove(className);
        if (btn) btn.classList.remove('active-fx');
        console.log(`FX_OFF: ${fxName}`);
    } else {
        // TURN ON (Clears existing tactical FX first for a clean state)
        target.classList.remove(...allFX);
        document.querySelectorAll('.btn').forEach(b => b.classList.remove('active-fx'));
        
        target.classList.add(className);
        if (btn) btn.classList.add('active-fx');
        console.log(`FX_ON: ${fxName}`);
    }
};

window.triggerHardReset = function() {
    console.log("SYSTEM_EVENT: HARD_RESET");
    const target = document.body;
    const allFX = ['fx-scan', 'fx-tear', 'fx-bloom', 'fx-chroma', 'fx-punch'];
    
    // 1. Wipe all classes and button lights
    target.classList.remove(...allFX);
    document.querySelectorAll('.btn').forEach(b => b.classList.remove('active-fx'));
    
    // 2. Trigger CRT Collapse
    target.classList.remove('anim-hard-reset');
    void target.offsetWidth; 
    target.classList.add('anim-hard-reset');
    
    // 3. Clean up animation class after 600ms
    setTimeout(() => target.classList.remove('anim-hard-reset'), 600);

    if (typeof ghostLog === 'function') {
        ghostLog('SYSTEM_HARD_RESET_EXECUTED', 'crit');
    }
};</script>
</body>
</html> 
