<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
   <title>DRIS//CORE VNGRD</title>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script src="https://cdn.ethers.io/lib/ethers-5.7.umd.min.js"></script>
<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
<script src="src/Compositor.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800;900&family=JetBrains+Mono:wght@300;400;500&family=Bebas+Neue&family=Russo+One&display=swap');
        
        :root { 
            --accent: #00f3ff; --accent-dim: rgba(0, 243, 255, 0.2); --accent-glow: rgba(0, 243, 255, 0.5);
            --p: #ff0055; --c: #00f3ff; --g: #00ff88; --y: #ffcc00; --r: #ff3333; --o: #ff9d00; --v: #b000ff;
            --bg: #050508; --panel: #08080c; --panel-light: #0c0c12; --border: #151520; --border-light: #202030;
            --text: #a0a0a8; --text-dim: #505058; --text-bright: #e8e8ec;
        }
        
        body.theme-magenta { --accent: #ff0055; --accent-dim: rgba(255,0,85,0.2); --accent-glow: rgba(255,0,85,0.5); }
        body.theme-green { --accent: #00ff88; --accent-dim: rgba(0,255,136,0.2); --accent-glow: rgba(0,255,136,0.5); }
        body.theme-purple { --accent: #b000ff; --accent-dim: rgba(176,0,255,0.2); --accent-glow: rgba(176,0,255,0.5); }
        body.theme-gold { --accent: #ffd700; --accent-dim: rgba(255,215,0,0.2); --accent-glow: rgba(255,215,0,0.5); }
        body.theme-night { --accent: #334455; --accent-dim: rgba(51,68,85,0.2); --bg: #020204; --panel: #040408; }

        /* --- WEB DNA KILL SWITCH --- */
        * { 
            box-sizing: border-box; margin: 0; padding: 0; 
            -webkit-user-select: none;
            user-select: none;
            -webkit-user-drag: none;
        }
        
        /* CURSOR: NORMAL BY DEFAULT */
        body { cursor: default; }
        .btn, button { cursor: pointer; }
        input[type="range"] { cursor: ew-resize; }
        input[type="text"] { cursor: text; }
        
        /* CURSOR: CROSSHAIR ONLY IN SHOOTING MODE */
        body.shooting-mode { cursor: crosshair; }
        body.shooting-mode #stage { cursor: crosshair !important; }
        body.shooting-mode .sidebar { cursor: default; }
        body.shooting-mode .sidebar .btn { cursor: pointer; }

        /* GPU PROMOTION - THE ENGINE CORE */
        #widget-layer, #sys-log, #stage, .sidebar {
            will-change: transform;
            backface-visibility: hidden;
            transform: translate3d(0,0,0);
        }
        
        /* OPTIMIZED DRAGGING - NO TRANSITION DURING DRAG */
        .dragging {
            transition: none !important;
            pointer-events: auto !important;
        }
        
        /* Hide helper class */
        .hidden { display: none !important; }
        
        /* Hide Scrollbars Globally */
        ::-webkit-scrollbar { display: none; }
        html, body { 
            scrollbar-width: none; 
            -ms-overflow-style: none; 
            overflow: hidden; 
            height: 100vh; width: 100vw; 
            background: var(--bg); color: var(--text); 
            font-family: 'JetBrains Mono', monospace; 
            font-size: 12px; 
            overscroll-behavior: none; 
            touch-action: none; 
            transition: background 0.1s linear; 
        }

        input, textarea { 
            user-select: text; 
            cursor: text !important; 
        }

        /* SYSTEM FAILURE MODE (REPLACES PSYCHOSIS STROBE) */
        body.system-failure {
            animation: system-failure-anim 4s infinite linear;
            background: #000 !important;
        }
        body.system-failure .sidebar, body.system-failure #top-bar, body.system-failure #bottom-bar {
            border-color: var(--r) !important;
        }
        body.system-failure * {
            color: var(--r) !important;
            text-shadow: 2px 0 var(--c), -2px 0 var(--y);
        }
        @keyframes system-failure-anim {
            0% { transform: skewX(0deg) scale(1); filter: hue-rotate(0deg); }
            20% { transform: skewX(2deg) scale(1.02); filter: hue-rotate(90deg) contrast(1.5); }
            40% { transform: skewX(-2deg) scale(0.98); filter: hue-rotate(180deg) invert(0.1); }
            60% { transform: skewX(1deg); filter: hue-rotate(270deg) blur(2px); }
            80% { transform: skewX(-1deg); filter: hue-rotate(300deg); }
            100% { transform: skewX(0deg) scale(1); filter: hue-rotate(360deg); }
        }

        /* PARTY MODE CONSOLE GLOW - RESTORED LIGHT PLAY */
        body.party-active .sidebar, body.party-active header, body.party-active footer {
            animation: console-breathe 0.5s infinite alternate;
        }
        @keyframes console-breathe {
            0% { border-color: var(--c); box-shadow: inset 0 0 5px rgba(0, 243, 255, 0.1); }
            100% { border-color: var(--v); box-shadow: inset 0 0 15px rgba(176, 0, 255, 0.2); }
        }

        /* NEW LOGO ANIMATIONS */
        .logo { font-family: 'Orbitron', sans-serif; font-size: 36px; font-weight: 900; letter-spacing: -2px; color: #fff; transition: all 0.05s ease; }
        .logo:hover { transform: scale(1.02); filter: brightness(1.1); text-shadow: 4px 4px 0px var(--accent-dim); }
        
        #main-logo span { animation: core-flicker 4s infinite; display:inline-block; }
        @keyframes core-flicker { 
            0%, 90% { opacity: 0.6; color: var(--accent); transform: skewX(0deg); }
            92% { opacity: 1; color: #fff; transform: skewX(-20deg); }
            94% { opacity: 0.6; color: var(--accent); transform: skewX(0deg); }
            96% { opacity: 0; }
            98% { opacity: 1; color: var(--r); }
            100% { opacity: 0.6; color: var(--accent); }
        }

        .logo.m1 { color: #00f3ff; text-shadow: 0 0 20px #00f3ff; animation: pulse-glow 2s infinite; }
        .logo.m2 { color: #ff0055; text-shadow: 2px 2px 0px #fff; animation: glitch-text 0.3s infinite; }
        .logo.m3 { background: linear-gradient(90deg, #00f3ff, #ff0055, #00ff88); -webkit-background-clip: text; color: transparent; animation: gradient-slide 3s linear infinite; }
        .logo.m4 { color: transparent; -webkit-text-stroke: 1px #fff; animation: hollow-pulse 1s infinite alternate; }
        .logo.m5 { color: #fff; text-shadow: 2px 0 #f00, -2px 0 #0ff; animation: chromatic-shake 0.2s infinite; }
        .logo.m6 { background: linear-gradient(180deg, #fff, #555); -webkit-background-clip: text; color: transparent; opacity: 0.8; }

        @keyframes pulse-glow { 0%,100% { opacity: 1; filter: drop-shadow(0 0 5px var(--accent)); } 50% { opacity: 0.8; filter: drop-shadow(0 0 15px var(--accent)); } }
        @keyframes glitch-text { 0% { transform: translate(0,0); } 20% { transform: translate(-2px, 2px); } 40% { transform: translate(-2px, -2px); } 60% { transform: translate(2px, 2px); } 80% { transform: translate(2px, -2px); } 100% { transform: translate(0,0); } }
        @keyframes gradient-slide { 0% { background-position: 0% 50%; background-size: 200% 200%; } 100% { background-position: 100% 50%; background-size: 200% 200%; } }
        @keyframes hollow-pulse { from { stroke-opacity: 1; } to { stroke-opacity: 0.3; } }
        @keyframes chromatic-shake { 0% { transform: translate(1px, 0); } 50% { transform: translate(-1px, 0); } 100% { transform: translate(1px, 0); } }

        .sub-tag { font-size: 11px; letter-spacing: 3px; color: var(--accent); margin-left: 10px; opacity: 0.7; position: relative; display: inline-block; overflow: hidden; }
        .sub-tag::after { content: ''; position: absolute; top: 0; left: -100%; width: 50%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent); animation: vngrd-shine 8s ease-in-out infinite; }
        @keyframes vngrd-shine { 0%, 85%, 100% { left: -100%; opacity: 0; } 90%, 95% { opacity: 1; } 92% { left: 150%; } }
        .version { font-size: 10px; color: var(--accent); padding: 3px 8px; background: var(--accent-dim); border: 1px solid var(--accent); margin-left: 10px; }

        #stage { position: fixed; top: 45px; left: 200px; right: 200px; bottom: 55px; background: #000; border: 1px solid var(--border); overflow: hidden; }
        #vj-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1000; }
        #overlay-layer { position: absolute; inset: 0; z-index: 2000; pointer-events: none; }
        
        #stage::before { content: ""; position: absolute; inset: 0; z-index: 3000; pointer-events: none; background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.03) 2px, rgba(0,0,0,0.03) 4px); opacity: 0.3; }
        #stage::after { content: ""; position: absolute; inset: 0; z-index: 3001; pointer-events: none; background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.5) 100%); }

        body.fullscreen #stage { position: fixed; inset: 0; z-index: 9999; border: none; }
        body.fullscreen .sidebar, body.fullscreen #top-bar, body.fullscreen #bottom-bar, body.fullscreen #ghost-terminal { opacity: 0; pointer-events: none; }

        #lower-third { position: absolute; bottom: 60px; left: 30px; z-index: 4000; pointer-events: none; }
        .lt-container { 
            display: flex; flex-direction: column; 
            background: linear-gradient(90deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.7) 100%);
            border-left: 3px solid var(--accent); 
            padding: 12px 25px 12px 15px; 
            min-width: 280px; max-width: 400px;
            opacity: 0; transform: translateX(-20px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #lower-third.visible .lt-container { opacity: 1; transform: translateX(0); }
        .lt-title { font-family: 'Orbitron', sans-serif; font-size: 20px; font-weight: 700; color: #fff; letter-spacing: 1px; line-height: 1.2; }
        .lt-subtitle { font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; margin-top: 2px; }
        .lt-container.lt-guest { border-color: var(--c); }
        .lt-container.lt-guest .lt-subtitle { color: var(--c); }
        .lt-container.lt-track { border-color: var(--g); }
        .lt-container.lt-track .lt-subtitle { color: var(--g); }
        .lt-container.lt-breaking { border-color: var(--r); animation: lt-pulse 1s infinite; }
        .lt-container.lt-breaking .lt-subtitle { color: var(--r); }
        @keyframes lt-pulse { 0%, 100% { border-color: var(--r); } 50% { border-color: #fff; } }

        /* ========================================
           TRIPLE-STACK IDENTITY - HEADER BRAND
           ======================================== */
        #brand {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Brand Logo Slot (uploaded image) */
        #brand-logo-slot {
            max-height: 32px;
            max-width: 60px;
            object-fit: contain;
            filter: drop-shadow(0 0 8px var(--accent));
            display: none;
        }
        #brand-logo-slot.active {
            display: block;
        }
        
        /* Main Logo Text - mix-blend-mode: exclusion by default */
        #main-logo {
            mix-blend-mode: exclusion;
        }
        #main-logo.hidden { display: none; }
        
        /* Text Style Modes */
        #main-logo.style-solid {
            mix-blend-mode: normal;
            color: #fff;
            text-shadow: 0 0 15px var(--accent);
        }
        #main-logo.style-hollow {
            mix-blend-mode: normal;
            color: transparent;
            -webkit-text-stroke: 1px var(--accent);
            text-shadow: none;
        }
        #main-logo.style-inverted {
            mix-blend-mode: exclusion;
            color: #fff;
            text-shadow: none;
        }
        
        /* V29 MANUAL LAYER ELEMENTS */
       /* --- V29 INDUSTRIAL OVERRIDE (NO GLOW) --- */
 #station-bug { 
            position: absolute; top: 30px; left: 30px; z-index: 2600; 
            font-family: 'Orbitron', sans-serif; font-size: 28px; font-weight: 800; 
            
            /* CLEANUP: White text with a subtle dark lift, NO BLUE GLOW */
            color: rgba(255,255,255,0.9); 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5); 
            
            background: transparent !important; 
            border: none !important; 
            backdrop-filter: none !important;
            cursor: move;
            pointer-events: auto !important;
        }
        #station-bug.hidden { opacity: 0; pointer-events: none; }
        #station-bug img { max-height: 60px; filter: drop-shadow(0 0 10px var(--accent)); }
        
      #user-logo-layer { 
    /* POSITION & SCALE */
    position: absolute; 
    top: 30px; 
    right: 30px; 
    z-index: 2550; 
    max-width: 150px; 
    max-height: 100px; 
    object-fit: contain; 
    transform-origin: top right;
    display: none;
    cursor: move;
    pointer-events: auto !important;

    /* SURGICAL CLEANUP: NO GLOW, NO BOX */
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;

    /* REPLACED: Professional depth instead of blue neon */
    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.8)) !important;
}
        
        /* HOLOGRAM WIDGET - REACTOR CORE */
       #widget-layer {
    position: absolute;
    width: 150px;
    height: 150px;
    background: transparent !important; /* Forces background to stay clear */
    border: none !important;            /* Removes the 1px solid border */
    z-index: 2600;
    pointer-events: auto !important;
    display: block;
    opacity: 1;
}

#hologram-canvas {
    width: 100% !important;
    height: 100% !important;
    background: transparent !important; /* Ensures the canvas itself has no color */
    border: none !important;           /* Removes the dashed/solid lines */
    box-shadow: none !important;       /* Removes the glow until a model is loaded */
    display: block;
}

/* STRUCTURAL INTEGRITY BAR (FLAT) */
#integrity-bar {
    position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
    width: 200px; height: 6px;
    background: #111; /* Solid dark background */
    border: 1px solid var(--border-light);
    z-index: 99998; display: none;
    box-shadow: none !important;
}

#integrity-fill {
    height: 100%; width: 100%;
    /* Solid colors feel more industrial than soft gradients */
    background: var(--g); 
    transition: width 0.1s;
}

#integrity-text {
    position: absolute; top: -16px; left: 50%; transform: translateX(-50%);
    font-size: 9px; 
    color: var(--text-bright); 
    text-shadow: none !important; /* GLOW REMOVED */
    font-family: 'Orbitron', sans-serif;
}
        
        /* LENS FAILURE STATE */
        body.lens-shattered #stage { backdrop-filter: none !important; filter: none !important; }
        body.lens-shattered .glass-fracture { animation: fracture-fall 1s forwards; }
        @keyframes fracture-fall {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(120vh) rotate(720deg); opacity: 0; }
        }
        
        /* CAMERA PREVIEW BOX - INLINE SIDEBAR */
        #cam-preview-float {
            position: relative;
            width: 100%;
            aspect-ratio: 16 / 9;
            background: #000;
            border: 1px solid var(--border);
            border-radius: 2px;
            display: none;
            overflow: hidden;
            margin: 6px 0;
        }
        #cam-preview-float.active { display: block; border-color: var(--accent); }
        #cam-preview-float video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            display: block;
        }
        #cam-preview-float .preview-label {
            position: absolute;
            top: 3px;
            left: 3px;
            font-size: 7px;
            color: var(--accent);
            background: rgba(0,0,0,0.7);
            padding: 1px 5px;
            border-left: 1px solid var(--accent);
            letter-spacing: 1.5px;
            font-family: 'Orbitron', sans-serif;
        }
        #cam-preview-float .rec-indicator {
            position: absolute;
            top: 3px;
            right: 3px;
            width: 6px;
            height: 6px;
            background: var(--r);
            border-radius: 50%;
            display: none;
            animation: rec-blink 1s infinite;
        }
        #cam-preview-float .rec-indicator.on { display: block; }
        
        /* AUTO-INVERT FOR TV LEGIBILITY */
        #station-bug {
            mix-blend-mode: difference;
            color: #ffffff !important;
            background: transparent !important;
        }
        #ticker-text {
            mix-blend-mode: difference;
        }
        
        /* MIDI LEARN MODE */
        body.midi-learn-active .btn,
        body.midi-learn-active input[type="range"] {
            animation: midi-learn-pulse 0.5s infinite alternate;
        }
        @keyframes midi-learn-pulse {
            0% { box-shadow: 0 0 5px var(--v); }
            100% { box-shadow: 0 0 20px var(--v), inset 0 0 10px rgba(176,0,255,0.2); }
        }
        .midi-bound {
            position: relative;
        }
        .midi-bound::after {
            content: 'M';
            position: absolute;
            top: -4px;
            right: -4px;
            width: 12px;
            height: 12px;
            background: var(--v);
            color: #fff;
            font-size: 7px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 2px;
            z-index: 10;
        }
        
        /* WEBGL LENS DRIP SHADER LAYER */
        #lens-drip-canvas {
            position: absolute;
            inset: 0;
            z-index: 2450;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #lens-drip-canvas.active { opacity: 1; }
        
        /* HEAT HAZE DISTORTION */
        #heat-haze-canvas {
            position: absolute;
            inset: 0;
            z-index: 2451;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #heat-haze-canvas.active { opacity: 1; }
        
        /* REFRACTIVE GLASS SHARDS - WebGL */
        .glass-shard-webgl {
            position: absolute;
            pointer-events: none;
            backdrop-filter: blur(2px) brightness(1.2);
            -webkit-backdrop-filter: blur(2px) brightness(1.2);
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 50%, rgba(255,255,255,0.05) 100%);
            border: 1px solid rgba(255,255,255,0.3);
            mix-blend-mode: overlay;
        }
        
        /* DEPTH HOLES - Physical Console Punctures */
        .bullet-hole-depth {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, #000 0%, #111 40%, #222 70%, transparent 100%);
            box-shadow: inset 3px 3px 8px rgba(0,0,0,0.9), 
                        inset -1px -1px 4px rgba(50,50,50,0.5),
                        0 0 10px rgba(0,0,0,0.5);
            pointer-events: none;
        }

        #ghost-terminal {
            position: fixed; bottom: 70px; right: 210px;
            width: 320px; height: 220px;
            background: rgba(0,5,8,0.95);
            border: 1px solid var(--c);
            z-index: 6000; font-family: 'JetBrains Mono', monospace; font-size: 10px;
            display: none; flex-direction: column;
            box-shadow: 0 0 20px var(--accent-dim);
        }
        #ghost-terminal.active { display: flex; }
        #ghost-terminal-header { display: flex; justify-content: space-between; align-items: center; padding: 6px 10px; background: var(--accent-dim); border-bottom: 1px solid var(--border); }
        #ghost-terminal-title { font-family: 'Orbitron', sans-serif; font-size: 9px; letter-spacing: 2px; color: var(--c); }
        #ghost-terminal-status { font-size: 8px; color: var(--g); }
        #ghost-terminal-body { flex: 1; padding: 8px; overflow-y: auto; scrollbar-width: none; }
        .ghost-log { margin-bottom: 3px; line-height: 1.3; font-size: 9px; }
        .ghost-log .ts { color: var(--text-dim); margin-right: 4px; font-size: 8px; }
        .ghost-log .ai { color: var(--accent); }
        .ghost-log .user { color: #fff; }
        .ghost-log .crit { color: var(--r); }
        .ghost-log .success { color: var(--g); }
        #ghost-input-line { display: flex; border-top: 1px solid var(--border); padding: 6px 8px; }
        #ghost-prompt { color: var(--accent); margin-right: 6px; font-size: 9px; }
        #ghost-input { background: transparent; border: none; color: #fff; flex: 1; font-family: 'JetBrains Mono', monospace; font-size: 10px; outline: none; }

        #top-bar { position: fixed; top: 0; left: 0; right: 0; height: 45px; background: linear-gradient(180deg, var(--panel-light) 0%, var(--panel) 100%); border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; padding: 0 15px; z-index: 5000; }
        #brand { display: flex; align-items: center; }
        #status-bar { display: flex; align-items: center; gap: 15px; }
        .stat { display: flex; align-items: center; gap: 5px; font-size: 10px; }
        .dot { width: 7px; height: 7px; border-radius: 50%; background: var(--g); box-shadow: 0 0 6px var(--g); }
        .dot.live { background: var(--r); box-shadow: 0 0 8px var(--r); animation: dot-pulse 0.5s infinite; }
        @keyframes dot-pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }
        #clock { font-family: 'Orbitron', sans-serif; font-size: 16px; color: var(--accent); letter-spacing: 2px; }
        #tally { display: none; padding: 4px 12px; background: var(--r); color: #fff; font-size: 10px; font-weight: bold; letter-spacing: 2px; animation: tally-blink 1s infinite; }
        @keyframes tally-blink { 0%,100% { opacity: 1; } 50% { opacity: 0.6; } }
        /* NEW RECORDING INDICATOR IN HEADER */
        #rec-status { display: none; padding: 4px 12px; background: var(--r); color: #fff; font-size: 10px; font-weight: bold; letter-spacing: 2px; animation: rec-header-blink 1s infinite; border-radius: 2px; }
        @keyframes rec-header-blink { 0%,100% { opacity: 1; box-shadow: 0 0 10px var(--r); } 50% { opacity: 0.3; box-shadow: none; } }
        
        .badge { display: flex; align-items: center; gap: 5px; padding: 3px 8px; border: 1px solid; font-size: 9px; transition: all 0.2s; }
        .badge:hover { box-shadow: 0 0 10px currentColor; }
        #fps-badge { border-color: var(--g); color: var(--g); background: rgba(0,255,136,0.05); }
        #cycle-badge { border-color: var(--y); color: var(--y); background: rgba(255,204,0,0.05); display: none; }
        #cycle-badge.on { display: flex; }

        .sidebar { position: fixed; top: 45px; bottom: 55px; width: 200px; background: var(--panel); border: 1px solid var(--border); overflow-y: auto; z-index: 4000; scrollbar-width: none; transition: border-color 0.4s ease, box-shadow 0.4s ease; }
        #left-panel { left: 0; border-left: none; border-right: 1px solid rgba(0, 243, 255, 0.1); }
        #right-panel { right: 0; border-right: none; border-left: 1px solid rgba(0, 243, 255, 0.1); }
        .section { border-bottom: 1px solid var(--border); }
        /* SCANNING ANIMATION FOR CYCLE MODE */
        .sec-head { display: flex; align-items: center; justify-content: space-between; padding: 8px 12px; background: rgba(0,0,0,0.3); border-bottom: 1px solid var(--border); position: relative; overflow: hidden; }
        .sec-head.scanning::after {
            content: ''; position: absolute; bottom: 0; left: -100%; width: 50%; height: 2px; background: var(--y);
            box-shadow: 0 0 10px var(--y); animation: scan-line 2s linear infinite;
        }
        @keyframes scan-line { 0% { left: -50%; } 100% { left: 150%; } }

        .sec-title { font-family: 'Orbitron', sans-serif; font-size: 9px; font-weight: 600; letter-spacing: 2px; color: var(--accent); }
        .sec-dot { width: 5px; height: 5px; background: var(--g); border-radius: 50%; box-shadow: 0 0 4px var(--g); }
        .sec-dot.off { background: var(--text-dim); box-shadow: none; }
        .sec-dot.gold { background: var(--y); box-shadow: 0 0 6px var(--y); }
        .sec-body { padding: 10px 12px; }
        
        /* VNGRD BUTTONS - DIGITAL SNAP */
        .btn { display: block; width: 100%; padding: 8px 10px; margin-bottom: 6px; background: linear-gradient(180deg, #0f0f14 0%, #0a0a0e 100%); border: 1px solid var(--border); color: var(--text); font-family: 'JetBrains Mono', monospace; font-size: 10px; text-align: left; transition: all 0.05s step-end; }
        .btn:hover { background: linear-gradient(180deg, #151520 0%, #0f0f14 100%); color: var(--text-bright); border-color: var(--border-light); }
        .btn:active { box-shadow: inset 0 2px 10px rgba(0,0,0,0.8); transform: translateY(2px); }
        .btn.on { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 10px var(--accent-dim); }
        .btn.active-mode { 
            background: var(--accent-dim) !important; 
            border-color: var(--accent) !important; 
            color: var(--accent) !important; 
            box-shadow: inset 0 0 15px rgba(0,243,255,0.3), 0 0 5px var(--accent);
            text-shadow: 0 0 8px var(--accent);
            font-weight: bold;
        }

        /* CYCLE TOGGLE GOLD STATE */
        .btn.cycle-active {
            border-color: var(--y) !important; color: var(--y) !important;
            box-shadow: 0 0 10px rgba(255,204,0,0.2);
            animation: cycle-pulse 2s infinite;
        }
        @keyframes cycle-pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.7; } }
        
        #btn-ui-react { animation: party-breathe 2s ease-in-out infinite; }
        #btn-ui-react.on { animation: none; color: #ff00ff; text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff; border-color: #ff00ff; background: rgba(255,0,255,0.1); }
        @keyframes party-breathe { 0%, 100% { color: var(--text); } 50% { color: #ff00ff; text-shadow: 0 0 8px #ff00ff; } }
        
        #btn-rumble { animation: seismic-breathe 2.5s ease-in-out infinite; }
        #btn-rumble.on { animation: none; color: #ff6600; text-shadow: 0 0 10px #ff6600, 0 0 20px #ff3300; border-color: #ff6600; background: rgba(255,102,0,0.1); }
        @keyframes seismic-breathe { 0%, 100% { color: var(--text); } 50% { color: #ff6600; text-shadow: 0 0 6px #ff6600; } }

        #btn-psychosis { border-color: #ff00ff; color: #ff00ff; text-align: center; font-weight: bold; letter-spacing: 1px; }
        #btn-psychosis:hover { background: #ff00ff; color: #000; box-shadow: 0 0 20px #ff00ff; }
        
        .btn.panic { background: #000; border-color: #ff0000; color: #ff0000; text-shadow: 0 0 5px #ff0000; font-weight: bold; text-align: center; }
        .btn.panic:hover { background: #ff0000; color: #000; box-shadow: 0 0 20px #ff0000; }
        .btn.warn { border-color: #ff9900; color: #ff9900; text-align: center; }
        .btn.warn:hover { background: #ff9900; color: #000; }
        .btn.eject { border-color: var(--text-dim); color: var(--text); text-align: center; }
        .btn.eject:hover { border-color: #fff; color: #fff; }
        
        .btn.impact { background: linear-gradient(180deg, #1a1000 0%, #0f0800 100%); border-color: var(--o); color: var(--o); }
        .btn.donate { background: linear-gradient(180deg, #0a1a0a 0%, #051005 100%); border-color: var(--g); color: var(--g); }
        .btn.donate:hover { background: var(--g); color: #000; box-shadow: 0 0 20px var(--g); }
        
        .btn-row { display: flex; gap: 6px; }
        .btn-row .btn { flex: 1; text-align: center; }
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .btn-grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; }
        .btn-grid-3 .btn { text-align: center; font-size: 9px; padding: 6px 4px; }
        
        .audio-ctrl-row { display: flex; gap: 4px; margin-bottom: 6px; }
        .btn-compact { flex: 1; text-align: center; padding: 8px 0; }
        .btn-compact svg { display: block; margin: 0 auto; pointer-events: none; width: 10px; height: 10px; }
        
        .inp { width: 100%; padding: 7px 10px; margin-bottom: 6px; background: #040406; border: 1px solid var(--border); color: var(--text-bright); font-family: 'JetBrains Mono', monospace; font-size: 10px; }
        .inp:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 8px var(--accent-dim); }
        .lbl { font-size: 9px; color: var(--text-dim); letter-spacing: 1px; margin-bottom: 4px; text-transform: uppercase; }
        .slider-wrap { margin-bottom: 10px; }
        .slider-top { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .slider-lbl { font-size: 9px; color: var(--text-dim); }
        .slider-val { font-size: 10px; color: var(--accent); font-family: 'Orbitron', sans-serif; }
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 4px; background: var(--border); border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: var(--accent); border-radius: 2px; box-shadow: 0 0 8px var(--accent-dim); }

        /* Camera preview removed - using full stage instead */

        #audio-box { background: #000; border: 1px solid var(--border); padding: 8px; margin-bottom: 8px; border-radius: 3px; }
        #vu { display: flex; gap: 2px; height: 30px; align-items: flex-end; }
        .vu-bar { flex: 1; background: linear-gradient(to top, var(--g) 0%, var(--y) 60%, var(--r) 90%); min-height: 2px; border-radius: 1px; transition: height 0.05s; }
        #track-info { font-family: 'Orbitron', sans-serif; font-size: 9px; color: var(--y); margin-top: 6px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        .palette-grid { display: flex; gap: 6px; flex-wrap: wrap; }
        .pal { width: 26px; height: 26px; border: 2px solid var(--border); border-radius: 4px; transition: all 0.2s; }
        .pal:hover { transform: scale(1.15); }
        .pal.on { border-color: #fff; box-shadow: 0 0 10px rgba(255,255,255,0.4); }
        .pal[data-t="cyan"] { background: #00f3ff; }
        .pal[data-t="magenta"] { background: #ff0055; }
        .pal[data-t="green"] { background: #00ff88; }
        .pal[data-t="purple"] { background: #b000ff; }
        .pal[data-t="gold"] { background: #ffd700; }
        .pal[data-t="night"] { background: linear-gradient(135deg, #0a1a15, #1a1a2a); border-color: #334455; }

        #bottom-bar { position: fixed; bottom: 0; left: 0; right: 0; height: 55px; background: linear-gradient(0deg, var(--panel-light) 0%, var(--panel) 100%); border-top: 1px solid var(--border); z-index: 5000; display: flex; flex-direction: column; }
        #ticker-wrap { flex: 1; display: flex; align-items: center; background: rgba(0,0,0,0.3); border-bottom: 1px solid var(--border); overflow: hidden; }
        #ticker-label { padding: 0 12px; font-size: 8px; letter-spacing: 2px; color: var(--accent); background: var(--accent-dim); height: 100%; display: flex; align-items: center; border-right: 1px solid var(--border); }
        #ticker-scroll { flex: 1; overflow: hidden; white-space: nowrap; }
        #ticker-text { display: inline-block; padding-left: 100%; animation: scroll-ticker 60s linear infinite; font-size: 10px; display: flex; gap: 30px; }
        @keyframes scroll-ticker { 0% { transform: translateX(0); } 100% { transform: translateX(-100%); } }
        .tick-up { color: var(--g); } .tick-down { color: var(--r); }
        #info-bar { display: flex; align-items: center; justify-content: space-between; padding: 6px 15px; font-size: 9px; }
        .info-group { display: flex; gap: 20px; }
        .info-item { color: var(--text-dim); }
        .info-item span { color: var(--text); }
        .info-item .hl { color: var(--accent); }

        #sys-log { position: fixed; bottom: 55px; right: 200px; width: 220px; height: 45px; background: rgba(0,0,0,0.95); border: 1px solid var(--border); border-bottom: none; font-size: 8px; color: var(--text-dim); overflow-y: auto; padding: 5px; z-index: 4400; }
        .log-line { margin-bottom: 2px; }
        .log-line .ts { color: var(--accent); margin-right: 5px; }

        #countdown { position: absolute; inset: 0; background: rgba(0,0,0,0.95); display: none; align-items: center; justify-content: center; z-index: 5000; }
        #countdown-num { font-family: 'Orbitron', sans-serif; font-size: 140px; font-weight: 900; color: var(--accent); text-shadow: 0 0 60px var(--accent); }
        #nft-hud { position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%); z-index: 9999; background: rgba(0,0,0,0.95); border: 2px solid var(--r); padding: 15px 30px; font-family: 'Orbitron', sans-serif; display: none; text-align: center; }
        #nft-hud.active { display: block; }
        #nft-timer { font-size: 36px; color: var(--r); font-weight: 900; }
        #nft-label { font-size: 10px; color: #fff; margin-top: 5px; letter-spacing: 2px; }
        .nft-bar { width: 200px; height: 4px; background: #333; margin-top: 10px; }
        .nft-fill { height: 100%; background: var(--r); transition: width 0.1s linear; }

        .blur-reveal { position: fixed; inset: 0; backdrop-filter: blur(50px); -webkit-backdrop-filter: blur(50px); z-index: 99999; pointer-events: none; animation: material-reveal 0.5s ease forwards; }
        @keyframes material-reveal { 0% { backdrop-filter: blur(50px); opacity: 1; } 100% { backdrop-filter: blur(0px); opacity: 0; } }

        input[type="file"] { display: none; }
        body.vhs #stage::before { background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.15) 2px, rgba(0,0,0,0.15) 4px); animation: vhs-track 0.1s steps(3) infinite; opacity: 0.6; }
        @keyframes vhs-track { 0% { background-position: 0 0; } 100% { background-position: 0 4px; } }
        body.crt #stage::after { background: radial-gradient(ellipse at center, transparent 30%, rgba(0,0,0,0.6) 100%); }
        
        /* CONSOLE_HARDWARE BUTTON EFFECTS - HIGH-END GLOW AND PULSE */
        .btn {
            transition: all 0.15s ease;
            text-transform: uppercase;
            position: relative;
        }
        .btn:hover {
            box-shadow: 0 0 20px var(--accent), 0 0 40px var(--accent-dim), inset 0 0 10px var(--accent-dim);
            border-color: var(--accent);
            text-shadow: 0 0 10px var(--accent);
            animation: btn-pulse 0.4s ease-in-out infinite;
        }
        @keyframes btn-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }
        .btn.on, .btn.active-mode {
            animation: btn-active-glow 0.8s ease-in-out infinite;
        }
        @keyframes btn-active-glow {
            0%, 100% { box-shadow: 0 0 15px var(--accent); }
            50% { box-shadow: 0 0 30px var(--accent), 0 0 50px var(--accent-dim); }
        }
        
        /* METAL DENT EFFECT - PERMANENT INSET */
        .dented {
            box-shadow: inset 4px 4px 10px rgba(0,0,0,0.8), inset -2px -2px 6px rgba(30,30,30,0.5) !important;
        }
        /* --- V34 FINAL SHOOTING MODE --- */

/* 1. FORCE CROSSHAIR EVERYWHERE */
body.shooting-mode, 
body.shooting-mode * {
    cursor: crosshair !important;
}

/* 2. MAKE CONSOLE "GHOSTLY" BUT VISIBLE */
/* This allows bullets to hit the buttons instead of clicking them */
body.shooting-mode .sidebar .btn, 
body.shooting-mode .sidebar input,
body.shooting-mode .logo-layer {
    pointer-events: none !important; /* IGNORE CLICKS (So you can shoot through) */
    /* NO OPACITY CHANGE - KEEPS IT LOOKING NORMAL */
}

/* 3. THE DISARM BUTTON (MUST WORK) */
body.shooting-mode #btn-shooting {
    pointer-events: auto !important; /* CLICKABLE */
    cursor: cell !important;
    background: var(--r) !important; /* RED ALERT */
    color: #000 !important;
    font-weight: 900 !important;
    box-shadow: 0 0 20px var(--r);
    z-index: 999999;
}
        /* MACHINE_GUN SHOOTING FX */
        #btn-shooting {
            z-index: 9999 !important;
            position: relative;
        }
        .bullet-hole {
            position: fixed;
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 99999;
        }
        .bullet-hole::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle, #000 30%, #333 50%, transparent 70%);
            border-radius: 50%;
            box-shadow: inset 0 0 5px #000, 0 0 3px rgba(0,0,0,0.8);
        }
        .bullet-hole::after {
            content: '';
            position: absolute;
            top: -5px; left: -5px; right: -5px; bottom: -5px;
            background: radial-gradient(circle, transparent 40%, rgba(50,50,50,0.3) 60%, transparent 80%);
            border-radius: 50%;
        }
        .smoke-puff {
            position: fixed;
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 99998;
            background: radial-gradient(circle, rgba(150,150,150,0.6) 0%, rgba(100,100,100,0.3) 40%, transparent 70%);
            border-radius: 50%;
            animation: smoke-rise 1.5s ease-out forwards;
        }
        @keyframes smoke-rise {
            0% { opacity: 1; transform: scale(0.5) translateY(0); }
            100% { opacity: 0; transform: scale(2) translateY(-50px); }
        }
        
        /* GLASS FRACTURE - REFRACTIVE VECTORS WITH LIGHTER COMPOSITE */
        #glass-fracture-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 99997;
            mix-blend-mode: lighter;
        }
        .glass-fracture {
            position: absolute;
            pointer-events: none;
            mix-blend-mode: lighter;
        }
        .glass-fracture svg {
            overflow: visible;
            mix-blend-mode: lighter;
        }
        .fracture-line {
            stroke: rgba(200,220,255,0.9);
            stroke-width: 1.5;
            filter: drop-shadow(0 0 4px rgba(200,220,255,1)) drop-shadow(0 0 8px rgba(150,200,255,0.6));
        }
        .fracture-glow {
            stroke: rgba(255,255,255,0.4);
            stroke-width: 3;
            filter: blur(2px);
        }
        
        #shooting-overlay {
            position: fixed;
            top: 45px; left: 200px; right: 200px; bottom: 55px;
            z-index: 99990;
            pointer-events: none;
            display: none;
        }
        body.shooting-mode #shooting-overlay { display: block; pointer-events: auto; }
        
        /* ========================================
           TRASUDATE ENGINE - LIQUID PHYSICS
           DISPLACEMENT_MAP WARPING ENTIRE UI
           ======================================== */
        #trasudate-layer {
            position: fixed;
            inset: 0;
            z-index: 99000;
            pointer-events: none;
            overflow: hidden;
        }
        #trasudate-canvas {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }
        .trasudate-drop {
            position: absolute;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            background: radial-gradient(ellipse at 30% 20%, 
                rgba(255,255,255,0.5) 0%, 
                rgba(200,220,255,0.25) 30%, 
                rgba(150,180,220,0.15) 60%,
                transparent 100%);
            box-shadow: 
                inset -2px -2px 10px rgba(255,255,255,0.4),
                inset 2px 2px 5px rgba(0,0,0,0.15),
                0 3px 10px rgba(0,0,0,0.3);
            pointer-events: none;
            backdrop-filter: blur(2px) saturate(1.3) brightness(1.1);
            transform-origin: center bottom;
        }
        .trasudate-trail {
            position: absolute;
            width: 4px;
            background: linear-gradient(180deg, rgba(200,220,255,0.4), transparent);
            border-radius: 3px;
            pointer-events: none;
        }
        
        /* DISPLACEMENT WARP ACTIVE STATE */
        body.trasudate-active {
            filter: url(#trasudate-displacement);
        }
        body.trasudate-active .sidebar,
        body.trasudate-active #stage,
        body.trasudate-active #top-bar,
        body.trasudate-active #bottom-bar {
            filter: url(#trasudate-displacement);
        }
        
        /* SATELLITE_ATMOSPHERE_ENGINE */
        #atmos-canvas {
            position: absolute;
            inset: 0;
            z-index: 2500;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #atmos-canvas.active { opacity: 1; }
        
        /* REFRACTION BUFFER FOR DISPLACEMENT */
        #refraction-buffer {
            position: absolute;
            inset: 0;
            z-index: 2400;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #refraction-buffer.active { opacity: 1; }
        
        .rain-drop {
            position: absolute;
            width: 2px;
            background: linear-gradient(180deg, transparent, var(--accent), var(--p));
            pointer-events: none;
            filter: blur(0.5px);
        }
        
        bodyfalse-active #stage {
            animation: heat-shimmer 0.15s infinite;
        }
        @keyframes heat-shimmer {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(1px); }
            75% { transform: translateX(-1px); }
        }
        
        @keyframes voice-flash {
            0% { filter: brightness(2.5); }
            100% { filter: brightness(1); }
        }
        .voice-flash { animation: voice-flash 0.1s ease-out; }
        
        /* SEISMIC SHAKE - BASS AND MIC REACTIVITY */
        @keyframes seismic-shake {
            0%, 100% { transform: translate(0, 0); }
            20% { transform: translate(-3px, 2px); }
            40% { transform: translate(3px, -2px); }
            60% { transform: translate(-2px, 3px); }
            80% { transform: translate(2px, -3px); }
        }
        body.seismic-active { animation: seismic-shake 0.08s infinite; }
        
    /* ═══ MIRROR COCKPIT — MOBILE ═══ */

    /* PORTRAIT LOCK OVERLAY — rotate-to-landscape gate */
    #portrait-lock {
        display: none;
        position: fixed; inset: 0; z-index: 99999;
        background: var(--bg);
        flex-direction: column; align-items: center; justify-content: center;
        gap: 24px;
        text-align: center;
    }
    #portrait-lock .lock-brand {
        font-family: 'Orbitron', sans-serif; font-weight: 900;
        font-size: clamp(28px, 8vw, 48px);
        color: var(--accent);
        text-shadow: 0 0 20px var(--accent-glow), 0 0 60px var(--accent-dim);
        letter-spacing: 0.15em;
    }
    #portrait-lock .lock-icon {
        width: 64px; height: 64px;
        border: 3px solid var(--accent);
        border-radius: 8px;
        position: relative;
        animation: lock-rotate 2s ease-in-out infinite;
    }
    #portrait-lock .lock-icon::after {
        content: ''; position: absolute;
        top: 50%; left: 50%; transform: translate(-50%,-50%);
        width: 0; height: 0;
        border-left: 12px solid var(--accent);
        border-top: 8px solid transparent;
        border-bottom: 8px solid transparent;
    }
    @keyframes lock-rotate {
        0%, 100% { transform: rotate(0deg); }
        25% { transform: rotate(90deg); }
        50% { transform: rotate(90deg); }
        75% { transform: rotate(0deg); }
    }
    #portrait-lock .lock-msg {
        font-family: 'JetBrains Mono', monospace;
        font-size: clamp(11px, 3vw, 15px);
        color: var(--text);
        letter-spacing: 0.2em;
        text-transform: uppercase;
        max-width: 80vw;
        line-height: 1.8;
    }
    #portrait-lock .lock-line {
        width: 40vw; height: 1px;
        background: linear-gradient(90deg, transparent, var(--accent), transparent);
    }

    /* Show overlay ONLY in portrait */
    @media (orientation: portrait) {
        #portrait-lock { display: flex !important; }
        body > *:not(#portrait-lock) { display: none !important; }
    }

    /* LANDSCAPE MOBILE — 1:1 desktop parity (full UI mirrored) */
    /* LANDSCAPE MOBILE — 1:1 desktop mirror, full UI, 0→1 coords intact */
    @media (max-width: 1024px) and (orientation: landscape) {
        html, body { font-size: 10px; }
        .sidebar {
            width: 200px; min-width: 160px;
            overflow-y: auto; overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }
        #stage { flex: 1; min-height: 0; }
        #top-bar { height: 36px; }
        #bottom-bar { height: 40px; }
        #sys-log { max-height: 60px; font-size: 9px; }
        #lower-third { bottom: 40px; left: 15px; }
        .lt-container { min-width: 200px; max-width: 300px; padding: 8px 16px 8px 10px; }
        .lt-title { font-size: 14px; }
        .lt-subtitle { font-size: 9px; }
    }

/* --- KINETIC SHUTTER TRANSITION --- */
.kinetic-shutter {
    animation: shutter-wipe 0.4s cubic-bezier(0.85, 0, 0.15, 1) forwards;
}

@keyframes shutter-wipe {
    0% { 
        clip-path: inset(0 0 0 0);
        transform: scale(1);
        filter: brightness(1) contrast(1);
    }
    45% { 
        clip-path: inset(0 100% 0 0); /* Horizontal wipe */
        transform: scale(1.03);
        filter: brightness(1.4) contrast(1.1);
    }
    50% { 
        clip-path: inset(0 0 0 100%); /* Reset wipe position */
    }
    100% { 
        clip-path: inset(0 0 0 0);
        transform: scale(1);
        filter: brightness(1) contrast(1);
    }
}</style>
</head>
<body oncontextmenu="return false;">
    <!-- PORTRAIT ORIENTATION LOCK -->
    <div id="portrait-lock">
        <div class="lock-brand">VNGRD</div>
        <div class="lock-line"></div>
        <div class="lock-icon"></div>
        <div class="lock-msg">PLEASE ROTATE FOR FULL EXPERIENCE</div>
        <div class="lock-line"></div>
    </div>

    <!-- SHOOTING_OVERLAY -->
    <div id="shooting-overlay"></div>
    
    <!-- TRASUDATE_LAYER - LIQUID PHYSICS -->
    <div id="trasudate-layer">
        <canvas id="trasudate-canvas"></canvas>
    </div>
    
    <svg style="position:absolute;width:0;height:0;">
        <defs>
            <filter id="chromatic-ghost" x="-20%" y="-20%" width="140%" height="140%">
                <feColorMatrix in="SourceGraphic" type="matrix" values="1 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 1 0" result="red"/>
                <feColorMatrix in="SourceGraphic" type="matrix" values="0 0 0 0 0  0 1 0 0 0  0 0 0 0 0  0 0 0 1 0" result="green"/>
                <feColorMatrix in="SourceGraphic" type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 1 0 0  0 0 0 1 0" result="blue"/>
                <feOffset in="red" dx="-15" dy="0" result="red-shift"/>
                <feOffset in="blue" dx="15" dy="0" result="blue-shift"/>
                <feBlend in="red-shift" in2="green" mode="screen" result="rg"/>
                <feBlend in="rg" in2="blue-shift" mode="screen"/>
            </filter>
            <filter id="heat-distort" x="-10%" y="-10%" width="120%" height="120%">
                <feTurbulence type="fractalNoise" baseFrequency="0.02 0.06" numOctaves="2" result="noise">
                    <animate attributeName="seed" from="0" to="100" dur="1s" repeatCount="indefinite"/>
                </feTurbulence>
                <feDisplacementMap in="SourceGraphic" in2="noise" scale="6" xChannelSelector="R" yChannelSelector="G"/>
            </filter>
            <!-- TRASUDATE DISPLACEMENT FILTER - LIQUID MAGNIFICATION -->
            <filter id="trasudate-displacement" x="-5%" y="-5%" width="110%" height="110%">
                <feGaussianBlur in="SourceGraphic" stdDeviation="0.5" result="blur"/>
                <feTurbulence type="fractalNoise" baseFrequency="0.01 0.02" numOctaves="3" seed="0" result="noise">
                    <animate attributeName="seed" from="0" to="50" dur="3s" repeatCount="indefinite"/>
                </feTurbulence>
                <feDisplacementMap in="blur" in2="noise" scale="3" xChannelSelector="R" yChannelSelector="G" result="displaced"/>
                <feComposite in="displaced" in2="SourceGraphic" operator="over"/>
            </filter>
            <!-- LIQUID REFRACTION FILTER -->
            <filter id="liquid-refract" x="-10%" y="-10%" width="120%" height="120%">
                <feGaussianBlur stdDeviation="1.5" result="blur"/>
                <feSpecularLighting result="spec" specularConstant="2" specularExponent="25" lighting-color="#ffffff">
                    <fePointLight x="100" y="50" z="250"/>
                </feSpecularLighting>
                <feComposite in="SourceGraphic" in2="spec" operator="arithmetic" k1="0" k2="1" k3="0.8" k4="0"/>
            </filter>
        </defs>
    </svg>
    
    <!-- STRUCTURAL INTEGRITY BAR -->
    <div id="integrity-bar">
        <div id="integrity-fill"></div>
        <div id="integrity-text">INTEGRITY: 100%</div>
    </div>
    
    <div class="blur-reveal" id="blur-reveal"></div>
    
    <header id="top-bar">
        <div id="brand">
            <!-- TRIPLE-STACK IDENTITY: [Image] [Text] [Controls] -->
            <img id="brand-logo-slot" src="" alt="" style="display:none;">
            <span class="logo m1" id="main-logo">DRIS<span style="font-size:14px;font-weight:400;color:var(--accent);opacity:0.6;margin-left:2px;letter-spacing:1px">//&nbsp;CORE</span></span>
            <span class="sub-tag">VNGRD</span>
            <span class="version">V34</span>
        </div>
        <div id="status-bar">
            <div id="wallet-badge" class="badge" style="cursor:pointer;border-color:var(--o);color:var(--o);"><span class="dot off" id="wallet-dot"></span>WALLET</div>
            <div id="rec-status">REC</div>
            
            <div class="badge" id="fps-badge">FPS: <span id="fps-val">60</span></div>
            <div class="badge" id="cycle-badge">CYCLE</div>
            <div class="stat"><div class="dot" id="main-dot"></div><span id="status-text">STANDBY</span></div>
            <div id="tally">ON_AIR</div>
            <div id="clock">00:00:00</div>
        </div>
    </header>

    <main id="stage">
        <canvas id="vj-canvas"></canvas>
        <canvas id="refraction-buffer"></canvas>
        <canvas id="atmos-canvas"></canvas>
        <!-- WEBGL SHADER LAYERS -->
        <canvas id="lens-drip-canvas"></canvas>
        <canvas id="heat-haze-canvas"></canvas>
        <div id="glass-fracture-layer"></div>
        <div id="overlay-layer">
            <!-- V33 MANUAL LAYER SEPARATION -->
            <div id="station-bug">VNGRD</div>
            <img id="user-logo-layer" src="" alt="Logo">
            <!-- HOLOGRAM WIDGET - REACTOR CORE -->
            <div id="widget-layer">
                <canvas id="hologram-canvas"></canvas>
            </div>
            <div id="lower-third">
                <div class="lt-container lt-guest">
                    <div class="lt-title" id="lt-title-text">GUEST_NAME</div>
                    <div class="lt-subtitle" id="lt-subtitle-text">TITLE_ROLE</div>
                </div>
            </div>
        </div>
        <div id="countdown"><div id="countdown-num">3</div></div>
    </main>
    
    <!-- Camera preview moved inline into sidebar CAMERA_4K section -->

    <div id="ghost-terminal">
        <div id="ghost-terminal-header">
            <span id="ghost-terminal-title">GHOST://COMMAND_INTERFACE</span>
            <span id="ghost-terminal-status">ONLINE</span>
        </div>
        <div id="ghost-terminal-body"></div>
        <div id="ghost-input-line">
            <span id="ghost-prompt">GHOST></span>
            <input type="text" id="ghost-input" placeholder="Awaiting command..." autocomplete="off">
        </div>
    </div>

    <aside class="sidebar" id="left-panel">
        <div class="section">
            <div class="sec-head"><span class="sec-title">CAMERA_4K</span><div class="sec-dot off" id="cam-dot"></div></div>
            <div class="sec-body">
                <button class="btn" id="btn-init-cam">SENSORS ONLINE [4K]</button>
                <div id="cam-preview-float">
                    <video id="preview-vid-float" autoplay muted playsinline></video>
                    <div class="preview-label">PREVIEW</div>
                    <div class="rec-indicator" id="rec-dot-float"></div>
                </div>
                <div id="cam-ctrls" style="display:none">
                    <button class="btn" id="btn-go-live" style="color:var(--y)">GO LIVE [3-2-1]</button>
                    <div class="btn-row">
                        <button class="btn" id="btn-inject">INJECT LOOP (10s)</button>
                        <button class="btn" id="btn-mic">MIC</button>
                    </div>
                </div>
                <div id="live-ctrls" style="display:none">
                    <button class="btn rec" id="btn-rec">REC_BROADCAST</button>
                    <button class="btn" id="btn-end">END LIVE</button>
                </div>
                <button class="btn" id="btn-kill" style="display:none;color:var(--r)">SHUTDOWN CAM</button>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head" id="media-header"><span class="sec-title">MEDIA_DECK</span><div class="sec-dot off" id="media-dot"></div></div>
            <div class="sec-body">
                <button class="btn" id="btn-load-media">LOAD MEDIA</button>
                
                <div class="audio-ctrl-row">
                    <button class="btn btn-compact" id="btn-prev"><svg width="10" height="10" viewBox="0 0 12 12"><path fill="currentColor" d="M2 2h2v8H2zm2 4l6 4V2z"/></svg></button>
                    <button class="btn btn-compact" id="btn-cycle-toggle" style="flex:3; font-size:9px;">CYCLE: OFF</button>
                    <button class="btn btn-compact" id="btn-rotate"><svg width="10" height="10" viewBox="0 0 12 12"><path fill="currentColor" d="M2 10l6-4-6-4v8zm6-8v8h2V2H8z"/></svg></button>
                </div>
                <div class="slider-wrap" id="cycle-slider-wrap" style="display:none;">
                    <div class="slider-top"><span class="slider-lbl">CYCLE TIME</span><span class="slider-val" id="val-cycle">8s</span></div>
                    <input type="range" min="2" max="30" value="8" id="sl-cycle">
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">REACTIVITY</span><div class="sec-dot"></div></div>
            <div class="sec-body">
                <div class="btn-grid-3" style="margin-bottom:6px;">
                    <button class="btn" id="btn-ui-react" style="font-size:8px;">PARTY</button>
                    <button class="btn" id="btn-rumble" style="font-size:8px;">SEISMIC</button>
                    <button class="btn" id="btn-psychosis" style="font-size:8px;">FAILURE</button>
                </div>
                <button class="btn" id="btn-shooting" style="color:var(--r);border-color:var(--r);font-size:9px;">SHOOTING_BASS</button>
            </div>
        </div>

        <div class="section">
            <div class="sec-head"><span class="sec-title">COMMAND</span><div class="sec-dot"></div></div>
            <div class="sec-body">
                <div class="lbl" style="text-align:center;color:var(--r)">EMERGENCY PROTOCOLS</div>
                <div class="btn-grid">
                    <button class="btn eject" id="btn-eject">EJECT</button>
                    <button class="btn warn" id="btn-clear-deck">CLEAR</button>
                </div>
                <button class="btn panic" id="btn-panic">[ESC] PANIC KILL</button>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">MIDI_HOST</span><div class="sec-dot off" id="midi-dot"></div></div>
            <div class="sec-body">
                <button class="btn" id="btn-midi">INIT WEBMIDI</button>
                <button class="btn" id="btn-midi-learn" style="color:var(--v);border-color:var(--v);">LEARN: OFF</button>
                <div id="midi-status" style="font-size:8px;color:var(--text-dim);margin-top:4px;">NO MIDI DEVICE</div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">LOWER_THIRD</span><div class="sec-dot"></div></div>
            <div class="sec-body">
                <input type="text" class="inp" id="lt-title" placeholder="Title..." value="GUEST NAME">
                <input type="text" class="inp" id="lt-sub" placeholder="Subtitle..." value="TITLE / ROLE">
                <div class="btn-grid">
                    <button class="btn" id="btn-lt-guest">GUEST</button>
                    <button class="btn" id="btn-lt-track">TRACK</button>
                    <button class="btn" id="btn-lt-breaking">BREAKING</button>
                    <button class="btn" id="btn-lt-off">OFF</button>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">IDENTITY</span><div class="sec-dot"></div></div>
            <div class="sec-body">
                <!-- STATION BUG -->
                <input type="text" class="inp" id="bug-text" placeholder="STATION_NAME..." value="VNGRD">
                <div class="btn-row">
                    <button class="btn" id="btn-set-station" style="flex:2;">SET BUG</button>
                    <button class="btn" id="btn-bug-toggle" title="Toggle Bug">[X]</button>
                </div>
                <!-- 2D LOGO -->
                <div class="btn-row" style="margin-top:6px;">
                    <button class="btn" id="btn-upload-2d" style="flex:2;">2D LOGO</button>
                    <button class="btn" id="btn-2d-x" title="Hide/Clear 2D">[X]</button>
                </div>
                <input type="file" id="file-2d-logo" accept=".png,.jpg,.jpeg,.gif,.webp" style="display:none;">
                <!-- 3D HOLOGRAM -->
                <div class="btn-row">
                    <button class="btn" id="btn-inject-3d" style="flex:2;color:var(--v);border-color:var(--v);">3D MODEL</button>
                    <button class="btn" id="btn-3d-x" title="HIDE / CLEAR 3D">[X]</button>
                </div>
                <input type="file" id="file-3d-model" accept=".stl,.obj,.glb,.gltf" style="display:none;">

            </div>
        </div>
    </aside>

    <aside class="sidebar" id="right-panel">
        <div class="section">
            <div class="sec-head"><span class="sec-title">AUDIO_ENGINE</span><div class="sec-dot off" id="audio-dot"></div></div>
            <div class="sec-body">
                <div id="audio-box">
                    <div id="vu"></div>
                    <div id="track-info">NO_TRACK</div>
                </div>
                <button class="btn" id="btn-audio">LOAD_AUDIO</button>
                <div class="audio-ctrl-row">
                    <button class="btn btn-compact" id="btn-prev-track"><svg width="10" height="10" viewBox="0 0 12 12"><path fill="currentColor" d="M2 2h2v8H2zm2 4l6 4V2z"/></svg></button>
                    <button class="btn btn-compact" id="btn-play-pause"><svg width="10" height="10" viewBox="0 0 12 12" id="icon-play-state"><path fill="currentColor" d="M3 2v8l7-4z"/></svg></button>
                    <button class="btn btn-compact" id="btn-next-track"><svg width="10" height="10" viewBox="0 0 12 12"><path fill="currentColor" d="M2 10l6-4-6-4v8zm6-8v8h2V2H8z"/></svg></button>
                </div>

                <div class="lbl" style="margin-top:8px;">INPUT_SIGNAL</div>
                <select class="inp" id="audio-input-select" style="width:100%;font-size:9px;padding:5px;background:var(--panel);border:1px solid var(--border);color:var(--text);">
                    <option value="">SELECT_DEVICE...</option>
                </select>
                <button class="btn" id="btn-scan-inputs" style="font-size:8px;margin-top:4px;">SCAN_DEVICES</button>
                <div id="input-level" style="height:3px;background:var(--border);margin-top:4px;">
                    <div id="input-level-bar" style="height:100%;width:0%;background:var(--g);transition:width 0.05s;"></div>
                </div>

                <div class="lbl" style="margin-top:8px;">ENGINEER_MODE</div>
                <div class="btn-grid-3">
                    <button class="btn active-mode" id="btn-stereo">STEREO</button>
                    <button class="btn" id="btn-spatial">3D_SPATIAL</button>
                    <button class="btn" id="btn-dolby" style="color:#00f3ff">DOLBY_DSP</button>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">WEATHER_SYNC</span><div class="sec-dot off" id="atmos-dot"></div></div>
            <div class="sec-body">
                <div id="geo-status" style="font-size:8px;color:var(--text-dim);margin-bottom:4px;">GEO: ACQUIRING...</div>
                <div id="weather-status" style="font-size:9px;color:var(--accent);margin-bottom:4px;">WEATHER: STANDBY</div>
                <div id="weather-fx" style="font-size:7px;color:var(--g);">FX: AUTO (RAIN=DRIP / HOT=HAZE)</div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">IMPACT_FX</span><div class="sec-dot"></div></div>
            <div class="sec-body">
                <div class="btn-grid-3">
                    <button class="btn impact" id="btn-stutter">STUTTER</button>
                    <button class="btn impact" id="btn-invert">INVERT</button>
                    <button class="btn impact" id="btn-crush">CRUSH</button>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">VJ_ENGINE</span><div class="sec-dot"></div></div>
            <div class="sec-body">
                <div class="slider-wrap"><div class="slider-top"><span class="slider-lbl">BRIGHTNESS</span><span class="slider-val" id="val-b">100%</span></div><input type="range" min="30" max="170" value="100" id="sl-b"></div>
                <div class="slider-wrap"><div class="slider-top"><span class="slider-lbl">CONTRAST</span><span class="slider-val" id="val-c">100%</span></div><input type="range" min="30" max="170" value="100" id="sl-c" data-midi-target="contrast"></div>
                <div class="slider-wrap"><div class="slider-top"><span class="slider-lbl">SATURATION</span><span class="slider-val" id="val-s">100%</span></div><input type="range" min="0" max="200" value="100" id="sl-s" data-midi-target="saturation"></div>
                <div class="slider-wrap"><div class="slider-top"><span class="slider-lbl">HUE</span><span class="slider-val" id="val-h">0</span></div><input type="range" min="0" max="360" value="0" id="sl-h" data-midi-target="hue"></div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">CANVAS_FX</span><div class="sec-dot"></div></div>
            <div class="sec-body">
                <div class="btn-row">
                    <button class="btn" id="btn-trails">TRAILS</button>
                    <button class="btn" id="btn-rgb">RGB</button>
                </div>
                <div class="slider-wrap"><div class="slider-top"><span class="slider-lbl">TRAIL α</span><span class="slider-val" id="val-trail">0.92</span></div><input type="range" min="50" max="98" value="92" id="sl-trail"></div>
                <div class="slider-wrap"><div class="slider-top"><span class="slider-lbl">RGB SHIFT</span><span class="slider-val" id="val-rgb">0</span></div><input type="range" min="0" max="30" value="0" id="sl-rgb"></div>
                <div class="btn-row">
                    <button class="btn" id="btn-pixelate">PIXEL</button>
                    <button class="btn" id="btn-mask-mode">MASK MODE</button>
                </div>
                <div class="slider-wrap"><div class="slider-top"><span class="slider-lbl">PIXEL SIZE</span><span class="slider-val" id="val-pix">1</span></div><input type="range" min="1" max="32" value="1" id="sl-pix"></div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">OVERLAYS</span><div class="sec-dot"></div></div>
            <div class="sec-body">
                <div class="btn-grid">
                    <button class="btn" id="btn-vhs">VHS</button>
                    <button class="btn" id="btn-crt">CRT</button>
                    <button class="btn" id="btn-reset">RESET FX</button>
                    <button class="btn" id="btn-fs">[H] FULL</button>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">THEME</span><div class="sec-dot"></div></div>
            <div class="sec-body">
                <div class="palette-grid">
                    <div class="pal on" data-t="cyan"></div>
                    <div class="pal" data-t="magenta"></div>
                    <div class="pal" data-t="green"></div>
                    <div class="pal" data-t="purple"></div>
                    <div class="pal" data-t="gold"></div>
                    <div class="pal" data-t="night"></div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">NFT_FACTORY</span><div class="sec-dot"></div></div>
            <div class="sec-body">
                <button class="btn rec" id="btn-nft-30">REC_30S_NFT</button>
                <button class="btn" id="btn-save-session">SAVE_SESSION</button>
                <button class="btn" id="btn-import-dna">IMPORT_VGD</button>
                <div class="btn-row">
                    <button class="btn" id="btn-projector">PROJECTOR</button>
                    <button class="btn" id="btn-vr" style="color:var(--v)">ENTER_VR</button>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">NFT_VAULT</span><div class="sec-dot off" id="vault-dot"></div></div>
            <div class="sec-body">
                <button class="btn" id="btn-scan-nfts" style="font-size:8px;">SCAN_WALLET_ASSETS</button>
                <div id="nft-vault-list" style="max-height:60px;overflow-y:auto;font-size:8px;color:var(--text-dim);margin-top:4px;">
                    CONNECT_WALLET_FIRST
                </div>
                <div id="nft-count" style="font-size:8px;color:var(--accent);margin-top:4px;">ASSETS: 0</div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">LEXICA_NANO</span><div class="sec-dot off" id="neural-dot"></div></div>
            <div class="sec-body">
                <input type="text" class="inp" id="ai-prompt" placeholder="DESCRIBE_IMAGE..." style="font-size:9px;">
                <button class="btn" id="btn-generate-ai" style="color:var(--v);border-color:var(--v);">LEXICA GENERATE</button>
                <div id="ai-status" style="font-size:8px;color:var(--text-dim);margin-top:4px;">LEXICA_API: READY</div>
            </div>
        </div>
        
        <div class="section">
            <div class="sec-head"><span class="sec-title">P2P_E2E_CALL</span><div class="sec-dot off" id="guest-dot"></div></div>
            <div class="sec-body">
                <div class="lbl" style="font-size:8px;margin-bottom:4px;">YOUR_CALL_ID:</div>
                <input type="text" class="inp" id="peer-id-display" readonly placeholder="CLICK_INIT_TO_GET_ID..." style="font-size:9px;text-align:center;color:var(--g);">
                <button class="btn" id="btn-copy-id" style="font-size:8px;margin-bottom:6px;">COPY_ID</button>
                
                <div class="lbl" style="font-size:8px;margin-bottom:4px;">GUEST_ID_TO_CALL:</div>
                <input type="text" class="inp" id="remote-peer-id" placeholder="PASTE_GUEST_ID..." style="font-size:9px;">
                
                <div class="btn-row" style="margin-top:6px;">
                    <button class="btn" id="btn-init-peer" style="color:var(--g)">INIT</button>
                    <button class="btn" id="btn-call-guest" style="color:var(--c)">CALL</button>
                </div>
                <button class="btn" id="btn-hangup" style="color:var(--r);border-color:var(--r);">END_CALL</button>
                <div id="call-status" style="font-size:8px;color:var(--text-dim);margin-top:4px;text-align:center;">NOT_CONNECTED</div>
            </div>
        </div>
    </aside>

    <footer id="bottom-bar">
        <div id="ticker-wrap">
            <div id="ticker-label">SYS</div>
            <div id="ticker-scroll">
                <div id="ticker-text">INITIALIZING_CRYPTO_STREAM...</div>
            </div>
        </div>
        <div id="info-bar">
            <div class="info-group">
                <div class="info-item">UP: <span id="uptime" class="hl">00:00:00</span></div>
                <div class="info-item">RES: <span id="res">3840x2160</span></div>
                <div class="info-item">Q: <span id="q-info">0</span></div>
            </div>
            <div class="info-group">
                <div class="info-item">AI: <span style="color:var(--g)">[G]_TO_SUMMON</span></div>
            </div>
        </div>
    </footer>

    <div id="sys-log"></div>
    
    <div id="nft-hud">
        <div id="nft-timer">00:00</div>
        <div id="nft-label">NFT_RECORDING</div>
        <div class="nft-bar"><div class="nft-fill" id="nft-fill"></div></div>
    </div>

    <input type="file" id="file-media" multiple accept="image/*,video/*">
    <input type="file" id="file-audio" multiple accept="audio/*">
    <input type="file" id="file-logo" accept="image/*">
    <input type="file" id="file-layer-logo" accept="image/*">
    <input type="file" id="file-vgd" accept=".vgd,.json">
    <audio id="audio-el"></audio>
    <div id="media-container" style="display:none;"></div>

<script>
const $ = id => document.getElementById(id);

// --- BROADCAST SAFE DRAG MODULE ---
function makeLogSafeDraggable(el) {
    let isDragging = false;
    let offset = { x: 0, y: 0 };

    el.addEventListener('mousedown', (e) => {
        if (e.target !== el) return; 
        isDragging = true;
        offset.x = e.clientX - el.offsetLeft;
        offset.y = e.clientY - el.offsetTop;
        el.style.borderColor = 'var(--accent)'; 
        el.style.transition = 'none'; 
    });

    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;

        const marginX = window.innerWidth * 0.10;
        const marginY = window.innerHeight * 0.10;

        let newX = e.clientX - offset.x;
        let newY = e.clientY - offset.y;

        newX = Math.max(marginX, Math.min(newX, window.innerWidth - el.offsetWidth - marginX));
        newY = Math.max(marginY, Math.min(newY, window.innerHeight - el.offsetHeight - marginY));

        el.style.left = newX + 'px';
        el.style.top = newY + 'px';
        el.style.right = 'auto'; 
        el.style.bottom = 'auto';
    });

    document.addEventListener('mouseup', () => {
        isDragging = false;
        el.style.borderColor = 'var(--border)';
        el.style.transition = 'all 0.2s';
    });

    el.ondblclick = () => {
        el.style.left = ''; el.style.top = '';
        el.style.right = '200px'; el.style.bottom = '55px';
    };
}
// --- KILL SWITCH ---
document.addEventListener('keydown', e => {
    if ((e.ctrlKey || e.metaKey) && (e.key === 's' || e.key === 'S')) { e.preventDefault(); console.log('SYS: SAVE_DISABLED'); }
});
document.ondragstart = function() { return false; };

const APP = {
    state: { isLive: false, isRecording: false, isFullscreen: false, isCycle: false, cycleTimer: null, isMobile: false, theme: 'cyan', startTime: Date.now(), psychosis: false },
    vj: { 
        brightness: 1.0, contrast: 1.0, saturation: 1.0, hue: 0, trailsEnabled: false, trailAlpha: 0.92, rgbEnabled: false, rgbIntensity: 0, rgbBassLink: false, pixelateEnabled: false, pixelSize: 1, rumbleEnabled: false, invert: false, uiReactivity: false, shakeIntensity: 0, shockwave: 0, lastBassLevel: 0, avgVol: 0, maskMode: false, glitchSnap: 0,
        seismicVelocity: 0, seismicPosition: 0, springConstant: 0.8, damping: 0.9
    },
    media: { queue: [], currentIndex: -1, currentElement: null },
    audio: { ctx: null, analyzer: null, source: null, element: null, playlist: [], currentTrack: -1, currentTrackName: '', bassLevel: 0, vuData: new Uint8Array(32), isPlaying: false, isConnected: false, spatialMode: 'stereo', panner: null, compressor: null, masterGain: null, lowShelf: null, highShelf: null, spatialInterval: null },
    projector: { window: null, stream: null, isOpen: false },
    nft: { recorder: null, chunks: [], isRecording: false, startTime: 0, duration: 30000, dnaSnapshot: null, audioDest: null },
    broadcast: { recorder: null, chunks: [], isRecording: false },
    loop: { recorder: null, chunks: [], activeUrl: null, timer: null, counter: 10 },
    guest: { peer: null, connection: null, stream: null, videoElement: null, audioSource: null, isActive: false, peerId: null },
    peer: { peer: null, call: null, localStream: null },
    wallet: { connected: false, address: null, chainId: null, nfts: [] },
    camera: { stream: null, recorder: null, chunks: [], mode: 'off', isRecording: false, videoEl: null, previewEl: null, micStream: null },
    render: { canvas: null, ctx: null, width: 3840, height: 2160, fps: 0, frameCount: 0, lastTime: 0, lastFpsUpdate: 0, rafId: null, scale: 1.0, pixelCanvas: null, pixelCtx: null, rgbActive: false },
    bug: { visible: true, text: 'VNGRD', image: null, textMode: 0, textVisible: true, imageVisible: false },
    layers: { logoScale: 1.0, logoSrc: null, bugScale: 1.0 },
    // IDENTITY TRINITY — three independent broadcast actors
    trinity: {
        bug:  { x: 0.015, y: 0.015, scale: 1.5, visible: true },
        logo: { x: 0.85,  y: 0.015, scale: 1.0, visible: false },
        holo: { x: 0.42,  y: 0.75,  scale: 1.0, visible: false }
    },
    lowerThird: { visible: false, preset: 'guest' },
    ui: { logoMorph: 0, morphs: ['m1','m2','m3','m4','m5','m6'] },
    ghost: { seismicEnergy: 0, nodesSecured: 0, directoryHandle: null },
    crypto: { ids: 'bitcoin,ethereum,solana,dogecoin' },
    // WEAPON_STATE_ISOLATION + STRUCTURAL_INTEGRITY
    shooting: { 
        active: false, bullets: [], audioCtx: null, 
        machineGunInterval: null, fractures: [], dents: [],
        lastX: 0, lastY: 0, tinkBuffer: null,
        lastFireTime: 0, fireThrottle: 100,
        repairTimer: null
    },
    glassIntegrity: 100,
    lensShattered: false,
    // MIDI_HOST + LEARN MODE + INSTRUMENT PASSTHROUGH
    midi: {
        access: null, inputs: [], outputs: [],
        learnMode: false, learnTarget: null,
        bindings: {}, // { noteOrCC: { element, target, type } }
        passthrough: false,
        synthCtx: null, synthOsc: null, synthGain: null
    },
    // Phase 1: Compositor (Iron-Clad Recorder Engine)
    compositor: null,
    // Phase 3: Web3 Sovereign DNA
    web3: { provider: null, signer: null, address: null, isConnected: false, mode: 'guest' },
    // Phase 5: Layer Saver
    layerSaver: { textureReady: false, fontReady: false, audioReady: false, allReady: false },
    vr: null,
    // PRO-AUDIO: 48kHz RAW
    inputDevices: { 
        list: [], selectedId: null, stream: null, analyzer: null,
        sampleRate: 48000, echoCancellation: false, noiseSuppression: false, autoGainControl: false
    },
    // TRANSUDATE_ATMOSPHERE_ENGINE
    atmosphere: { 
        voiceReact: false, intensity: 50, heatIntensity: 0,
        rainDrops: [], rainInterval: null,
        canvas: null, ctx: null, temperature: null,
        latitude: null, longitude: null, city: 'UNKNOWN', country: '',
        weatherCode: null, metar: '', isRaining: false,
        refractionCanvas: null, refractionCtx: null,
        midiOverride: false
    },
    // WEBGL SHADERS
    shaders: {
        lensDrip: { active: false, canvas: null, gl: null, program: null, time: 0, rafId: null },
        heatHaze: { active: false, canvas: null, gl: null, program: null, time: 0, rafId: null }
    },
    // TRASUDATE_ENGINE - LIQUID_PHYSICS
    trasudate: {
        active: false,
        canvas: null, ctx: null,
        drops: [],
        rafId: null,
        physics: {
            gravity: 0.12,
            surfaceTension: 0.65,
            mergeThreshold: 30,
            trailFade: 0.015,
            viscosity: 0.94,
            maxDrops: 50
        }
    },
    // HOLOGRAM_ENGINE - THREE.JS REACTOR CORE
    hologram: {
        scene: null, camera: null, renderer: null,
        mesh: null,
        scale: 1.0, rotationSpeed: 0.01
    },
    // LEXICA_NANO
    neural: { generating: false, lastImage: null }
};

// GHOST TERMINAL
function ghostLog(msg, type = 'cmd') {
    const body = $('ghost-terminal-body');
    const ts = new Date().toTimeString().split(' ')[0].substring(0, 5);
    const line = document.createElement('div');
    line.className = 'ghost-log';
    line.innerHTML = `<span class="ts">${ts}</span><span class="${type}">${msg}</span>`;
    body.appendChild(line);
    body.scrollTop = body.scrollHeight;
    if (body.children.length > 50) body.firstChild.remove();
}

function ghostInit() {
    let dragging = false, startX, startY, elX, elY;
    const header = $('ghost-terminal-header');
    const terminal = $('ghost-terminal');
    header.addEventListener('mousedown', e => {
        dragging = true; startX = e.clientX; startY = e.clientY;
        elX = terminal.offsetLeft; elY = terminal.offsetTop;
    });
    document.addEventListener('mousemove', e => {
        if (!dragging) return;
        terminal.style.left = (elX + e.clientX - startX) + 'px';
        terminal.style.top = (elY + e.clientY - startY) + 'px';
        terminal.style.right = 'auto'; terminal.style.bottom = 'auto';
    });
    document.addEventListener('mouseup', () => { dragging = false; });
}

function toggleGhost() {
    const term = $('ghost-terminal');
    const isActive = term.style.display === 'flex';
    term.style.display = isActive ? 'none' : 'flex';
    if(!isActive) { term.classList.add('active'); $('ghost-input').focus(); ghostLog('GHOST_AI LISTENING...', 'ai'); }
}

$('ghost-input').addEventListener('keydown', e => { if(e.key === 'Enter') { const val = e.target.value.trim(); if(val) processGhostCommand(val); e.target.value = ''; } });

function processGhostCommand(cmd) { 
    ghostLog(cmd.toUpperCase(), 'user'); 
    const c = cmd.toLowerCase().trim();
    const hour = new Date().getHours();
    
    setTimeout(() => { 
        // Greetings
        if (c.match(/^(hi|hello|hey|yo|sup|ciao|hola|bonjour|salut|oi)$/)) {
            const greets = [
                'Hey operator. Systems are yours.',
                'Yo. What are we breaking today?',
                'Ciao. Ready when you are.',
                hour < 12 ? 'Morning. Coffee protocols engaged.' : hour < 18 ? 'Good afternoon, commander.' : 'Night shift. Let\'s make magic.'
            ];
            ghostLog(greets[Math.floor(Math.random()*greets.length)], 'ai');
        }
        // Status
        else if (c.includes('status') || c === 'sys') {
            ghostLog(`FPS:${APP.render.fps} | MEDIA:${APP.media.queue.length} | AUDIO:${APP.audio.isPlaying ? 'PLAYING' : 'IDLE'}`, 'ai');
        }
        // Help
        else if (c === 'help' || c === '?') {
            ghostLog('SOVEREIGN_COMMANDS:', 'ai');
            ghostLog('SHATTER | TRASUDATE | LOAD | MINT', 'success');
            ghostLog('status | theme | party | seismic | fx', 'ai');
            ghostLog('time | crypto | about | clear | fs', 'ai');
        }
        // ========== SOVEREIGN COMMANDS ==========
        // SHATTER - Trigger glass fractures across screen
        else if (c === 'shatter') {
            ghostLog('SHATTER_PROTOCOL: INITIATING...', 'success');
            const stage = $('stage');
            const rect = stage.getBoundingClientRect();
            for (let i = 0; i < 6; i++) {
                setTimeout(() => {
                    const x = rect.left + Math.random() * rect.width;
                    const y = rect.top + Math.random() * rect.height;
                    if (typeof createGlassFracture === 'function') {
                        createGlassFracture(x, y);
                    }
                }, i * 80);
            }
            ghostLog('GLASS_MATRIX: SHATTERED', 'success');
        }
        // TRASUDATE - Toggle liquid physics engine
        else if (c === 'trasudate' || c === 'liquid' || c === 'rain') {
            APP.trasudate.active = !APP.trasudate.active;
            if (APP.trasudate.active) {
                initTrasudateEngine();
                ghostLog('TRASUDATE_ENGINE: ONLINE', 'success');
                ghostLog('FLUID_PHYSICS: MERGING | TENSION | TRAILING', 'ai');
            } else {
                stopTrasudateEngine();
                ghostLog('TRASUDATE_ENGINE: OFFLINE', 'ai');
            }
        }
        // LOAD - Open directory picker for media scan
        else if (c === 'load' || c === 'scan') {
            ghostLog('LOAD_PROTOCOL: SCANNING...', 'ai');
            (async () => {
                try {
                    if (!window.showDirectoryPicker) {
                        ghostLog('DIRECTORY_PICKER: NOT_SUPPORTED', 'crit');
                        return;
                    }
                    const dirHandle = await window.showDirectoryPicker();
                    APP.ghost.directoryHandle = dirHandle;
                    let mediaCount = 0;
                    const mediaExt = ['.mp4', '.webm', '.mov', '.jpg', '.jpeg', '.png', '.gif', '.mp3', '.wav'];
                    
                    for await (const entry of dirHandle.values()) {
                        if (entry.kind === 'file') {
                            const name = entry.name.toLowerCase();
                            if (mediaExt.some(ext => name.endsWith(ext))) {
                                mediaCount++;
                                const file = await entry.getFile();
                                const url = URL.createObjectURL(file);
                                if (name.match(/\.(mp4|webm|mov)$/i)) {
                                    const vid = document.createElement('video');
                                    vid.src = url; vid.loop = true; vid.muted = true;
                                    APP.media.queue.push({ type: 'video', element: vid, name: entry.name });
                                } else if (name.match(/\.(jpg|jpeg|png|gif)$/i)) {
                                    const img = new Image();
                                    img.src = url;
                                    APP.media.queue.push({ type: 'image', element: img, name: entry.name });
                                }
                            }
                        }
                    }
                    ghostLog(`LOADED: ${mediaCount} MEDIA_FILES`, 'success');
                    $('q-info').textContent = APP.media.queue.length;
                } catch (e) {
                    ghostLog('LOAD_ABORTED: ' + e.message, 'crit');
                }
            })();
        }
        // MINT - Prepare NFT snapshot
        else if (c === 'mint') {
            ghostLog('MINT_PROTOCOL: PREPARING...', 'ai');
            if (APP.render.canvas) {
                try {
                    const dataUrl = APP.render.canvas.toDataURL('image/png');
                    APP.nft.dnaSnapshot = dataUrl;
                    ghostLog('SNAPSHOT: ' + (dataUrl.length / 1024).toFixed(0) + 'KB', 'success');
                    ghostLog('READY_FOR_MINT // CONNECT_WALLET', 'ai');
                    const a = document.createElement('a');
                    a.href = dataUrl;
                    a.download = `VNGRD_MINT_${Date.now()}.png`;
                    a.click();
                    ghostLog('SNAPSHOT_DOWNLOADED', 'success');
                } catch (e) {
                    ghostLog('MINT_ERROR: ' + e.message, 'crit');
                }
            }
        }
        // ========== END SOVEREIGN COMMANDS ==========
        // Theme
        else if (c.startsWith('theme ')) {
            const t = c.split(' ')[1];
            if (['cyan','magenta','green','purple','gold','night'].includes(t)) {
                setTheme(t);
                ghostLog(`Theme: ${t.toUpperCase()}`, 'success');
            } else {
                ghostLog('Themes: cyan, magenta, green, purple, gold, night', 'ai');
            }
        }
        else if (c === 'theme') {
            ghostLog(`Current: ${APP.state.theme || 'cyan'}`, 'ai');
        }
        // Party
        else if (c === 'party') {
            $('btn-ui-react').click();
            ghostLog(APP.vj.uiReactivity ? 'PARTY MODE: ON' : 'PARTY MODE: OFF', APP.vj.uiReactivity ? 'success' : 'ai');
        }
        // Seismic
        else if (c === 'seismic' || c === 'shake') {
            $('btn-rumble').click();
            ghostLog(APP.vj.rumbleEnabled ? 'SEISMIC: ARMED' : 'SEISMIC: OFF', APP.vj.rumbleEnabled ? 'success' : 'ai');
        }
        // FX
        else if (c === 'fx' || c === 'crush') {
            impactCrush();
            ghostLog('CRUSH FX TRIGGERED', 'success');
        }
        else if (c === 'stutter') {
            impactStutter();
            ghostLog('STUTTER FX', 'success');
        }
        else if (c === 'invert') {
            impactInvert();
            ghostLog('INVERT FX', 'success');
        }
        // Time
        else if (c === 'time' || c === 'clock') {
            ghostLog(new Date().toLocaleTimeString() + ' | UP:' + $('uptime').textContent, 'ai');
        }
        // Crypto
        else if (c === 'crypto' || c === 'btc' || c === 'eth') {
            fetchCrypto();
            ghostLog('Fetching feeds...', 'ai');
        }
        // Joke
        else if (c === 'joke') {
            const jokes = [
                'Why do DJs make great coders? They know how to drop the beat and the bugs.',
                'I told my GPU a joke. It rendered me speechless.',
                '404: Humor module temporarily unavailable.',
                'What\'s a VJ\'s favorite key? The space bar.',
            ];
            ghostLog(jokes[Math.floor(Math.random()*jokes.length)], 'ai');
        }
        // About
        else if (c === 'about' || c === 'who') {
            ghostLog('GHOST://AI v3 | VNGRD companion system', 'ai');
        }
        // Clear
        else if (c === 'clear' || c === 'cls') {
            $('ghost-terminal-body').innerHTML = '';
            ghostLog('Terminal cleared', 'ai');
        }
        // Fullscreen
        else if (c === 'fs' || c === 'fullscreen') {
            toggleFullscreen();
            ghostLog('Fullscreen toggled', 'success');
        }
        // Random/unknown - give helpful response
        else {
            const responses = [
                'Unknown. Type "help" for commands.',
                'Didn\'t catch that. Try "help".',
                'Command not found. "help" for list.',
            ];
            ghostLog(responses[Math.floor(Math.random()*responses.length)], 'crit');
        }
    }, 200 + Math.random() * 150); 
}

// CRYPTO
async function fetchCrypto() {
    try {
        const res = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${APP.crypto.ids}&vs_currencies=usd&include_24hr_change=true`);
        const data = await res.json();
        const html = [];
        const syms = { bitcoin: 'BTC', ethereum: 'ETH', solana: 'SOL', dogecoin: 'DOGE' };
        ['bitcoin', 'ethereum', 'solana', 'dogecoin'].forEach(id => {
            if(data[id]) {
                const change = data[id].usd_24h_change;
                const colorClass = change >= 0 ? 'tick-up' : 'tick-down';
                const arrow = change >= 0 ? '▲' : '▼';
                html.push(`<span>${syms[id]}: $${data[id].usd} <span class="${colorClass}">(${arrow} ${change.toFixed(2)}%)</span></span>`);
            }
        });
        html.push('<span style="color:var(--accent)">WHAT HAPPENS IN THE NODES STAYS IN THE NODES</span>');
        const finalHtml = html.join('&nbsp;&nbsp;//&nbsp;&nbsp;');
        $('ticker-text').innerHTML = finalHtml + '&nbsp;&nbsp;//&nbsp;&nbsp;' + finalHtml; 
    } catch(e) { $('ticker-text').innerHTML = '<span style="color:var(--r)">CONNECTION_LOST // RETRYING FEED...</span>'; }
}

// UTILS
function log(msg) { const box = document.getElementById('sys-log'); if (!box) return; const ts = new Date().toTimeString().split(' ')[0]; const el = document.createElement('div'); el.className = 'log-line'; el.innerHTML = `<span class="ts">${ts}</span>${msg}`; box.insertBefore(el, box.firstChild); if (box.children.length > 30) box.lastChild.remove(); }
function checkMobile() { APP.state.isMobile = /Android|iPhone|iPad|iPod|webOS|BlackBerry/i.test(navigator.userAgent); if (APP.state.isMobile) { APP.render.width = 1920; APP.render.height = 1080; log('MOBILE_MODE'); } }

// RENDER
function initCanvas() {
    APP.render.canvas = $('vj-canvas');
    APP.render.ctx = APP.render.canvas.getContext('2d', { alpha: false }); // Removed desynchronized to prevent grey flickering
    resizeCanvas();
    window.addEventListener('resize', () => { resizeCanvas(); checkMobile(); });
    // Off-screen canvas for proper pixelation
    APP.render.pixelCanvas = document.createElement('canvas');
    APP.render.pixelCanvas.width = 384; APP.render.pixelCanvas.height = 216; // Start small
    APP.render.pixelCtx = APP.render.pixelCanvas.getContext('2d', { alpha: false });
    APP.render.pixelCtx.imageSmoothingEnabled = false;
    log('CANVAS_INIT_4K');
}
function resizeCanvas() { APP.render.canvas.width = APP.render.width; APP.render.canvas.height = APP.render.height; $('res').textContent = `${APP.render.width}x${APP.render.height}`; }

function renderLoop(timestamp) {
    APP.render.rafId = requestAnimationFrame(renderLoop);
    APP.render.frameCount++;
    if (timestamp - APP.render.lastFpsUpdate >= 1000) { APP.render.fps = APP.render.frameCount; APP.render.frameCount = 0; APP.render.lastFpsUpdate = timestamp; $('fps-val').textContent = APP.render.fps; }
    
    const ctx = APP.render.ctx; const w = APP.render.width; const h = APP.render.height;
    ctx.imageSmoothingEnabled = false;
    
    // --- SEISMIC ENGINE (Random shake on bass - OFF by default) ---
    let finalShakeX = 0, finalShakeY = 0;
    
    if (APP.vj.rumbleEnabled && APP.audio.isPlaying && APP.audio.bassLevel > 150) {
        // Classic random shake on bass hits (like v22.1)
        const intensity = (APP.audio.bassLevel - 150) / 100 * 8;
        finalShakeX = (Math.random() - 0.5) * intensity;
        finalShakeY = (Math.random() - 0.5) * intensity;
    }

    // Apply transform to BODY
    const targetTransform = (Math.abs(finalShakeX) > 0.2 || Math.abs(finalShakeY) > 0.2) 
        ? `translate3d(${finalShakeX.toFixed(1)}px, ${finalShakeY.toFixed(1)}px, 0)` 
        : '';
    if (document.body.style.transform !== targetTransform) { 
        document.body.style.transform = targetTransform; 
    }

    // --- AUTONOMOUS PARTY MODE ---
    if (APP.vj.uiReactivity) {
        if (APP.audio.bassLevel > 220) {
           // Light play handled in analyzeAudio for performance
        }
    }

    // --- CLEAR FRAME (kill ghosting on logos) ---
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, w, h);
    
    // FILTER STACK - values are decimals (1.0 = 100%), convert to proper CSS
    const filterStr = `brightness(${APP.vj.brightness}) contrast(${APP.vj.contrast}) saturate(${APP.vj.saturation}) hue-rotate(${APP.vj.hue}deg)${APP.vj.invert ? ' invert(1)' : ''}`;
    ctx.filter = filterStr;
    
    let source = null;
    if (APP.state.isLive && APP.camera.stream && APP.camera.videoEl) source = APP.camera.videoEl; 
    else if (APP.guest.stream && APP.guest.isActive && APP.guest.videoElement) source = APP.guest.videoElement;
    else if (APP.media.currentElement) source = APP.media.currentElement;
    
    if (source) {
        const ready = source.tagName === 'VIDEO' ? source.readyState >= 2 : (source.complete && source.naturalWidth > 0);
        if (ready) {
            
            if (APP.vj.pixelateEnabled && APP.vj.pixelSize > 1) {
                // OFF-SCREEN BUFFER RENDER
                const size = APP.vj.pixelSize;
                const sw = Math.ceil(w / size);
                const sh = Math.ceil(h / size);
                
                if(APP.render.pixelCanvas.width !== sw) { APP.render.pixelCanvas.width = sw; APP.render.pixelCanvas.height = sh; }
                
                APP.render.pixelCtx.drawImage(source, 0, 0, sw, sh);
                ctx.drawImage(APP.render.pixelCanvas, 0, 0, sw, sh, 0, 0, w, h);
            } else {
                ctx.drawImage(source, 0, 0, w, h);
            }

            if (APP.vj.maskMode) {
                const pulse = 1 + (APP.audio.bassLevel / 255) * 0.5;
                ctx.globalCompositeOperation = 'destination-in';
                ctx.beginPath(); ctx.arc(w/2, h/2, (h/3) * pulse, 0, Math.PI * 2); ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
            }
        }
    }

    // --- RGB SHIFT ---
    if (APP.vj.rgbEnabled && APP.vj.rgbIntensity > 0) {
        const shift = APP.vj.rgbIntensity;
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(APP.render.canvas, shift, 0);
        ctx.drawImage(APP.render.canvas, -shift, 0);
        ctx.restore();
    }
    
    // ═══ IDENTITY TRINITY — three independent actors burned into canvas ═══
    ctx.filter = 'none';
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
    var T = APP.trinity;
    
    // ACTOR 1: STATION BUG (text or uploaded image)
    if (T.bug.visible) {
        var bugEl = $('station-bug');
        var bx = T.bug.x * w, by = T.bug.y * h, bScale = T.bug.scale;
        if (bugEl) {
            var bugImg = bugEl.querySelector('img');
            if (bugImg && bugImg.complete && bugImg.naturalWidth > 0) {
                ctx.save();
                var bw = bugImg.naturalWidth * bScale * (w / 1920);
                var bh = bugImg.naturalHeight * bScale * (h / 1080);
                ctx.drawImage(bugImg, bx, by, bw, bh);
                ctx.restore();
            } else if (APP.bug.text) {
                ctx.save();
                var bugFS = Math.max(14, 28 * bScale * (h / 1080));
                ctx.font = '800 ' + bugFS + 'px Orbitron, sans-serif';
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2;
                ctx.fillText(APP.bug.text, bx, by);
                ctx.restore();
            }
        }
    }
    
    // ACTOR 2: 2D LOGO (uploaded image via drawImage — no size cap)
    if (T.logo.visible) {
        var logoImg = $('user-logo-layer');
        if (logoImg && logoImg.src && logoImg.src !== window.location.href && logoImg.naturalWidth > 0) {
            ctx.save();
            var lScale = T.logo.scale;
            var lw = logoImg.naturalWidth * lScale * (w / 1920);
            var lh = logoImg.naturalHeight * lScale * (h / 1080);
            var lx = T.logo.x * w, ly = T.logo.y * h;
            ctx.drawImage(logoImg, lx, ly, lw, lh);
            ctx.restore();
        }
    }
    
    // ACTOR 3: 3D MODEL (renderLoop drives rotation + render, zero zombie loops)
    if (T.holo.visible) {
        var holoCanvas = $('hologram-canvas');
        if (holoCanvas && holoCanvas.width > 0) {
            // Drive 3D animation from renderLoop — single rAF for everything
            if (APP.hologram.mesh && APP.hologram.renderer && APP.hologram.scene && APP.hologram.camera) {
                APP.hologram.mesh.rotation.y += APP.hologram.rotationSpeed;
                APP.hologram.renderer.render(APP.hologram.scene, APP.hologram.camera);
            }
            ctx.save();
            var hScale = T.holo.scale;
            var hw = holoCanvas.width * hScale * (w / 1920);
            var hh = holoCanvas.height * hScale * (h / 1080);
            var hx = T.holo.x * w, hy = T.holo.y * h;
            try { ctx.drawImage(holoCanvas, hx, hy, hw, hh); } catch(e) {}
            ctx.restore();
        }
    }
        

    // ═══ PERMANENT SIGNATURE — untouchable, not part of Trinity ═══
    ctx.save();
    var sigFS = Math.max(14, h * 0.012);
    ctx.font = '900 ' + sigFS + 'px Orbitron';
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
    ctx.shadowColor = 'rgba(0,0,0,0.6)'; ctx.shadowBlur = sigFS / 8;
    ctx.fillText('VNGRD', w - (w * 0.01), h - (h * 0.01));
    ctx.restore();
}

function triggerImpact() { document.body.classList.remove('impact-flash'); void document.body.offsetWidth; document.body.classList.add('impact-flash'); setTimeout(() => document.body.classList.remove('impact-flash'), 200); }
function triggerChromaticAberration() { const c = APP.render.canvas; c.style.filter = 'url(#chromatic-ghost)'; setTimeout(() => { c.style.filter = 'none'; }, 200); }
function impactStutter() { const oT = APP.vj.trailsEnabled, oA = APP.vj.trailAlpha; APP.vj.trailsEnabled = true; APP.vj.trailAlpha = 0.98; triggerChromaticAberration(); setTimeout(() => { APP.vj.trailsEnabled = oT; APP.vj.trailAlpha = oA; }, 500); }
function impactInvert() { APP.vj.invert = true; triggerChromaticAberration(); setTimeout(() => { APP.vj.invert = false; }, 500); }
function impactCrush() { const oRGB = APP.vj.rgbIntensity, oPix = APP.vj.pixelSize, oRE = APP.vj.rgbEnabled, oPE = APP.vj.pixelateEnabled; APP.vj.rgbEnabled = true; APP.vj.pixelateEnabled = true; APP.vj.rgbIntensity = 25; APP.vj.pixelSize = 16; setTimeout(() => { APP.vj.rgbEnabled = oRE; APP.vj.pixelateEnabled = oPE; APP.vj.rgbIntensity = oRGB; APP.vj.pixelSize = oPix; }, 500); }

// SIMPLE DRAGGABLE - DIRECT LEFT/TOP POSITIONING (for non-Trinity DOM elements)
function makeDraggable(el) {
    let isDown = false, iX, iY, cX = 0, cY = 0;
    el.addEventListener('mousedown', e => {
        isDown = true; iX = e.clientX - cX; iY = e.clientY - cY;
        el.style.cursor = 'grabbing'; e.stopPropagation();
    });
    document.addEventListener('mousemove', e => {
        if (!isDown) return; e.preventDefault();
        cX = e.clientX - iX; cY = e.clientY - iY;
        el.style.transform = 'translate3d(' + cX + 'px, ' + cY + 'px, 0)';
    });
    document.addEventListener('mouseup', () => { isDown = false; el.style.cursor = 'grab'; });
}

// ═══ TOUCH-BRIDGE — Unified Mouse + Touch for Trinity ═══
// One-finger drag + two-finger pinch (mobile) / mouse drag + ctrl+wheel pinch (desktop)
(function initTouchBridge() {
    var activeActor = null, offsetX = 0, offsetY = 0;
    var pinchActor = null, lastPinchDist = 0;

    // --- Shared utilities ---
    function getCanvas() { return APP.render.canvas || null; }

    function canvasNorm(clientX, clientY) {
        var c = getCanvas(); if (!c) return null;
        var r = c.getBoundingClientRect();
        return { x: (clientX - r.left) / r.width, y: (clientY - r.top) / r.height };
    }

    function hitTest(pos) {
        var T = APP.trinity, w = APP.render.width, h = APP.render.height;
        if (T.holo.visible) {
            var hc = $('hologram-canvas');
            if (hc && hc.width > 0) {
                var hw = (hc.width * T.holo.scale * (w / 1920)) / w;
                var hh = (hc.height * T.holo.scale * (h / 1080)) / h;
                if (pos.x >= T.holo.x && pos.x <= T.holo.x + hw && pos.y >= T.holo.y && pos.y <= T.holo.y + hh) return 'holo';
            }
        }
        if (T.logo.visible) {
            var li = $('user-logo-layer');
            if (li && li.naturalWidth > 0) {
                var lw = (li.naturalWidth * T.logo.scale * (w / 1920)) / w;
                var lh = (li.naturalHeight * T.logo.scale * (h / 1080)) / h;
                if (pos.x >= T.logo.x && pos.x <= T.logo.x + lw && pos.y >= T.logo.y && pos.y <= T.logo.y + lh) return 'logo';
            }
        }
        if (T.bug.visible) {
            var bw = Math.max(0.08, 0.08 * T.bug.scale);
            var bh = Math.max(0.03, 0.03 * T.bug.scale);
            if (pos.x >= T.bug.x && pos.x <= T.bug.x + bw && pos.y >= T.bug.y && pos.y <= T.bug.y + bh) return 'bug';
        }
        return null;
    }

    function isUIElement(target) {
        return target.closest && (target.closest('.sidebar') || target.closest('#ghost-bar') || target.closest('button') || target.closest('input') || target.closest('#portrait-lock'));
    }

    function clampPos(v) { return Math.max(0, Math.min(0.95, v)); }

    function applyScale(actor, delta) {
        APP.trinity[actor].scale = Math.max(0.1, Math.min(10, APP.trinity[actor].scale + delta));
        if (actor === 'holo') APP.hologram.scale = APP.trinity.holo.scale;
    }

    // ─── MOUSE: drag ───
    document.addEventListener('mousedown', function(e) {
        if (isUIElement(e.target)) return;
        var pos = canvasNorm(e.clientX, e.clientY);
        if (!pos) return;
        var actor = hitTest(pos);
        if (!actor) return;
        activeActor = actor;
        offsetX = pos.x - APP.trinity[actor].x;
        offsetY = pos.y - APP.trinity[actor].y;
        e.preventDefault();
    });
    document.addEventListener('mousemove', function(e) {
        if (!activeActor) return;
        var pos = canvasNorm(e.clientX, e.clientY);
        if (!pos) return;
        APP.trinity[activeActor].x = clampPos(pos.x - offsetX);
        APP.trinity[activeActor].y = clampPos(pos.y - offsetY);
        e.preventDefault();
    });
    document.addEventListener('mouseup', function() { activeActor = null; });

    // ─── MOUSE: ctrl+wheel pinch (Mac trackpad) ───
    document.addEventListener('wheel', function(e) {
        if (!e.ctrlKey) return;
        var pos = canvasNorm(e.clientX, e.clientY);
        if (!pos) return;
        var actor = hitTest(pos);
        if (!actor) return;
        e.preventDefault();
        applyScale(actor, e.deltaY > 0 ? -0.05 : 0.05);
    }, { passive: false });

    // ─── TOUCH: one-finger drag + two-finger pinch ───
    var touchDragActor = null, touchOffX = 0, touchOffY = 0;

    document.addEventListener('touchstart', function(e) {
        if (isUIElement(e.target)) return;

        if (e.touches.length === 1) {
            // ONE FINGER — drag
            var t = e.touches[0];
            var pos = canvasNorm(t.clientX, t.clientY);
            if (!pos) return;
            var actor = hitTest(pos);
            if (!actor) return;
            touchDragActor = actor;
            touchOffX = pos.x - APP.trinity[actor].x;
            touchOffY = pos.y - APP.trinity[actor].y;
            e.preventDefault();
        } else if (e.touches.length === 2) {
            // TWO FINGERS — pinch-to-zoom
            touchDragActor = null;
            var dx = e.touches[0].clientX - e.touches[1].clientX;
            var dy = e.touches[0].clientY - e.touches[1].clientY;
            lastPinchDist = Math.sqrt(dx * dx + dy * dy);
            var mx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            var my = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            var pos = canvasNorm(mx, my);
            if (pos) pinchActor = hitTest(pos);
        }
    }, { passive: false });

    document.addEventListener('touchmove', function(e) {
        if (e.touches.length === 1 && touchDragActor) {
            // ONE FINGER — drag
            var t = e.touches[0];
            var pos = canvasNorm(t.clientX, t.clientY);
            if (!pos) return;
            APP.trinity[touchDragActor].x = clampPos(pos.x - touchOffX);
            APP.trinity[touchDragActor].y = clampPos(pos.y - touchOffY);
            e.preventDefault();
        } else if (e.touches.length === 2 && pinchActor) {
            // TWO FINGERS — pinch-to-zoom
            var dx = e.touches[0].clientX - e.touches[1].clientX;
            var dy = e.touches[0].clientY - e.touches[1].clientY;
            var dist = Math.sqrt(dx * dx + dy * dy);
            var delta = (dist - lastPinchDist) * 0.005;
            applyScale(pinchActor, delta);
            lastPinchDist = dist;
            e.preventDefault();
        }
    }, { passive: false });

    document.addEventListener('touchend', function(e) {
        if (e.touches.length === 0) {
            touchDragActor = null; pinchActor = null; activeActor = null;
            lastPinchDist = 0;
        } else if (e.touches.length === 1) {
            pinchActor = null; lastPinchDist = 0;
            var t = e.touches[0];
            var pos = canvasNorm(t.clientX, t.clientY);
            if (pos) {
                var actor = hitTest(pos);
                if (actor) {
                    touchDragActor = actor;
                    touchOffX = pos.x - APP.trinity[actor].x;
                    touchOffY = pos.y - APP.trinity[actor].y;
                }
            }
        }
    });

    document.addEventListener('touchcancel', function() {
        touchDragActor = null; pinchActor = null; activeActor = null; lastPinchDist = 0;
    });
})();


// ========================================
// V34 IDENTITY HANDLERS
// ========================================

// STATION BUG - Set text
if ($('btn-set-station')) {
    $('btn-set-station').onclick = () => {
        const bug = $('station-bug');
        const text = $('bug-text').value || 'VNGRD';
        if (bug) {
            bug.textContent = text;
            bug.style.display = 'block';
            bug.style.background = 'transparent';
            APP.bug.text = text;
        }
        log('STATION: ' + text.toUpperCase());
    };
}

// STATION BUG - Toggle [X] (visible -> hidden via Trinity state)
if ($('btn-bug-toggle')) {
    $('btn-bug-toggle').onclick = () => {
        APP.trinity.bug.visible = !APP.trinity.bug.visible;
        var bug = $('station-bug');
        if (bug) bug.classList.toggle('hidden', !APP.trinity.bug.visible);
        log(APP.trinity.bug.visible ? 'BUG: VISIBLE' : 'BUG: HIDDEN');
    };
}

// 2D LOGO - Upload
if ($('btn-upload-2d')) {
    $('btn-upload-2d').onclick = () => $('file-2d-logo').click();
}

if ($('file-2d-logo')) {
    $('file-2d-logo').onchange = e => {
        if (e.target.files.length) {
            const file = e.target.files[0];
            const url = URL.createObjectURL(file);
            const logoLayer = $('user-logo-layer');
            if (logoLayer) {
                logoLayer.src = url;
                logoLayer.style.display = 'block';
                logoLayer.style.background = 'transparent';
                logoLayer.style.border = 'none';
                logoLayer.style.boxShadow = 'none';
                logoLayer.style.pointerEvents = 'auto';
            }
            APP.trinity.logo.visible = true;
            log('2D_LOGO: ' + file.name.toUpperCase());
        }
    };
}

// 2D LOGO - Toggle [X] (visible -> hidden -> cleared)
APP.layers.logo2dState = 'empty';

if ($('btn-2d-x')) {
    $('btn-2d-x').onclick = () => {
        const logoLayer = $('user-logo-layer');
        if (!logoLayer) return;
        
        if (APP.trinity.logo.visible) {
            // Visible -> Hidden
            APP.trinity.logo.visible = false;
            logoLayer.style.display = 'none';
            log('2D_LOGO: HIDDEN');
        } else if (logoLayer.src && logoLayer.src !== window.location.href) {
            // Hidden -> Clear
            APP.trinity.logo.visible = false;
            logoLayer.src = '';
            logoLayer.style.display = 'none';
            log('2D_LOGO: CLEARED');
        }
    };
}

// 3D handled exclusively by module script — no inline handlers

// MEDIA & CYCLE LOGIC
function loadMediaFiles(input) {
    const isFirstLoad = APP.media.currentIndex === -1;
    Array.from(input.files).forEach((file, idx) => {
        const url = URL.createObjectURL(file);
        const type = file.type.startsWith('video') ? 'video' : 'image';
        const item = { type, url, element: null, name: file.name };
        if (type === 'video') { const vid = document.createElement('video'); vid.src = url; vid.muted = true; vid.loop = !APP.state.isCycle; vid.playsInline = true; vid.preload = 'auto'; item.element = vid; $('media-container').appendChild(vid); }
        else { const img = new Image(); img.src = url; item.element = img; }
        APP.media.queue.push(item);
        if (isFirstLoad && idx === 0) rotateMedia();
    });
    updateQueueDisplay(); $('media-dot').classList.remove('off'); log(`MEDIA: +${input.files.length}`); 
}

function rotateMedia() {
    if (APP.media.queue.length === 0) return;
    APP.vj.glitchSnap = 3; 
    if (APP.media.currentElement?.tagName === 'VIDEO') APP.media.currentElement.pause();
    APP.media.currentIndex = (APP.media.currentIndex + 1) % APP.media.queue.length;
    const item = APP.media.queue[APP.media.currentIndex];
    APP.media.currentElement = item.element;
    if (item.type === 'video') { item.element.loop = !APP.state.isCycle; item.element.currentTime = 0; item.element.play().catch(() => {}); }
    checkCycleLogic();
}

function previousMedia() {
    if (APP.media.queue.length === 0) return;
    APP.vj.glitchSnap = 3;
    if (APP.media.currentElement?.tagName === 'VIDEO') APP.media.currentElement.pause();
    APP.media.currentIndex = (APP.media.currentIndex - 1 + APP.media.queue.length) % APP.media.queue.length;
    const item = APP.media.queue[APP.media.currentIndex];
    APP.media.currentElement = item.element;
    if (item.type === 'video') { item.element.loop = !APP.state.isCycle; item.element.currentTime = 0; item.element.play().catch(() => {}); }
    checkCycleLogic();
}

function ejectCurrent() {
    if (APP.media.queue.length === 0) return;
    const current = APP.media.queue[APP.media.currentIndex];
    if (current.element?.tagName === 'VIDEO') { current.element.pause(); current.element.src = ''; current.element.remove(); }
    URL.revokeObjectURL(current.url);
    APP.media.queue.splice(APP.media.currentIndex, 1);
    if (APP.media.queue.length === 0) { APP.media.currentIndex = -1; APP.media.currentElement = null; $('media-dot').classList.add('off'); APP.render.ctx.fillStyle = '#000'; APP.render.ctx.fillRect(0, 0, APP.render.width, APP.render.height); }
    else { if (APP.media.currentIndex >= APP.media.queue.length) APP.media.currentIndex = 0; const next = APP.media.queue[APP.media.currentIndex]; APP.media.currentElement = next.element; if (next.type === 'video') { next.element.currentTime = 0; next.element.play().catch(() => {}); } }
    updateQueueDisplay();
}

function clearDeck() {
    if(APP.state.isCycle) toggleCycle();
    APP.media.queue.forEach(item => { if (item.element?.tagName === 'VIDEO') { item.element.pause(); item.element.src = ''; item.element.remove(); } URL.revokeObjectURL(item.url); });
    APP.media.queue = []; APP.media.currentIndex = -1; APP.media.currentElement = null; $('media-dot').classList.add('off');
    updateQueueDisplay();
    log('DECK_CLEARED');
}

function panicReset() {
    location.reload(); // Hard Reset for Panic
}

function toggleCycle() {
    if (APP.media.queue.length === 0) return; 

    APP.state.isCycle = !APP.state.isCycle;
    const btn = $('btn-cycle-toggle');
    const header = $('media-header');
    
    if (APP.state.isCycle) {
        btn.innerHTML = 'CYCLE: ON';
        btn.classList.add('cycle-active'); 
        header.classList.add('scanning');
        $('cycle-badge').classList.add('on');
        checkCycleLogic();
    } else {
        btn.innerHTML = 'CYCLE: OFF';
        btn.classList.remove('cycle-active');
        header.classList.remove('scanning');
        $('cycle-badge').classList.remove('on');
        clearTimeout(APP.state.cycleTimer);
        if (APP.media.currentElement?.tagName === 'VIDEO') APP.media.currentElement.loop = true;
    }
}

function checkCycleLogic() {
    clearTimeout(APP.state.cycleTimer);
    if (!APP.state.isCycle || APP.media.currentIndex === -1) return;
    const current = APP.media.queue[APP.media.currentIndex];
    if (!current) return;
    if (current.type === 'video') { if (current.element) { current.element.loop = false; current.element.onended = () => { if (APP.state.isCycle) rotateMedia(); }; } }
    else { const secs = parseInt($('sl-cycle').value) || 8; APP.state.cycleTimer = setTimeout(() => { if (APP.state.isCycle) rotateMedia(); }, secs * 1000); }
}

function updateQueueDisplay() {
    const count = APP.media.queue.length;
    if($('q-info')) $('q-info').textContent = count; 
    const btn = $('btn-load-media');
    if (count > 0) {
        btn.innerHTML = `MEDIA LOADED [ ${count} ]`;
        btn.classList.add('active-mode');
        $('media-dot').classList.remove('off');
    } else {
        btn.innerHTML = 'LOAD MEDIA';
        btn.classList.remove('active-mode');
        $('media-dot').classList.add('off');
    }
}

// CAMERA
async function initCamera() {
    try {
        APP.camera.stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 3840 }, height: { ideal: 2160 }, frameRate: { ideal: 60, min: 30 } }, audio: false });
        APP.camera.videoEl = document.createElement('video');
        APP.camera.videoEl.srcObject = APP.camera.stream;
        APP.camera.videoEl.muted = true; APP.camera.videoEl.playsInline = true; APP.camera.videoEl.play().catch(() => {});
        APP.camera.mode = 'preview';
        $('btn-init-cam').style.display = 'none';
        $('cam-ctrls').style.display = 'block';
        $('btn-kill').style.display = 'block';
        $('cam-dot').classList.remove('off');
        log('CAM_ONLINE');
        if (!APP.audio.ctx) { APP.audio.ctx = new (window.AudioContext || window.webkitAudioContext)(); }

        // Activate floating camera preview box
        const preview = $('cam-preview-float');
        const previewVid = $('preview-vid-float');
        if (preview && previewVid) {
            previewVid.srcObject = APP.camera.stream;
            preview.classList.add('active');
            APP.camera.previewEl = previewVid;
        }
    } catch (e) { log('CAM_DENIED'); }
}

$('btn-inject').onclick = () => {
    if(!APP.camera.stream) return;
    const btn = $('btn-inject');
    if (APP.loop.recorder && APP.loop.recorder.state === 'recording') { APP.loop.recorder.stop(); return; }
    APP.loop.chunks = [];
    APP.loop.recorder = new MediaRecorder(APP.camera.stream, { mimeType: 'video/webm' }); 
    APP.loop.recorder.ondataavailable = e => APP.loop.chunks.push(e.data);
    APP.loop.recorder.onstop = () => {
        clearInterval(APP.loop.timer);
        const blob = new Blob(APP.loop.chunks, { type: 'video/webm' });
        if(APP.loop.activeUrl) URL.revokeObjectURL(APP.loop.activeUrl);
        APP.loop.activeUrl = URL.createObjectURL(blob);
        const vid = document.createElement('video');
        vid.src = APP.loop.activeUrl;
        vid.muted = true; vid.loop = true; vid.play();
        const item = { type: 'video', url: APP.loop.activeUrl, element: vid, name: 'LOOP_SAMPLE' };
        APP.media.queue.push(item);
        APP.media.currentIndex = APP.media.queue.length - 1;
        APP.media.currentElement = vid;
        APP.state.isLive = false; 
        btn.innerText = 'INJECT LOOP (10s)'; btn.classList.remove('on'); updateQueueDisplay(); log('LOOP_INJECTED');
    };
    APP.loop.recorder.start(); btn.classList.add('on'); APP.loop.counter = 10; btn.innerText = `SAMPLING... ${APP.loop.counter}`;
    APP.loop.timer = setInterval(() => { APP.loop.counter--; btn.innerText = `SAMPLING... ${APP.loop.counter}`; if(APP.loop.counter <= 0) APP.loop.recorder.stop(); }, 1000);
};

function goLive() {
    if (!APP.camera.stream) return;
    const overlay = $('countdown'); const num = $('countdown-num'); const btn = $('btn-go-live');
    overlay.style.display = 'flex'; let count = 3; num.textContent = count; btn.textContent = `LIVE IN ${count}...`; 
    const interval = setInterval(() => {
        count--;
        if (count > 0) { num.textContent = count; btn.textContent = `LIVE IN ${count}...`; }
        else { 
            clearInterval(interval); overlay.style.display = 'none'; APP.state.isLive = true; APP.camera.mode = 'live'; var _pf = $('cam-preview-float'); if (_pf) { _pf.classList.remove('active'); _pf.style.display = 'none'; } 
            $('cam-ctrls').style.display = 'none'; $('live-ctrls').style.display = 'block'; $('tally').style.display = 'block'; $('status-text').textContent = 'LIVE'; $('main-dot').classList.add('live'); 
            document.querySelector('.preview-label').textContent = 'LIVE'; log('LIVE_PODCAST_MODE'); 
        }
    }, 1000);
}

$('btn-rec').onclick = () => {
    const btn = $('btn-rec');
    if(APP.broadcast.isRecording) {
        APP.broadcast.recorder.stop(); APP.broadcast.isRecording = false; btn.innerText = 'SAVING...'; btn.classList.remove('active'); 
        $('rec-status').style.display = 'none'; 
    } else {
        const stream = APP.render.canvas.captureStream(60);
        if(APP.audio.source && APP.audio.ctx) {
            const dest = APP.audio.ctx.createMediaStreamDestination();
            APP.audio.source.connect(dest); 
            if(dest.stream.getAudioTracks().length > 0) stream.addTrack(dest.stream.getAudioTracks()[0]);
        }
        APP.broadcast.chunks = [];
        // Phase 1: 15Mbps VP9 codec enforcement
        let bcastOpts = { mimeType: 'video/webm;codecs=vp9,opus', videoBitsPerSecond: 15000000, audioBitsPerSecond: 128000 };
        try { APP.broadcast.recorder = new MediaRecorder(stream, bcastOpts); }
        catch(e) { APP.broadcast.recorder = new MediaRecorder(stream, { mimeType: 'video/webm' }); }
        APP.broadcast.recorder.ondataavailable = e => APP.broadcast.chunks.push(e.data);
        APP.broadcast.recorder.onstop = () => {
            const blob = new Blob(APP.broadcast.chunks, { type: 'video/webm' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `VNGRD_BROADCAST_${Date.now()}.webm`; a.click(); btn.innerText = 'REC_BROADCAST'; log('BROADCAST_SAVED');
        };
        APP.broadcast.recorder.start(); APP.broadcast.isRecording = true; btn.innerText = '■ STOP & SAVE'; btn.classList.add('active'); 
        $('rec-status').style.display = 'block'; 
    }
};

function endLive() { 
    APP.state.isLive = false; APP.camera.mode = 'preview'; $('live-ctrls').style.display = 'none'; $('cam-ctrls').style.display = 'block'; $('tally').style.display = 'none'; $('status-text').textContent = 'STANDBY'; $('main-dot').classList.remove('live'); $('btn-go-live').textContent = 'GO LIVE [3-2-1]'; var _pf3 = $('cam-preview-float'); if (_pf3 && APP.camera.stream) { _pf3.style.display = ''; _pf3.classList.add('active'); } 
    log('END_LIVE'); 
    $('rec-status').style.display = 'none';
}

function killCamera() { 
    if (APP.camera.stream) APP.camera.stream.getTracks().forEach(t => t.stop()); 
    if (APP.camera.videoEl) { APP.camera.videoEl.srcObject = null; APP.camera.videoEl = null; } 
    APP.camera.mode = 'off'; APP.state.isLive = false; $('live-ctrls').style.display = 'none'; $('cam-ctrls').style.display = 'none'; $('btn-init-cam').style.display = 'block'; $('btn-kill').style.display = 'none'; $('cam-dot').classList.add('off'); $('tally').style.display = 'none'; $('status-text').textContent = 'STANDBY'; $('main-dot').classList.remove('live'); var _pf2 = $('cam-preview-float'); if (_pf2) { _pf2.classList.remove('active'); _pf2.style.display = 'none'; } if (APP.camera.previewEl) { APP.camera.previewEl.srcObject = null; APP.camera.previewEl = null; } log('CAM_OFF'); 
    $('rec-status').style.display = 'none';
}

function showLowerThird(preset) {
    const lt = $('lower-third'); const container = lt.querySelector('.lt-container');
    container.classList.remove('lt-guest', 'lt-track', 'lt-breaking'); container.classList.add(`lt-${preset}`);
    APP.lowerThird.preset = preset; APP.lowerThird.visible = true;
    if (preset === 'track' && APP.audio.currentTrackName) { $('lt-title-text').textContent = APP.audio.currentTrackName; $('lt-subtitle-text').textContent = 'NOW PLAYING'; }
    else if (preset === 'breaking') { $('lt-title-text').textContent = $('lt-title').value || 'BREAKING NEWS'; $('lt-subtitle-text').textContent = $('lt-sub').value || 'LIVE UPDATE'; }
    else { $('lt-title-text').textContent = $('lt-title').value || 'GUEST NAME'; $('lt-subtitle-text').textContent = $('lt-sub').value || 'TITLE / ROLE'; }
    lt.classList.add('visible');
    ['guest', 'track', 'breaking', 'off'].forEach(p => { $(`btn-lt-${p}`).classList.toggle('on', p === preset); });
}
function hideLowerThird() { $('lower-third').classList.remove('visible'); APP.lowerThird.visible = false; ['guest', 'track', 'breaking', 'off'].forEach(p => { $(`btn-lt-${p}`).classList.remove('on'); }); $('btn-lt-off').classList.add('on'); }

// AUDIO ENGINEER IMPLEMENTATION
APP.audio.element = $('audio-el');
function loadAudioFiles(input) { Array.from(input.files).forEach(file => { APP.audio.playlist.push({ url: URL.createObjectURL(file), name: file.name.replace(/\.[^.]+$/, '') }); }); $('audio-dot').classList.remove('off'); if (!APP.audio.isPlaying && APP.audio.playlist.length) playTrack(0); log(`AUDIO: +${input.files.length}`); }

function playTrack(idx) {
    if (!APP.audio.playlist.length) return;
    if (idx !== undefined) APP.audio.currentTrack = idx;
    else if (APP.audio.currentTrack === -1) APP.audio.currentTrack = 0;
    const track = APP.audio.playlist[APP.audio.currentTrack];
    APP.audio.currentTrackName = track.name;
    APP.audio.element.src = track.url;
    
    // Ensure Context
    if (!APP.audio.ctx) APP.audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
    
    APP.audio.element.play().then(() => { 
        APP.audio.isPlaying = true; 
        $('track-info').textContent = track.name.toUpperCase(); 
        if (APP.lowerThird.visible && APP.lowerThird.preset === 'track') $('lt-title-text').textContent = track.name; 
        log(`PLAY: ${track.name}`); 
        updatePlayIcon();
    });
    if (!APP.audio.isConnected) setupAudioChain();
}

function nextTrack() {
    if (!APP.audio.playlist.length) return;
    APP.audio.currentTrack = (APP.audio.currentTrack + 1) % APP.audio.playlist.length;
    playTrack(APP.audio.currentTrack);
}

function prevTrack() {
    if (!APP.audio.playlist.length) return;
    APP.audio.currentTrack = (APP.audio.currentTrack - 1 + APP.audio.playlist.length) % APP.audio.playlist.length;
    playTrack(APP.audio.currentTrack);
}

function togglePlayPause() {
    if (!APP.audio.playlist.length) return;
    if (APP.audio.element.paused) {
        if (APP.audio.element.src) APP.audio.element.play();
        else playTrack();
    } else {
        APP.audio.element.pause();
    }
    APP.audio.isPlaying = !APP.audio.element.paused;
    updatePlayIcon();
}

function updatePlayIcon() {
    const icon = $('icon-play-state');
    if(APP.audio.isPlaying) {
        icon.innerHTML = '<path fill="currentColor" d="M3 2h2v8H3zm4 0h2v8H7z"/>';
    } else {
        icon.innerHTML = '<path fill="currentColor" d="M3 2v8l7-4z"/>';
    }
}

function setupAudioChain() {
    const ctx = APP.audio.ctx;
    if (APP.audio.source) APP.audio.source.disconnect();
    APP.audio.source = ctx.createMediaElementSource(APP.audio.element);
    APP.audio.analyzer = ctx.createAnalyser();
    APP.audio.analyzer.fftSize = 64;
    APP.audio.masterGain = ctx.createGain();
    APP.audio.masterGain.gain.value = 0.9;
    
    // 3D Spatial
    APP.audio.panner = ctx.createPanner();
    APP.audio.panner.panningModel = 'HRTF';
    APP.audio.panner.distanceModel = 'inverse';
    
    // Dolby Emulation (EQ + Comp)
    APP.audio.lowShelf = ctx.createBiquadFilter();
    APP.audio.lowShelf.type = "lowshelf";
    APP.audio.lowShelf.frequency.value = 60; 
    APP.audio.lowShelf.gain.value = 0; 
    APP.audio.highShelf = ctx.createBiquadFilter();
    APP.audio.highShelf.type = "highshelf";
    APP.audio.highShelf.frequency.value = 12000;
    APP.audio.highShelf.gain.value = 0; 
    APP.audio.compressor = ctx.createDynamicsCompressor();
    APP.audio.compressor.threshold.value = -24; 
    APP.audio.compressor.knee.value = 30;
    APP.audio.compressor.ratio.value = 1; 

    // ═══ Phase 2: OUTPUT LIMITER (Hard 0dB ceiling) ═══
    APP.audio.outputLimiter = ctx.createDynamicsCompressor();
    APP.audio.outputLimiter.threshold.setValueAtTime(-1, ctx.currentTime);
    APP.audio.outputLimiter.knee.setValueAtTime(0, ctx.currentTime);
    APP.audio.outputLimiter.ratio.setValueAtTime(20, ctx.currentTime);
    APP.audio.outputLimiter.attack.setValueAtTime(0.001, ctx.currentTime);
    APP.audio.outputLimiter.release.setValueAtTime(0.1, ctx.currentTime);

    // ═══ Phase 2: SIDE-CHAIN DUCKING GAIN ═══
    APP.audio.duckingGain = ctx.createGain();
    APP.audio.duckingGain.gain.setValueAtTime(1.0, ctx.currentTime);

    // ═══ Phase 2: TRIPLE-PATH STEREO TAP ═══
    APP.audio.stereoGain = ctx.createGain();
    APP.audio.stereoGain.gain.setValueAtTime(1.0, ctx.currentTime);

    // ═══ Phase 2: DOLBY HRTF PATH ═══
    APP.audio.dolbyPanner = ctx.createPanner();
    APP.audio.dolbyPanner.panningModel = 'HRTF';
    APP.audio.dolbyPanner.distanceModel = 'inverse';
    APP.audio.dolbyPanner.refDistance = 1;
    if (APP.audio.dolbyPanner.positionX) {
        APP.audio.dolbyPanner.positionX.setValueAtTime(0, ctx.currentTime);
        APP.audio.dolbyPanner.positionY.setValueAtTime(5, ctx.currentTime);
        APP.audio.dolbyPanner.positionZ.setValueAtTime(-2, ctx.currentTime);
    }

    // ═══ Phase 2: SURROUND 5.1 SPLITTER ═══
    try {
        APP.audio.surroundSplitter = ctx.createChannelSplitter(6);
        APP.audio.surroundMerger = ctx.createChannelMerger(6);
    } catch(e) { /* 5.1 not supported */ }

    // ═══ Phase 2: Mic analyzer for ducking ═══
    APP.audio.micAnalyzer = ctx.createAnalyser();
    APP.audio.micAnalyzer.fftSize = 256;

    // Upgraded routing: Source -> Panner -> EQ -> Comp -> Ducking -> Analyzer -> MasterGain -> Limiter -> Destination
    APP.audio.source
        .connect(APP.audio.panner)
        .connect(APP.audio.lowShelf)
        .connect(APP.audio.highShelf)
        .connect(APP.audio.compressor)
        .connect(APP.audio.duckingGain)
        .connect(APP.audio.analyzer)
        .connect(APP.audio.masterGain)
        .connect(APP.audio.outputLimiter)
        .connect(ctx.destination);

    // Stereo monitoring tap
    APP.audio.masterGain.connect(APP.audio.stereoGain);

    // Dolby HRTF parallel path
    APP.audio.source.connect(APP.audio.dolbyPanner);
    APP.audio.dolbyPanner.connect(APP.audio.outputLimiter);

    APP.audio.vuData = new Uint8Array(APP.audio.analyzer.frequencyBinCount); 
    APP.audio.isConnected = true;
    log('DAW_ENGINE: TRIPLE_PATH + LIMITER + DUCKING');
    updateVU();
}

function setAudioMode(mode) {
    if(!APP.audio.ctx) return;
    const now = APP.audio.ctx.currentTime;
    clearInterval(APP.audio.spatialInterval);
    
    APP.audio.panner.positionX.value = 0;
    APP.audio.panner.positionZ.value = 0;
    APP.audio.lowShelf.gain.setTargetAtTime(0, now, 0.1);
    APP.audio.highShelf.gain.setTargetAtTime(0, now, 0.1);
    APP.audio.compressor.ratio.setTargetAtTime(1, now, 0.1); 
    
    if (mode === 'stereo') { log('AUDIO: PURE STEREO'); }
    else if (mode === 'spatial') {
        log('AUDIO: 3D ROTATION');
        let angle = 0;
        APP.audio.spatialInterval = setInterval(() => {
            angle += 0.02;
            APP.audio.panner.positionX.value = Math.sin(angle);
            APP.audio.panner.positionZ.value = Math.cos(angle);
        }, 16);
    }
    else if (mode === 'dolby') {
        log('AUDIO: DOLBY CINEMA DSP');
        APP.audio.lowShelf.gain.setTargetAtTime(4, now, 0.1);
        APP.audio.highShelf.gain.setTargetAtTime(4, now, 0.1);
        APP.audio.compressor.ratio.setTargetAtTime(12, now, 0.1);
        APP.audio.compressor.threshold.setTargetAtTime(-30, now, 0.1);
        APP.audio.compressor.attack.setTargetAtTime(0.003, now, 0.1);
    }
    
    APP.audio.spatialMode = mode;
    ['stereo', 'spatial', 'dolby'].forEach(m => {
        const btn = $(`btn-${m}`);
        if(m === mode) btn.classList.add('active-mode');
        else btn.classList.remove('active-mode');
    });
}

function updateVU() {
    requestAnimationFrame(updateVU);
    if (!APP.audio.analyzer || !APP.audio.isPlaying) return;
    APP.audio.analyzer.getByteFrequencyData(APP.audio.vuData);
    const bars = $('vu').children; 
    if(bars.length === 0) { const vu = $('vu'); for (let i = 0; i < 16; i++) { const bar = document.createElement('div'); bar.className = 'vu-bar'; vu.appendChild(bar); } }
    for (let i = 0; i < bars.length; i++) bars[i].style.height = Math.max(2, (APP.audio.vuData[i * 2] / 255) * 28) + 'px';
    
    const bass = (APP.audio.vuData[0] + APP.audio.vuData[1]) / 2;
    APP.audio.bassLevel = bass;
    
    // LIGHT PLAY (PARTY MODE)
    if(APP.vj.uiReactivity && bass > 200) {
        document.body.style.boxShadow = `inset 0 0 ${bass/2}px var(--accent)`;
    } else if (APP.vj.uiReactivity) {
        document.body.style.boxShadow = 'none';
    }
}

$('btn-save-session').onclick = () => {
    const session = { vj: APP.vj, theme: APP.state.theme, bug: APP.bug.text, layers: APP.layers, hologramScale: APP.hologram.scale, timestamp: Date.now() };
    localStorage.setItem('VNGRD_SESSION', JSON.stringify(session));
    log('RAM_SECURED');
    if(confirm("SESSION SECURED IN INTERNAL RAM.\n\nDOWNLOAD PHYSICAL BACKUP (.VGD)?")) {
        const blob = new Blob([JSON.stringify(session)], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `VNGRD_SESSION_${Date.now()}.vgd`; a.click();
        log('BACKUP_SAVED');
    }
};

// VGD FILE IMPORT
$('btn-import-dna').onclick = () => $('file-vgd').click();
$('file-vgd').onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
        try {
            const s = JSON.parse(ev.target.result);
            // Dispose existing 3D scene before importing new state
            if (APP.hologram && APP.hologram.scene) {
                if (APP.hologram.mesh) {
                    APP.hologram.scene.remove(APP.hologram.mesh);
                    APP.hologram.mesh.traverse(function(c) { if (c.isMesh) { if (c.geometry) c.geometry.dispose(); if (c.material) c.material.dispose(); } });
                }
                if (APP.hologram.renderer) APP.hologram.renderer.dispose();
                APP.hologram.mesh = null; APP.hologram.renderer = null; APP.hologram.scene = null; APP.hologram.camera = null;
            }
            // Restore state
            if (s.theme) setTheme(s.theme);
            if (s.bug) { APP.bug.text = s.bug; $('bug-text').value = s.bug; $('station-bug').textContent = s.bug; }
            if (s.vj) { APP.vj = { ...APP.vj, ...s.vj }; }
            if (s.layers) {
                APP.layers = { ...APP.layers, ...s.layers };
                APP.trinity.logo.scale = APP.layers.logoScale || 1.0;
                APP.trinity.bug.scale = APP.layers.bugScale || 1.5;
            }
            if (s.hologramScale) APP.hologram.scale = s.hologramScale;
            // Restore VJ sliders
            if ($('sl-b')) $('sl-b').value = Math.round(APP.vj.brightness * 100);
            if ($('sl-c')) $('sl-c').value = Math.round(APP.vj.contrast * 100);
            if ($('sl-s')) $('sl-s').value = Math.round(APP.vj.saturation * 100);
            if ($('sl-h')) $('sl-h').value = APP.vj.hue;
            log('VGD_IMPORTED: ' + file.name.toUpperCase());
            alert('Session restored from ' + file.name);
        } catch(err) { log('VGD_IMPORT_ERR: ' + err.message); alert('Invalid VGD file'); }
    };
    reader.readAsText(file);
    e.target.value = '';
};

function loadFromMemory() {
    const data = localStorage.getItem('VNGRD_SESSION');
    if(!data) return;
    try {
        const s = JSON.parse(data);
        if(s.theme) setTheme(s.theme);
        if(s.bug) { APP.bug.text = s.bug; $('bug-text').value = s.bug; updateBug(); }
        if(s.vj) { APP.vj = { ...APP.vj, ...s.vj }; }
        if(s.layers) { APP.layers = { ...APP.layers, ...s.layers }; APP.trinity.logo.scale = APP.layers.logoScale || 1.0; APP.trinity.bug.scale = APP.layers.bugScale || 1.5; }
        log('MEMORY_RESTORED');
    } catch(e) { log('MEMORY_CORRUPT'); }
}

function startNFTRecording() {
    if (APP.nft.isRecording) { stopNFTRecording(); return; }
    try {
        const canvasStream = APP.render.canvas.captureStream(60);
        // Mix audio into NFT recording
        if (APP.audio.ctx) {
            const nftDest = APP.audio.ctx.createMediaStreamDestination();
            if (APP.audio.masterGain) APP.audio.masterGain.connect(nftDest);
            if (APP.audio.micGainNode) APP.audio.micGainNode.connect(nftDest);
            if (nftDest.stream.getAudioTracks().length > 0) canvasStream.addTrack(nftDest.stream.getAudioTracks()[0]);
        }
        // Phase 1: 15Mbps VP9 codec enforcement
        let nftRecorderOpts = { mimeType: 'video/webm;codecs=vp9,opus', videoBitsPerSecond: 15000000, audioBitsPerSecond: 128000 };
        try { APP.nft.recorder = new MediaRecorder(canvasStream, nftRecorderOpts); }
        catch(e) { APP.nft.recorder = new MediaRecorder(canvasStream, { mimeType: 'video/webm' }); }
        APP.nft.chunks = [];
        APP.nft.recorder.ondataavailable = e => APP.nft.chunks.push(e.data);
        APP.nft.recorder.onstop = finalizeNFT;
        APP.nft.recorder.start();
        APP.nft.isRecording = true; APP.nft.startTime = Date.now();
        $('btn-nft-30').textContent = '■ STOP REC'; $('btn-nft-30').classList.add('on'); $('nft-hud').classList.add('active');
        updateNFTTimer();
        setTimeout(() => { if (APP.nft.isRecording) stopNFTRecording(); }, 30000);
        log('NFT_REC_START');
    } catch (e) { log('NFT_REC_ERR'); }
}
function stopNFTRecording() { if (!APP.nft.isRecording) return; APP.nft.recorder.stop(); APP.nft.isRecording = false; $('btn-nft-30').textContent = 'REC_30S_NFT'; $('btn-nft-30').classList.remove('on'); $('nft-hud').classList.remove('active'); log('NFT_REC_STOP'); }
function updateNFTTimer() { if (!APP.nft.isRecording) return; const elapsed = Date.now() - APP.nft.startTime; const secs = Math.floor(elapsed / 1000); $('nft-timer').textContent = `00:${String(secs).padStart(2,'0')}`; $('nft-fill').style.width = `${Math.min(100, (elapsed / 30000) * 100)}%`; requestAnimationFrame(updateNFTTimer); }
function finalizeNFT() { const blob = new Blob(APP.nft.chunks, { type: 'video/webm' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `VNGRD_NFT_${Date.now()}.webm`; a.click(); APP.nft.chunks = []; log('NFT_EXPORTED'); }
function openProjector() { if (APP.projector.isOpen) return; APP.projector.stream = APP.render.canvas.captureStream(60); APP.projector.window = window.open('', 'DRIS_Projector', 'width=1280,height=720,menubar=no,toolbar=no'); APP.projector.window.document.write('<!DOCTYPE html><html><body style="margin:0;background:#000;overflow:hidden"><video id="pf" autoplay muted playsinline style="width:100vw;height:100vh;object-fit:contain"></video><script>document.getElementById("pf").srcObject = window.opener.APP.projector.stream;<\/script></body></html>'); APP.projector.isOpen = true; $('btn-projector').classList.add('on'); log('PROJECTOR_OPEN'); }
// --- KINETIC SNAP ENGINE ---
function triggerIndustrialSnap(nextImageUrl) {
    const stage = document.getElementById('main-stage-img'); 
    if (!stage) return;

    stage.classList.remove('kinetic-shutter');
    void stage.offsetWidth; // Force CSS restart
    stage.classList.add('kinetic-shutter');

    setTimeout(() => {
        stage.src = nextImageUrl;
        log('SYSTEM: FRAME_CAPTURED');
    }, 200); 
}

// THE TRIGGER: This ensures the projector logic and snap logic coexist
if (typeof log === 'function') log('PROJECTOR_SYSTEM_LINKED');
// UI
function setTheme(theme) { document.body.className = document.body.className.replace(/theme-\w+/g, '').replace('system-failure', ''); if (theme !== 'cyan') document.body.classList.add(`theme-${theme}`); APP.state.theme = theme; document.querySelectorAll('.pal').forEach(p => p.classList.toggle('on', p.dataset.t === theme)); log(`THEME: ${theme}`); }
function toggleVHS() { document.body.classList.toggle('vhs'); $('btn-vhs').classList.toggle('on'); log('VHS'); }
function toggleCRT() { document.body.classList.toggle('crt'); $('btn-crt').classList.toggle('on'); log('CRT'); }
function toggleFullscreen() { APP.state.isFullscreen = !APP.state.isFullscreen; document.body.classList.toggle('fullscreen', APP.state.isFullscreen); $('btn-fs').classList.toggle('on', APP.state.isFullscreen); log('FULLSCREEN'); }

function morphLogo() { const logo = $('main-logo'); APP.ui.morphs.forEach(m => logo.classList.remove(m)); APP.ui.logoMorph = (APP.ui.logoMorph + 1) % APP.ui.morphs.length; logo.classList.add(APP.ui.morphs[APP.ui.logoMorph]); }
function updateClock() { $('clock').textContent = new Date().toTimeString().split(' ')[0]; const s = Math.floor((Date.now() - APP.state.startTime) / 1000); $('uptime').textContent = `${String(Math.floor(s/3600)).padStart(2,'0')}:${String(Math.floor((s%3600)/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`; }

// EMERGENCY
$('btn-panic').onclick = panicReset;
$('btn-clear-deck').onclick = clearDeck;
$('btn-eject').onclick = ejectCurrent;

// SYSTEM FAILURE MODE - Timed chaos sequence that auto-stops (5 seconds)
$('btn-psychosis').onclick = () => {
    if (APP.state.psychosis) return; // Prevent double-triggering
    
    APP.state.psychosis = true;
    document.body.classList.add('system-failure');
    $('btn-psychosis').classList.add('active-mode');
    log('CRITICAL: SYSTEM FAILURE DETECTED');
    
    // Store original states
    const origRGB = APP.vj.rgbEnabled;
    const origRGBIntensity = APP.vj.rgbIntensity;
    const origPixelate = APP.vj.pixelateEnabled;
    const origPixelSize = APP.vj.pixelSize;
    const origHue = APP.vj.hue;
    const origTrails = APP.vj.trailsEnabled;
    const origTrailAlpha = APP.vj.trailAlpha;
    
    let tick = 0;
    const totalTicks = 100; // 5 seconds at 50ms
    
    const chaos = setInterval(() => {
        tick++;
        
        // Phase 1: Hue rotation + RGB (0-35)
        if (tick <= 35) {
            APP.vj.hue = (tick * 10) % 360;
            APP.vj.rgbEnabled = true;
            APP.vj.rgbIntensity = 5 + Math.floor(Math.random() * 12);
        }
        // Phase 2: Pixelate + trails + wobble (35-70)
        else if (tick <= 70) {
            APP.vj.pixelateEnabled = tick % 3 !== 0;
            APP.vj.pixelSize = 2 + Math.floor(Math.random() * 8);
            APP.vj.trailsEnabled = true;
            APP.vj.trailAlpha = 0.65 + Math.random() * 0.25;
            // Wobble effect
            const wobbleX = Math.sin(tick * 0.4) * 10;
            const wobbleY = Math.cos(tick * 0.5) * 8;
            document.body.style.transform = `translate(${wobbleX}px, ${wobbleY}px)`;
        }
        // Phase 3: Recovery + invert flashes (70-100)
        else {
            APP.vj.rgbIntensity = Math.max(0, APP.vj.rgbIntensity - 0.8);
            APP.vj.pixelSize = Math.max(1, APP.vj.pixelSize - 0.3);
            if (tick % 5 === 0) APP.vj.invert = !APP.vj.invert;
            if (tick > 85) document.body.style.transform = '';
        }
        
        // End sequence
        if (tick >= totalTicks) {
            clearInterval(chaos);
            
            // Restore everything
            APP.vj.rgbEnabled = origRGB;
            APP.vj.rgbIntensity = origRGBIntensity;
            APP.vj.pixelateEnabled = origPixelate;
            APP.vj.pixelSize = origPixelSize;
            APP.vj.hue = origHue;
            APP.vj.trailsEnabled = origTrails;
            APP.vj.trailAlpha = origTrailAlpha;
            APP.vj.invert = false;
            document.body.style.transform = '';
            
            APP.state.psychosis = false;
            document.body.classList.remove('system-failure');
            $('btn-psychosis').classList.remove('active-mode');
            log('SYSTEM RESTORED');
        }
    }, 50);
};

$('btn-mask-mode').onclick = () => { APP.vj.maskMode = !APP.vj.maskMode; $('btn-mask-mode').classList.toggle('on'); log(`MASK_MODE: ${APP.vj.maskMode ? 'ON' : 'OFF'}`); };
$('btn-reset').onclick = () => {
    APP.vj.brightness = 1.0; $('sl-b').value = 100; $('val-b').textContent = '100%';
    APP.vj.contrast = 1.0; $('sl-c').value = 100; $('val-c').textContent = '100%';
    APP.vj.saturation = 1.0; $('sl-s').value = 100; $('val-s').textContent = '100%';
    APP.vj.hue = 0; $('sl-h').value = 0; $('val-h').textContent = '0°';
    APP.vj.trailsEnabled = false; $('btn-trails').classList.remove('on');
    APP.vj.rgbEnabled = false; $('btn-rgb').classList.remove('on');
    APP.vj.pixelateEnabled = false; $('btn-pixelate').classList.remove('on');
    APP.vj.pixelSize = 1; $('sl-pix').value = 1; $('val-pix').textContent = '1';
    APP.vj.rgbIntensity = 0; $('sl-rgb').value = 0; $('val-rgb').textContent = '0';
    APP.vj.maskMode = false; $('btn-mask-mode').classList.remove('on');
    document.body.classList.remove('vhs', 'crt', 'system-failure'); 
    $('btn-vhs').classList.remove('on'); $('btn-crt').classList.remove('on');
    log('FX_RESET_ONLY');
};


// ═══════════════════════════════════════════════════════════════════════════
// Phase 2: SIDE-CHAIN DUCKING ENGINE
// ═══════════════════════════════════════════════════════════════════════════
function initMicDucking(micStream) {
    if (!APP.audio.ctx || !micStream) return;
    try {
        APP.audio.micSource = APP.audio.ctx.createMediaStreamSource(micStream);
        APP.audio.micSource.connect(APP.audio.micAnalyzer);
        APP.audio.duckingActive = true;
        monitorDucking();
        log('DUCKING: ARMED_-20dB');
    } catch (e) { log('DUCKING_ERR: ' + e.message); }
}

function monitorDucking() {
    if (!APP.audio.duckingActive || !APP.audio.micAnalyzer) return;
    requestAnimationFrame(monitorDucking);
    const buf = new Float32Array(APP.audio.micAnalyzer.frequencyBinCount);
    APP.audio.micAnalyzer.getFloatTimeDomainData(buf);
    let sum = 0;
    for (let i = 0; i < buf.length; i++) sum += buf[i] * buf[i];
    const db = 20 * Math.log10(Math.max(Math.sqrt(sum / buf.length), 1e-10));
    const now = APP.audio.ctx.currentTime;
    // setTargetAtTime: exponential approach = zero pops/clicks in 15Mbps recording
    if (db > -20) {
        APP.audio.duckingGain.gain.setTargetAtTime(0.25, now, 0.05);
    } else {
        APP.audio.duckingGain.gain.setTargetAtTime(1.0, now, 0.15);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Phase 3: WEB3 SOVEREIGN DNA
// ═══════════════════════════════════════════════════════════════════════════
async function initWeb3() {
    try {
        if (typeof window.ethereum !== 'undefined') {
            APP.web3.provider = window.ethereum;
            // Check already-connected accounts without triggering popup
            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
            if (accounts.length > 0) {
                APP.web3.address = accounts[0];
                APP.web3.isConnected = true;
                APP.web3.mode = 'sovereign';
                APP.layerSaver.allReady = true;
                enableRecordButtons(true);
                log('WEB3: SOVEREIGN [' + APP.web3.address.slice(0, 8) + '...]');
            } else {
                APP.web3.mode = 'guest';
                log('WEB3: GUEST_MODE (CONNECT VIA WALLET BADGE)');
            }
        } else {
            APP.web3.mode = 'guest';
            log('WEB3: GUEST_MODE');
        }
    } catch (e) {
        APP.web3.mode = 'guest';
        log('WEB3: GUEST_FALLBACK');
    }
}

async function signVideoDNA(videoBlob) {
    const result = { hash: null, signature: null, timestamp: Date.now(), address: APP.web3.address || 'guest', mode: APP.web3.mode };
    try {
        const ab = await videoBlob.arrayBuffer();
        const hashBuf = await window.crypto.subtle.digest('SHA-256', ab);
        result.hash = Array.from(new Uint8Array(hashBuf)).map(b => b.toString(16).padStart(2, '0')).join('');
        if (APP.web3.mode === 'sovereign' && APP.web3.provider) {
            const msg = 'VNGRD_DNA_SEAL:' + result.hash + ':' + result.timestamp;
            result.signature = await APP.web3.provider.request({ method: 'personal_sign', params: [msg, APP.web3.address] });
            log('DNA: SEALED + ETH_SIG');
        } else {
            localStorage.setItem('vngrd_last_hash', result.hash);
            log('DNA: SEALED_SHA256 (GUEST)');
        }
    } catch (e) { log('DNA_SEAL_ERR'); }
    return result;
}

function injectDNAHeader(dna, seal) {
    if (!dna || !seal) return dna;
    dna.sovereign = {
        hash: seal.hash, signature: seal.signature, timestamp: seal.timestamp,
        address: seal.address, mode: seal.mode,
        traits: { resolution: APP.render.width + 'x' + APP.render.height, codec: 'vp9+opus', bitrate: '15Mbps', spatialMode: APP.audio.spatialMode, theme: APP.state.theme, version: 'VNGRD_23.5_SERVERLESS' }
    };
    return dna;
}

// ═══════════════════════════════════════════════════════════════════════════
// Phase 4: PODCASTER PORTAL UI + MIDI Visual/Audio Mapping
// ═══════════════════════════════════════════════════════════════════════════
function portalCamPreview() {
    // Preview is now inline in the CAMERA_4K sidebar section — no repositioning needed
    const cam = $('cam-preview-float');
    if (!cam) return;
    log('PORTAL: CAM_INLINE');
}

function triggerVisualEffect(note, velocity) {
    const i = velocity / 127;
    if (note >= 36 && note <= 39) { [impactStutter, impactInvert, impactCrush, triggerSeismic][(note - 36)]?.(); }
    else if (note >= 40 && note <= 47) { setTheme(['cyan','magenta','gold','purple','green'][(note - 40) % 5]); }
    else if (note >= 48 && note <= 59) { APP.vj.rgbIntensity = Math.round(i * 30); APP.vj.rgbEnabled = i > 0.1; }
    else if (note >= 60 && i > 0.5) { rotateMedia(); }
}

function setMidiAudioFilter(cc, value) {
    const n = value / 127;
    if (cc === 1) APP.vj.brightness = 0.2 + n * 1.8;
    else if (cc === 7 && APP.audio.masterGain) APP.audio.masterGain.gain.setValueAtTime(n, APP.audio.ctx.currentTime);
    else if (cc === 71) APP.vj.contrast = 0.2 + n * 1.8;
    else if (cc === 74) APP.vj.hue = Math.round(n * 360);
    else if (cc === 91) { APP.vj.trailAlpha = 0.8 + n * 0.19; APP.vj.trailsEnabled = n > 0.05; }
}

// ═══════════════════════════════════════════════════════════════════════════
// Phase 5: LAYER SAVER (yPodcaster Protection)
// ═══════════════════════════════════════════════════════════════════════════
async function checkLayerReadiness() {
    try {
        const [tex, font] = await Promise.all([
            Promise.resolve(!!(APP.render.canvas && APP.render.ctx)),
            document.fonts ? document.fonts.ready.then(() => true).catch(() => true) : Promise.resolve(true)
        ]);
        // Audio check: pass if ctx exists OR if wallet is connected (studio unlocked)
        const audio = !!(APP.audio.ctx && APP.audio.ctx.state !== 'closed') || (APP.wallet && APP.wallet.connected);
        APP.layerSaver.textureReady = tex;
        APP.layerSaver.fontReady = font;
        APP.layerSaver.audioReady = audio;
        APP.layerSaver.allReady = tex && font;
        if (APP.layerSaver.allReady) {
            log('LAYER_SAVER: ALL_READY');
            enableRecordButtons(true);
        } else {
            const missing = [];
            if (!tex) missing.push('TEXTURE');
            if (!font) missing.push('FONT');
            log('LAYER_SAVER: MISSING [' + missing.join(', ') + ']');
            enableRecordButtons(false);
        }
        return APP.layerSaver.allReady;
    } catch (e) { enableRecordButtons(false); return false; }
}

function enableRecordButtons(enabled) {
    ['btn-nft-30', 'btn-broadcast'].forEach(id => {
        const btn = $(id);
        if (btn) { btn.disabled = !enabled; btn.style.opacity = enabled ? '1' : '0.3'; }
    });
}

// ═══════════════════════════════════════════════════════════════════════════
// Phase 1: COMPOSITOR INTEGRATION
// ═══════════════════════════════════════════════════════════════════════════
function initCompositor() {
    if (!window.Compositor) { log('COMPOSITOR: NOT_LOADED'); return; }
    APP.compositor = new Compositor({
        width: APP.render.width,
        height: APP.render.height,
        fps: 60,
        bitrate: 15000000,
        audioBitrate: 128000
    });
    APP.compositor.setLayer('overlay', APP.render.canvas);
    if (APP.camera.stream) {
        const vid = $('preview-vid') || APP.camera.videoEl;
        if (vid) APP.compositor.setLayer('camera', vid);
    }
    // Feed hologram canvas as 3D scene
    const holoCanvas = $('hologram-canvas');
    if (holoCanvas) APP.compositor.setLayer('scene3D', holoCanvas);

    APP.compositor.initRecorder(APP.audio.ctx, APP.audio.masterGain);
    APP.compositor.onWorkerMessage((type, payload) => {
        if (type === 'STATUS') log('COMPOSITOR: ' + payload);
    });
    APP.compositor.startRecording(1000);
    log('COMPOSITOR: 15Mbps_VP9_PIPELINE_ACTIVE');
}

document.addEventListener('DOMContentLoaded', () => {
    log('DRIS//core_VNGRD_v23.5_SYSTEM_FAILURE');
    checkMobile(); initCanvas(); ghostInit(); fetchCrypto(); setInterval(fetchCrypto, 60000);
    loadFromMemory();
    // Phase 1: Initialize Compositor
    initCompositor();
    // Phase 3: Initialize Web3 (Hybrid Gate)
    initWeb3();
    // Phase 4: Portal UI
    portalCamPreview();
    // Phase 5: Layer Saver
    checkLayerReadiness();
 
    // Hide DOM overlays — Trinity actors are drawn directly on canvas
    var _sb = $('station-bug'); if (_sb) _sb.style.opacity = '0';
    var _ul = $('user-logo-layer'); if (_ul) _ul.style.opacity = '0';
    
    requestAnimationFrame(renderLoop);
    updateClock(); setInterval(updateClock, 1000); morphLogo(); setTimeout(morphLogo, 4000);
    
    // Wire UI
    $('btn-init-cam').onclick = initCamera; $('btn-go-live').onclick = goLive; $('btn-end').onclick = endLive; $('btn-kill').onclick = killCamera;
    
    // MIC TOGGLE — routes mic into broadcast recording + triggers ducking
    $('btn-mic').onclick = async () => {
        const btn = $('btn-mic');
        if (APP.camera.micStream) {
            // Turn OFF mic
            APP.camera.micStream.getTracks().forEach(t => t.stop());
            APP.camera.micStream = null;
            APP.audio.duckingActive = false;
            if (APP.audio.micGainNode) { APP.audio.micGainNode.disconnect(); APP.audio.micGainNode = null; }
            btn.classList.remove('on');
            btn.textContent = 'MIC';
            log('MIC: OFF');
            return;
        }
        try {
            if (!APP.audio.ctx) APP.audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
            APP.camera.micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, sampleRate: 48000 } });
            // Create mic source and route to audio context for monitoring + recording
            const micSource = APP.audio.ctx.createMediaStreamSource(APP.camera.micStream);
            APP.audio.micGainNode = APP.audio.ctx.createGain();
            APP.audio.micGainNode.gain.value = 1.0;
            micSource.connect(APP.audio.micGainNode);
            APP.audio.micGainNode.connect(APP.audio.ctx.destination);
            // Arm ducking
            initMicDucking(APP.camera.micStream);
            btn.classList.add('on');
            btn.textContent = 'MIC [ON]';
            log('MIC: ARMED_48kHz');
            // Re-check layer readiness with audio context now available
            checkLayerReadiness();
        } catch(e) { log('MIC_ERR: ' + e.message); }
    };
    
    // --- COMPACT MEDIA DECK WIRING ---
    $('btn-load-media').onclick = () => $('file-media').click();
    $('btn-cycle-toggle').onclick = toggleCycle;

    // Keep Navigation
    $('btn-rotate').onclick = rotateMedia; 
    $('btn-prev').onclick = previousMedia;
    $('file-media').onchange = e => loadMediaFiles(e.target);
    
    // Live Time Update
    // Cycle slider handler
    $('sl-cycle').oninput = e => {
        $('val-cycle').textContent = e.target.value + 's';
        if(APP.state.isCycle) {
            checkCycleLogic();
        }
    };
    
    // Show slider when cycle is on
    const origToggleCycle = toggleCycle;
    toggleCycle = function() {
        origToggleCycle();
        $('cycle-slider-wrap').style.display = APP.state.isCycle ? 'block' : 'none';
    };

    $('btn-lt-guest').onclick = () => showLowerThird('guest'); $('btn-lt-track').onclick = () => showLowerThird('track'); $('btn-lt-breaking').onclick = () => showLowerThird('breaking'); $('btn-lt-off').onclick = hideLowerThird;
    $('lt-title').oninput = e => { if (APP.lowerThird.visible) $('lt-title-text').textContent = e.target.value; };
    $('lt-sub').oninput = e => { if (APP.lowerThird.visible) $('lt-subtitle-text').textContent = e.target.value; };
    $('btn-audio').onclick = () => $('file-audio').click(); $('file-audio').onchange = e => loadAudioFiles(e.target);
    
    // NEW COMPACT AUDIO
    $('btn-next-track').onclick = nextTrack; 
    $('btn-prev-track').onclick = prevTrack;
    $('btn-play-pause').onclick = togglePlayPause;
    
    $('btn-stutter').onclick = impactStutter; $('btn-invert').onclick = impactInvert; $('btn-crush').onclick = impactCrush;
    $('sl-b').oninput = e => { APP.vj.brightness = e.target.value / 100; $('val-b').textContent = e.target.value + '%'; };
    $('sl-c').oninput = e => { APP.vj.contrast = e.target.value / 100; $('val-c').textContent = e.target.value + '%'; };
    $('sl-s').oninput = e => { APP.vj.saturation = e.target.value / 100; $('val-s').textContent = e.target.value + '%'; };
    $('sl-h').oninput = e => { APP.vj.hue = parseInt(e.target.value); $('val-h').textContent = e.target.value + '°'; };
    $('btn-trails').onclick = () => { APP.vj.trailsEnabled = !APP.vj.trailsEnabled; $('btn-trails').classList.toggle('on'); };
    $('btn-rgb').onclick = () => { APP.vj.rgbEnabled = !APP.vj.rgbEnabled; $('btn-rgb').classList.toggle('on'); };
    $('btn-pixelate').onclick = () => { APP.vj.pixelateEnabled = !APP.vj.pixelateEnabled; $('btn-pixelate').classList.toggle('on'); };
    $('sl-trail').oninput = e => { APP.vj.trailAlpha = parseInt(e.target.value) / 100; $('val-trail').textContent = (e.target.value / 100).toFixed(2); };
    $('sl-rgb').oninput = e => { APP.vj.rgbIntensity = parseInt(e.target.value); $('val-rgb').textContent = e.target.value; };
    $('sl-pix').oninput = e => { APP.vj.pixelSize = parseInt(e.target.value); $('val-pix').textContent = e.target.value; };
    $('btn-vhs').onclick = toggleVHS; $('btn-crt').onclick = toggleCRT; $('btn-fs').onclick = toggleFullscreen;
    document.querySelectorAll('.pal').forEach(p => p.onclick = () => setTheme(p.dataset.t));
    $('btn-projector').onclick = openProjector;
    
    // PARTY MODE TRIGGER - Rapid morphs + light effects
    $('btn-ui-react').onclick = () => { 
        APP.vj.uiReactivity = !APP.vj.uiReactivity; 
        $('btn-ui-react').classList.toggle('on');
        document.body.classList.toggle('party-active', APP.vj.uiReactivity);
        
        if (APP.vj.uiReactivity) {
            log('PARTY_MODE: ACTIVATED');
            
            // Immediate light flash (like logo click on reference)
            document.body.style.filter = 'brightness(2) contrast(1.2)';
            document.querySelectorAll('.sidebar').forEach(s => s.style.boxShadow = '0 0 30px var(--accent)');
            setTimeout(() => {
                document.body.style.filter = '';
                document.querySelectorAll('.sidebar').forEach(s => s.style.boxShadow = '');
            }, 100);
            
            // Rapid logo morph cycle (like clicking logo fast)
            let count = 0;
            const rapidMorph = setInterval(() => {
                morphLogo();
                count++;
                if (count >= 15) clearInterval(rapidMorph);
            }, 60);
            
            // Continuous light play interval
            APP.partyInterval = setInterval(() => {
                if (!APP.vj.uiReactivity) {
                    clearInterval(APP.partyInterval);
                    return;
                }
                // Random theme flashes
                if (Math.random() > 0.7) {
                    const themes = ['cyan', 'magenta', 'green', 'purple', 'gold'];
                    setTheme(themes[Math.floor(Math.random() * themes.length)]);
                }
                // Random morph
                if (Math.random() > 0.5) morphLogo();
                // Light pulse
                if (Math.random() > 0.6) {
                    document.body.style.filter = 'brightness(1.3)';
                    setTimeout(() => { document.body.style.filter = ''; }, 50);
                }
            }, 300);
        } else {
            log('PARTY_MODE: DEACTIVATED');
            if (APP.partyInterval) clearInterval(APP.partyInterval);
            document.body.style.filter = '';
        }
    };
    
    // SEISMIC TOGGLE
    $('btn-rumble').onclick = () => { 
        APP.vj.rumbleEnabled = !APP.vj.rumbleEnabled; 
        $('btn-rumble').classList.toggle('on'); 
        if (!APP.vj.rumbleEnabled) document.body.style.transform = '';
        log(APP.vj.rumbleEnabled ? "SEISMIC: ON" : "SEISMIC: OFF"); 
    };
    
    // WALLET CONNECTION (Header badge) - Real MetaMask/ETH connection
    $('wallet-badge').onclick = async () => {
        if (APP.wallet && APP.wallet.connected) {
            if (confirm('Disconnect wallet?')) {
                APP.wallet = { connected: false, address: null, chainId: null };
                $('wallet-badge').style.borderColor = 'var(--o)';
                $('wallet-badge').style.color = 'var(--o)';
                $('wallet-badge').innerHTML = '<span class="dot off"></span>WALLET';
                log('WALLET: DISCONNECTED');
            }
            return;
        }
        
        if (typeof window.ethereum === 'undefined') {
            log('NO_METAMASK');
            alert('MetaMask not detected. Please install the MetaMask browser extension from metamask.io');
            window.open('https://metamask.io/download/', '_blank');
            return;
        }
        
        try {
            // Request account access
            const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
            const address = accounts[0];
            
            // Get chain ID
            const chainId = await window.ethereum.request({ method: 'eth_chainId' });
            const chainNames = {
                '0x1': 'ETH', '0x89': 'MATIC', '0xa86a': 'AVAX', '0x38': 'BSC',
                '0xa4b1': 'ARB', '0xa': 'OP', '0x2105': 'BASE', '0xaa36a7': 'SEP'
            };
            const network = chainNames[chainId] || 'NET:' + parseInt(chainId, 16);
            
            APP.wallet = { connected: true, address, chainId };
            const short = address.slice(0, 6) + '...' + address.slice(-4);
            
            $('wallet-badge').style.borderColor = 'var(--g)';
            $('wallet-badge').style.color = 'var(--g)';
            $('wallet-badge').innerHTML = `<span class="dot" style="background:var(--g);box-shadow:0 0 6px var(--g)"></span>${network}:${short}`;
            log('WALLET: ' + network + ' ' + short); APP.layerSaver.allReady = true; enableRecordButtons(true); log('LAYER_SAVER: WALLET_UNLOCKED');
            
            // Get balance
            try {
                const balance = await window.ethereum.request({
                    method: 'eth_getBalance',
                    params: [address, 'latest']
                });
                const ethBalance = (parseInt(balance, 16) / 1e18).toFixed(4);
                log('BALANCE: ' + ethBalance + ' ' + (network === 'ETH' ? 'ETH' : 'native'));
            } catch (e) { /* Balance fetch optional */ }
            
            // Listen for account/network changes
            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length === 0) {
                    APP.wallet = { connected: false };
                    $('wallet-badge').style.borderColor = 'var(--o)';
                    $('wallet-badge').style.color = 'var(--o)';
                    $('wallet-badge').innerHTML = '<span class="dot off"></span>WALLET';
                    checkLayerReadiness();
                    log('WALLET: DISCONNECTED');
                } else {
                    const newShort = accounts[0].slice(0, 6) + '...' + accounts[0].slice(-4);
                    APP.wallet.address = accounts[0];
                    $('wallet-badge').innerHTML = `<span class="dot" style="background:var(--g);box-shadow:0 0 6px var(--g)"></span>${network}:${newShort}`;
                    log('WALLET: SWITCHED TO ' + newShort);
                }
            });
            
            window.ethereum.on('chainChanged', (newChainId) => {
                const newNetwork = chainNames[newChainId] || 'NET:' + parseInt(newChainId, 16);
                APP.wallet.chainId = newChainId;
                const short = APP.wallet.address.slice(0, 6) + '...' + APP.wallet.address.slice(-4);
                $('wallet-badge').innerHTML = `<span class="dot" style="background:var(--g);box-shadow:0 0 6px var(--g)"></span>${newNetwork}:${short}`;
                log('NETWORK: SWITCHED TO ' + newNetwork);
            });
            
        } catch (e) {
            if (e.code === 4001) {
                log('WALLET: USER REJECTED');
            } else {
                log('WALLET ERROR: ' + e.message);
            }
        }
    };
    
    $('btn-stereo').onclick = () => setAudioMode('stereo');
    $('btn-spatial').onclick = () => setAudioMode('spatial');
    $('btn-dolby').onclick = () => setAudioMode('dolby');

    // LOGO CLICK INTERACTION - Light flash + morph (like reference site)
    $('main-logo').onmousedown = () => {
        // Light flash effect
        document.body.style.filter = 'brightness(2) contrast(1.2)';
        document.querySelectorAll('.sidebar').forEach(s => s.style.boxShadow = '0 0 30px var(--accent)');
        setTimeout(() => {
            document.body.style.filter = '';
            document.querySelectorAll('.sidebar').forEach(s => s.style.boxShadow = '');
        }, 100);
        
        // Morph logo
        morphLogo();
    };

    // Final UI and Input Handlers
    document.addEventListener('keydown', e => {
        if (e.target.tagName === 'INPUT') return;
        if (e.key === 'g' || e.key === 'G') toggleGhost();
        if (e.key === 'h' || e.key === 'H') toggleFullscreen();
        if (e.key === 'Escape') { $('btn-panic').click(); } 
        if (e.key === ' ') { e.preventDefault(); rotateMedia(); }
    });

    // Ensure uploaded logos are interactable
    $('file-layer-logo').onchange = e => { 
        if (e.target.files.length) { 
            const url = URL.createObjectURL(e.target.files[0]); 
            const img = $('user-logo-layer');
            img.src = url; 
            img.style.display = 'block'; 
            img.style.pointerEvents = 'auto'; 
            log('IDENTITY_LAYER_LOADED');
        } 
    };

    // ========================================
    // MIDI_HOST WITH LEARN MODE & PASSTHROUGH
    // ========================================
    
    // MIDI LEARN MODE - Click element + hit MIDI to bind
    if ($('btn-midi-learn')) {
        $('btn-midi-learn').onclick = () => {
            APP.midi.learnMode = !APP.midi.learnMode;
            document.body.classList.toggle('midi-learn-active', APP.midi.learnMode);
            $('btn-midi-learn').textContent = APP.midi.learnMode ? 'LEARN MODE: ON' : 'LEARN MODE: OFF';
            $('btn-midi-learn').classList.toggle('on', APP.midi.learnMode);
            log('MIDI_LEARN: ' + (APP.midi.learnMode ? 'ACTIVE' : 'OFF'));
            
            if (APP.midi.learnMode) {
                // Add click listeners to learnable elements
                document.querySelectorAll('[data-midi-target]').forEach(el => {
                    el.addEventListener('click', midiLearnClick);
                });
            } else {
                document.querySelectorAll('[data-midi-target]').forEach(el => {
                    el.removeEventListener('click', midiLearnClick);
                });
                APP.midi.learnTarget = null;
            }
        };
    }
    
    function midiLearnClick(e) {
        if (!APP.midi.learnMode) return;
        e.preventDefault();
        e.stopPropagation();
        
        const target = e.currentTarget.dataset.midiTarget;
        APP.midi.learnTarget = { element: e.currentTarget, target: target };
        log('MIDI_LEARN: Waiting for MIDI input for ' + target.toUpperCase());
        e.currentTarget.style.outline = '2px solid var(--v)';
    }
    
    // INSTRUMENT PASSTHROUGH - Synthesizer
    if ($('btn-midi-passthru')) {
        $('btn-midi-passthru').onclick = () => {
            APP.midi.passthrough = !APP.midi.passthrough;
            $('btn-midi-passthru').textContent = APP.midi.passthrough ? 'INSTRUMENT: ON' : 'INSTRUMENT: OFF';
            $('btn-midi-passthru').classList.toggle('on', APP.midi.passthrough);
            log('MIDI_INSTRUMENT: ' + (APP.midi.passthrough ? 'ACTIVE' : 'OFF'));
            
            // Initialize synth context
            if (APP.midi.passthrough && !APP.midi.synthCtx) {
                APP.midi.synthCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
                APP.midi.synthGain = APP.midi.synthCtx.createGain();
                APP.midi.synthGain.connect(APP.midi.synthCtx.destination);
            }
        };
    }
    
    // Play synthesized note
    function playSynthNote(note, velocity) {
        if (!APP.midi.passthrough || !APP.midi.synthCtx) return;
        
        const freq = 440 * Math.pow(2, (note - 69) / 12); // MIDI to frequency
        const osc = APP.midi.synthCtx.createOscillator();
        const gain = APP.midi.synthCtx.createGain();
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        const vol = (velocity / 127) * 0.3;
        gain.gain.setValueAtTime(vol, APP.midi.synthCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, APP.midi.synthCtx.currentTime + 0.5);
        
        osc.connect(gain);
        gain.connect(APP.midi.synthGain);
        osc.start();
        osc.stop(APP.midi.synthCtx.currentTime + 0.5);
    }
    
    // --- MIDI CONTROLLER ---
    $('btn-midi').onclick = async () => {
        if (!navigator.requestMIDIAccess) {
            log('WEBMIDI_NOT_SUPPORTED');
            alert('WebMIDI not supported in this browser. Try Chrome or Edge.');
            return;
        }
        
        try {
            const midiAccess = await navigator.requestMIDIAccess({ sysex: false });
            APP.midi.access = midiAccess;
            APP.midi.inputs = [];
            APP.midi.outputs = [];
            
            const inputs = Array.from(midiAccess.inputs.values());
            const outputs = Array.from(midiAccess.outputs.values());
            
            if (inputs.length === 0) {
                log('NO_MIDI_DEVICES');
                alert('No MIDI devices found. Connect a MIDI controller and try again.');
                return;
            }
            
            log('MIDI: ' + inputs.length + ' inputs, ' + outputs.length + ' outputs');
            $('btn-midi').classList.add('on');
            $('btn-midi').textContent = 'MIDI ACTIVE';
            $('midi-status').textContent = inputs[0].name;
            $('midi-status').style.color = 'var(--g)';
            if ($('midi-dot')) $('midi-dot').classList.remove('off');
            
            // Handle MIDI input messages
            inputs.forEach(input => {
                APP.midi.inputs.push(input);
                input.onmidimessage = (msg) => {
                    const [status, note, velocity] = msg.data;
                    const cmd = status >> 4;
                    const channel = status & 0x0F;
                    
                    // MIDI LEARN - Bind to waiting target
                    if (APP.midi.learnMode && APP.midi.learnTarget && velocity > 0) {
                        const key = (cmd === 11) ? 'cc' + note : 'note' + note;
                        APP.midi.bindings[key] = {
                            element: APP.midi.learnTarget.element,
                            target: APP.midi.learnTarget.target,
                            type: (cmd === 11) ? 'cc' : 'note'
                        };
                        APP.midi.learnTarget.element.classList.add('midi-bound');
                        APP.midi.learnTarget.element.style.outline = '';
                        updateMidiBindingsDisplay();
                        log('MIDI_BOUND: ' + key + ' -> ' + APP.midi.learnTarget.target);
                        APP.midi.learnTarget = null;
                        return;
                    }
                    
                    // Note On (cmd 9) with velocity > 0
                    if (cmd === 9 && velocity > 0) {
                        // INSTRUMENT PASSTHROUGH
                        if (APP.midi.passthrough) {
                            playSynthNote(note, velocity);
                        }
                        
                        // Check for learned binding
                        const binding = APP.midi.bindings['note' + note];
                        if (binding) {
                            triggerMidiBinding(binding, velocity);
                        }
                        
                        // KINETIC TRIGGERS - Velocity scales impact
                        const intensity = velocity / 127;
                        
                        // Drum pads / low notes - trigger DIEGETIC DESTRUCTION
                        if (note < 48) {
                            // Scale impact with velocity
                            if (APP.shooting.active && typeof fireWeaponAt === 'function') {
                                const x = Math.random() * window.innerWidth;
                                const y = Math.random() * window.innerHeight;
                                fireWeaponAt(x, y, intensity);
                            }
                            
                            // Seismic shake scaled to velocity
                            const shake = intensity * 30;
                            document.body.style.transform = `translate(${(Math.random()-0.5)*shake}px, ${(Math.random()-0.5)*shake}px)`;
                            setTimeout(() => document.body.style.transform = '', 50);
                        }
                        
                        // Higher notes - trigger effects
                        if (velocity > 80) {
                            if (note >= 60 && note < 64) impactStutter();
                            else if (note >= 64 && note < 68) impactInvert();
                            else if (note >= 68 && note < 72) impactCrush();
                            else if (note >= 72) { rotateMedia(); triggerImpact(); }
                        }
                        
                        // Theme changes on specific notes
                        if (note === 36) setTheme('cyan');
                        if (note === 37) setTheme('magenta');
                        if (note === 38) setTheme('green');
                        if (note === 39) setTheme('purple');
                        if (note === 40) setTheme('gold');
                    }
                    
                    // Note Off - stop synth
                    if (cmd === 8 || (cmd === 9 && velocity === 0)) {
                        // Note off handling if needed
                    }
                    
                    // Control Change (cmd 11) - sliders/knobs - MIDI OVERRIDE
                    if (cmd === 11) {
                        const val = velocity / 127;
                        APP.atmosphere.midiOverride = true;
                        
                        // Check for learned binding
                        const binding = APP.midi.bindings['cc' + note];
                        if (binding) {
                            triggerMidiCCBinding(binding, val);
                        }
                        
                        // Default CC mappings
                        if (note === 1 || note === 74) { APP.vj.brightness = 0.5 + val; $('sl-b').value = APP.vj.brightness * 100; $('val-b').textContent = Math.round(APP.vj.brightness*100)+'%'; }
                        if (note === 2 || note === 71) { APP.vj.contrast = 0.5 + val; $('sl-c').value = APP.vj.contrast * 100; }
                        if (note === 3 || note === 76) { APP.vj.saturation = val * 2; $('sl-s').value = APP.vj.saturation * 100; }
                        if (note === 4 || note === 77) { APP.vj.hue = val * 360; $('sl-h').value = APP.vj.hue; }
                        // Rain/Heat via MIDI
                        if (note === 20) { APP.atmosphere.intensity = val * 100; $('sl-atmos').value = val * 100; $('val-atmos').textContent = Math.round(val*100)+'%'; }
                        if (note === 21) { APP.atmosphere.heatIntensity = val * 100; $('sl-heat').value = val * 100; $('val-heat').textContent = Math.round(val*100)+'%'; }
                    }
                    
                    // Pitch Bend - control hue
                    if (cmd === 14) {
                        const bend = ((velocity << 7) | note) - 8192;
                        APP.vj.hue = (bend / 8192) * 180 + 180;
                    }
                };
            });
            
            // Store outputs
            outputs.forEach(output => APP.midi.outputs.push(output));
            
        } catch (e) {
            log('MIDI_ERROR: ' + e.message);
            alert('MIDI access denied: ' + e.message);
        }
    };
    
    function triggerMidiBinding(binding, velocity) {
        const el = binding.element;
        const target = binding.target;
        const intensity = velocity / 127;
        
        switch(target) {
            case 'stutter': impactStutter(); break;
            case 'invert': impactInvert(); break;
            case 'crush': impactCrush(); break;
            case 'shatter': if (typeof createGlassFracture === 'function') createGlassFracture(window.innerWidth/2, window.innerHeight/2); break;
            case 'lens-drip': el.click(); break;
            case 'heat-haze': el.click(); break;
            default: if (el.click) el.click();
        }
    }
    
    function triggerMidiCCBinding(binding, val) {
        const el = binding.element;
        const target = binding.target;
        
        if (el.tagName === 'INPUT' && el.type === 'range') {
            const min = parseFloat(el.min);
            const max = parseFloat(el.max);
            el.value = min + (max - min) * val;
            el.dispatchEvent(new Event('input'));
        }
    }
    
    function updateMidiBindingsDisplay() {
        const container = $('midi-bindings');
        if (!container) return;
        
        const bindings = Object.entries(APP.midi.bindings);
        if (bindings.length === 0) {
            container.textContent = '';
            return;
        }
        
        container.innerHTML = bindings.map(([key, val]) => `${key}:${val.target}`).join(' | ');
    }

    // --- WebXR VR MODE ---
    $('btn-vr').onclick = async () => {
        if (!navigator.xr) {
            log('WEBXR_NOT_SUPPORTED');
            alert('WebXR not supported. Try a VR-capable browser like Oculus Browser, Firefox Reality, or Chrome with a VR headset.');
            return;
        }
        
        try {
            const supported = await navigator.xr.isSessionSupported('immersive-vr');
            if (!supported) {
                // Try inline mode for phones/cardboard
                const inlineSupported = await navigator.xr.isSessionSupported('inline');
                if (inlineSupported) {
                    log('VR: Inline mode available');
                    alert('Full VR not available. For phone VR, open in a WebXR-compatible browser.');
                } else {
                    log('NO_VR_SUPPORT');
                    alert('No VR headset detected. Connect a VR device and try again.');
                }
                return;
            }
            
            log('VR: Starting immersive session');
            $('btn-vr').classList.add('on');
            $('btn-vr').textContent = 'EXIT VR';
            
            const session = await navigator.xr.requestSession('immersive-vr', {
                requiredFeatures: ['local-floor'],
                optionalFeatures: ['bounded-floor', 'hand-tracking']
            });
            
            APP.vr = { session, active: true };
            
            // Create WebGL context for VR
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl2', { xrCompatible: true });
            
            await gl.makeXRCompatible();
            
            const baseLayer = new XRWebGLLayer(session, gl);
            session.updateRenderState({ baseLayer });
            
            const refSpace = await session.requestReferenceSpace('local-floor');
            
            // VR render loop
            session.requestAnimationFrame(function vrLoop(time, frame) {
                if (!APP.vr.active) return;
                
                session.requestAnimationFrame(vrLoop);
                
                const pose = frame.getViewerPose(refSpace);
                if (pose) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, baseLayer.framebuffer);
                    
                    for (const view of pose.views) {
                        const viewport = baseLayer.getViewport(view);
                        gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
                        
                        // Draw the VJ canvas content to VR
                        gl.clearColor(0, 0, 0, 1);
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        
                        // Copy canvas to WebGL texture
                        const texture = gl.createTexture();
                        gl.bindTexture(gl.TEXTURE_2D, texture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, APP.render.canvas);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                }
            });
            
            session.addEventListener('end', () => {
                APP.vr.active = false;
                $('btn-vr').classList.remove('on');
                $('btn-vr').textContent = 'ENTER VR';
                log('VR: Session ended');
            });
            
        } catch (e) {
            log('VR_ERROR: ' + e.message);
            $('btn-vr').classList.remove('on');
            $('btn-vr').textContent = 'ENTER VR';
        }
    };

    // --- NFT RECORDING ---
    $('btn-nft-30').onclick = startNFTRecording;

    // ========================================
    // ========================================
    // KINETIC_MATERIAL_IMPACTS + WEAPON_STATE_ISOLATION
    // STRUCTURAL_INTEGRITY + ACOUSTIC_SYNTHESIS
    // ========================================
    
    // ACOUSTIC SYNTHESIS - NO EXTERNAL FILES
    function getAudioCtx() {
        if (!APP.shooting.audioCtx) {
            APP.shooting.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        return APP.shooting.audioCtx;
    }
    
    // GLASS SHATTER: High-pitch 3800Hz sine snap
    function playGlassShatter() {
        const ctx = getAudioCtx();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(3800, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1800, ctx.currentTime + 0.05);
        
        gain.gain.setValueAtTime(0.5, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);
        
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + 0.1);
    }
    
    // METAL TINK: Short 1600Hz square wave
    function playMetalTink() {
        const ctx = getAudioCtx();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        
        osc.type = 'square';
        osc.frequency.setValueAtTime(1600, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + 0.03);
        
        gain.gain.setValueAtTime(0.25, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.06);
        
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + 0.08);
    }
    
    // TERMINAL SMASH: Filtered white noise + 5kHz-to-200Hz sweep
    function playTerminalSmash() {
        const ctx = getAudioCtx();
        
        // White noise
        const bufferSize = ctx.sampleRate * 0.5;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        
        const noise = ctx.createBufferSource();
        noise.buffer = buffer;
        
        // Filter sweep
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(5000, ctx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.4);
        filter.Q.value = 5;
        
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.6, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(ctx.destination);
        noise.start(ctx.currentTime);
        noise.stop(ctx.currentTime + 0.5);
        
        // Impact sweep
        const osc = ctx.createOscillator();
        const oscGain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(200, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(40, ctx.currentTime + 0.3);
        oscGain.gain.setValueAtTime(0.5, ctx.currentTime);
        oscGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
        osc.connect(oscGain);
        oscGain.connect(ctx.destination);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + 0.35);
    }
    
   
    
    // STRUCTURAL INTEGRITY SYSTEM
    function updateIntegrityBar() {
        const bar = $('integrity-bar');
        const fill = $('integrity-fill');
        const text = $('integrity-text');
        
        if (!bar || !fill || !text) return;
        
        bar.classList.add('active');
        fill.style.width = APP.glassIntegrity + '%';
        text.textContent = 'INTEGRITY: ' + APP.glassIntegrity + '%';
        
        // Color based on integrity
        if (APP.glassIntegrity > 60) {
            fill.style.background = 'linear-gradient(90deg, var(--g) 0%, var(--g) 100%)';
        } else if (APP.glassIntegrity > 30) {
            fill.style.background = 'linear-gradient(90deg, var(--y) 0%, var(--y) 100%)';
        } else {
            fill.style.background = 'linear-gradient(90deg, var(--r) 0%, var(--r) 100%)';
        }
    }
    
    function triggerTerminalShatter() {
        APP.lensShattered = true;
        document.body.classList.add('lens-shattered');
        playTerminalSmash();
        
        // All fractures fall off screen
        APP.shooting.fractures.forEach(f => {
            f.style.animation = 'fracture-fall 1s forwards';
        });
        
        log('TERMINAL_SHATTER: LENS_FAILURE');
        
        setTimeout(() => {
            $('glass-fracture-layer').innerHTML = '';
            APP.shooting.fractures = [];
        }, 1000);
    }
    
    function repairLens() {
        if (!APP.lensShattered && APP.glassIntegrity >= 100) return;
        
        playHydraulicHiss();
        APP.glassIntegrity = 100;
        APP.lensShattered = false;
        document.body.classList.remove('lens-shattered');
        updateIntegrityBar();
        
        // Clear all damage
        APP.shooting.bullets.forEach(b => b.remove());
        APP.shooting.bullets = [];
        APP.shooting.fractures.forEach(f => f.remove());
        APP.shooting.fractures = [];
        APP.shooting.dents.forEach(d => d.classList.remove('dented'));
        APP.shooting.dents = [];
        $('glass-fracture-layer').innerHTML = '';
        
        log('LENS_REPAIR: INTEGRITY_RESTORED');
        
        setTimeout(() => {
            if (!APP.shooting.active) {
                $('integrity-bar').classList.remove('active');
            }
        }, 2000);
    }
    
    function startRepairTimer() {
        if (APP.shooting.repairTimer) {
            clearTimeout(APP.shooting.repairTimer);
        }
        APP.shooting.repairTimer = setTimeout(() => {
            if (APP.glassIntegrity < 100 || APP.lensShattered) {
                repairLens();
            }
        }, 15000); // 15 second auto-repair
    }
    
    // GLASS FRACTURE WITH 20S PURGE
    function createGlassFracture(x, y) {
        const stage = $('stage');
        const rect = stage.getBoundingClientRect();
        const localX = x - rect.left;
        const localY = y - rect.top;
        
        const fracture = document.createElement('div');
        fracture.className = 'glass-fracture';
        fracture.style.left = localX + 'px';
        fracture.style.top = localY + 'px';
        
        const numCracks = 5 + Math.floor(Math.random() * 6);
        let svg = '<svg width="100" height="100" style="position:absolute;left:-50px;top:-50px;mix-blend-mode:lighter;">';
        
        for (let i = 0; i < numCracks; i++) {
            const angle = (i / numCracks) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
            const len = 20 + Math.random() * 35;
            let path = `M50,50 `;
            let cx = 50, cy = 50;
            const segments = 3 + Math.floor(Math.random() * 3);
            
            for (let s = 0; s < segments; s++) {
                const segLen = len / segments;
                const jitter = (Math.random() - 0.5) * 12;
                cx += Math.cos(angle + jitter * 0.1) * segLen;
                cy += Math.sin(angle + jitter * 0.1) * segLen;
                path += `L${cx.toFixed(1)},${cy.toFixed(1)} `;
            }
            
            svg += `<path d="${path}" class="fracture-glow" fill="none"/>`;
            svg += `<path d="${path}" class="fracture-line" fill="none"/>`;
        }
        
        svg += '<circle cx="50" cy="50" r="4" fill="rgba(255,255,255,0.9)" filter="blur(2px)"/>';
        svg += '<circle cx="50" cy="50" r="2" fill="#fff"/>';
        svg += '</svg>';
        
        fracture.innerHTML = svg;
        $('glass-fracture-layer').appendChild(fracture);
        APP.shooting.fractures.push(fracture);
        
        playGlassShatter();
        
        // 20S MEMORY PURGE
        setTimeout(() => {
            fracture.style.opacity = '0';
            fracture.style.transition = 'opacity 0.5s';
            setTimeout(() => {
                fracture.remove();
                const idx = APP.shooting.fractures.indexOf(fracture);
                if (idx > -1) APP.shooting.fractures.splice(idx, 1);
            }, 500);
        }, 20000);
    }
    
    // METAL DENT
    function createMetalDent(el) {
        if (!el.classList.contains('dented')) {
            el.classList.add('dented');
            APP.shooting.dents.push(el);
        }
        playMetalTink();
    }
    
    // BULLET HOLE WITH 20S PURGE
    function createBulletHole(x, y) {
        const hole = document.createElement('div');
        hole.className = 'bullet-hole';
        hole.style.left = (x - 10) + 'px';
        hole.style.top = (y - 10) + 'px';
        document.body.appendChild(hole);
        APP.shooting.bullets.push(hole);
        
        const smoke = document.createElement('div');
        smoke.className = 'smoke-puff';
        smoke.style.left = (x - 20) + 'px';
        smoke.style.top = (y - 20) + 'px';
        document.body.appendChild(smoke);
        setTimeout(() => smoke.remove(), 1500);
        
        // 20S PURGE
        setTimeout(() => {
            hole.style.opacity = '0';
            hole.style.transition = 'opacity 0.5s';
            setTimeout(() => {
                hole.remove();
                const idx = APP.shooting.bullets.indexOf(hole);
                if (idx > -1) APP.shooting.bullets.splice(idx, 1);
            }, 500);
        }, 20000);
    }
    
    // FIRE WEAPON - CORE FUNCTION WITH THROTTLE AND INTEGRITY
    function fireWeapon(x, y) {
        // 100MS THROTTLE
        const now = Date.now();
        if (now - APP.shooting.lastFireTime < APP.shooting.fireThrottle) return;
        APP.shooting.lastFireTime = now;
        
        // INTEGRITY DAMAGE
        APP.glassIntegrity = Math.max(0, APP.glassIntegrity - 2);
        updateIntegrityBar();
        startRepairTimer();
        
        // Check for terminal shatter
        if (APP.glassIntegrity <= 0 && !APP.lensShattered) {
            triggerTerminalShatter();
            return;
        }
        
        const stage = $('stage');
        const stageRect = stage.getBoundingClientRect();
        const target = document.elementFromPoint(x, y);
        
        // Material detection
        const isGlass = x >= stageRect.left && x <= stageRect.right &&
                        y >= stageRect.top && y <= stageRect.bottom;
        
        const isMetal = target && (
            target.classList.contains('btn') ||
            target.closest('.sidebar') ||
            target.closest('#top-bar') ||
            target.closest('#bottom-bar')
        );
        
        if (isGlass && !isMetal) {
            createGlassFracture(x, y);
        } else if (isMetal) {
            const metalEl = target.classList.contains('btn') ? target : 
                           (target.closest('.sidebar') || target.closest('#top-bar') || target.closest('#bottom-bar'));
            if (metalEl) createMetalDent(metalEl);
            createBulletHole(x, y);
        } else {
            createBulletHole(x, y);
            playMetalTink();
        }
        
        // Screen shake
        document.body.style.transform = `translate(${(Math.random()-0.5)*8}px, ${(Math.random()-0.5)*8}px)`;
        setTimeout(() => document.body.style.transform = '', 40);
    }
    
    // WEAPON STATE ISOLATION - GLOBAL CAPTURE PHASE LISTENER
    function weaponGlobalInterceptor(e) {
        if (!APP.shooting.active) return;
        
        // Allow clicking the weapon toggle button
        const target = e.target;
        if (target.id === 'btn-shooting' || target.closest('#btn-shooting')) {
            return; // Let the click through
        }
        
        // PREVENT ALL OTHER CLICKS - Complete input safety
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        
        // Fire weapon at click location
        fireWeapon(e.clientX, e.clientY);
    }
    
    // MACHINE GUN - 100MS RAPID FIRE ON MOUSEDOWN
    let machineGunActive = false;
    
    function startMachineGun(e) {
        if (!APP.shooting.active) return;
        
        const target = e.target;
        if (target.id === 'btn-shooting' || target.closest('#btn-shooting')) {
            return;
        }
        
        e.preventDefault();
        machineGunActive = true;
        APP.shooting.lastX = e.clientX;
        APP.shooting.lastY = e.clientY;
        
        fireWeapon(e.clientX, e.clientY);
        
        APP.shooting.machineGunInterval = setInterval(() => {
            if (machineGunActive && APP.shooting.active) {
                const jitterX = APP.shooting.lastX + (Math.random() - 0.5) * 20;
                const jitterY = APP.shooting.lastY + (Math.random() - 0.5) * 20;
                fireWeapon(jitterX, jitterY);
            }
        }, 100);
    }
    
    function stopMachineGun() {
        machineGunActive = false;
        if (APP.shooting.machineGunInterval) {
            clearInterval(APP.shooting.machineGunInterval);
            APP.shooting.machineGunInterval = null;
        }
    }
    
    function trackMouse(e) {
        APP.shooting.lastX = e.clientX;
        APP.shooting.lastY = e.clientY;
    }
    
    $('btn-shooting').onclick = () => {
        APP.shooting.active = !APP.shooting.active;
        $('btn-shooting').classList.toggle('on', APP.shooting.active);
        document.body.classList.toggle('shooting-mode', APP.shooting.active);
        
        if (APP.shooting.active) {
            log('MACHINE_GUN: ARMED');
            updateIntegrityBar();
            
            // WEAPON STATE ISOLATION - Capture phase for complete input safety
            window.addEventListener('click', weaponGlobalInterceptor, true);
            document.addEventListener('mousemove', trackMouse);
            document.addEventListener('mousedown', startMachineGun);
            document.addEventListener('mouseup', stopMachineGun);
            
        } else {
            stopMachineGun();
            window.removeEventListener('click', weaponGlobalInterceptor, true);
            document.removeEventListener('mousemove', trackMouse);
            document.removeEventListener('mousedown', startMachineGun);
            document.removeEventListener('mouseup', stopMachineGun);
            
            // Clear repair timer but keep damage visible
            if (APP.shooting.repairTimer) {
                clearTimeout(APP.shooting.repairTimer);
                APP.shooting.repairTimer = null;
            }
            
            // Hide integrity bar after delay
            setTimeout(() => {
                if (!APP.shooting.active) {
                    $('integrity-bar').classList.remove('active');
                }
            }, 3000);
            
            log('MACHINE_GUN: OFF');
        }
    };

    // --- P2P / E2E CALL ---
    $('btn-init-peer').onclick = () => {
        if (APP.peer && APP.peer.peer) {
            log('PEER: Already initialized');
            return;
        }
        
        try {
            const peerId = 'VNGRD-' + Math.random().toString(36).substr(2, 8).toUpperCase();
            APP.peer = {
                peer: new Peer(peerId),
                call: null,
                localStream: null
            };
            
            APP.peer.peer.on('open', (id) => {
                $('peer-id-display').value = id;
                $('guest-dot').classList.remove('off');
                $('call-status').textContent = 'Ready to call';
                $('call-status').style.color = 'var(--g)';
                log('PEER: ' + id);
            });
            
            APP.peer.peer.on('error', (err) => {
                log('PEER ERROR: ' + err.type);
                $('call-status').textContent = 'Error: ' + err.type;
                $('call-status').style.color = 'var(--r)';
            });
            
            // Handle incoming calls - FIXED: Use selected INPUT_SIGNAL deviceId
            APP.peer.peer.on('call', async (call) => {
                log('INCOMING_CALL FROM ' + call.peer);
                $('call-status').textContent = 'INCOMING_CALL...';
                
                if (confirm('INCOMING_CALL FROM ' + call.peer + '. ACCEPT?')) {
                    try {
                        // Use selected audio input device if available
                        const audioConstraints = APP.inputDevices.selectedId 
                            ? { deviceId: { exact: APP.inputDevices.selectedId } }
                            : true;
                        
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            video: true, 
                            audio: audioConstraints 
                        });
                        APP.peer.localStream = stream;
                        call.answer(stream);
                        
                        call.on('stream', (remoteStream) => {
                            if (!APP.guest.videoElement) {
                                APP.guest.videoElement = document.createElement('video');
                                APP.guest.videoElement.autoplay = true;
                                APP.guest.videoElement.playsInline = true;
                                APP.guest.videoElement.muted = false;
                            }
                            APP.guest.videoElement.srcObject = remoteStream;
                            APP.guest.stream = remoteStream;
                            APP.guest.isActive = true;
                            
                            $('call-status').textContent = 'IN_CALL: ' + call.peer;
                            $('call-status').style.color = 'var(--g)';
                            log('CALL_CONNECTED');
                        });
                        
                        APP.peer.call = call;
                    } catch (e) {
                        log('MEDIA ERROR: ' + e.message);
                    }
                } else {
                    log('CALL REJECTED');
                }
            });
            
        } catch (e) {
            log('PEER INIT ERROR: ' + e.message);
        }
    };
    
    $('btn-copy-id').onclick = () => {
        const id = $('peer-id-display').value;
        if (id) {
            navigator.clipboard.writeText(id);
            $('btn-copy-id').textContent = '✓ COPIED';
            setTimeout(() => $('btn-copy-id').textContent = 'COPY_ID', 2000);
        }
    };
    
    $('btn-call-guest').onclick = async () => {
        if (!APP.peer || !APP.peer.peer) {
            alert('CLICK_INIT_FIRST');
            return;
        }
        
        const remoteId = $('remote-peer-id').value.trim();
        if (!remoteId) {
            alert('ENTER_GUEST_ID_TO_CALL');
            return;
        }
        
        try {
            $('call-status').textContent = 'CALLING...';
            $('call-status').style.color = 'var(--y)';
            
            // Use selected audio input device if available
            const audioConstraints = APP.inputDevices.selectedId 
                ? { deviceId: { exact: APP.inputDevices.selectedId } }
                : true;
            
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: true, 
                audio: audioConstraints 
            });
            APP.peer.localStream = stream;
            
            const call = APP.peer.peer.call(remoteId, stream);
            
            call.on('stream', (remoteStream) => {
                if (!APP.guest.videoElement) {
                    APP.guest.videoElement = document.createElement('video');
                    APP.guest.videoElement.autoplay = true;
                    APP.guest.videoElement.playsInline = true;
                }
                APP.guest.videoElement.srcObject = remoteStream;
                APP.guest.stream = remoteStream;
                APP.guest.isActive = true;
                
                $('call-status').textContent = 'CONNECTED: ' + remoteId;
                $('call-status').style.color = 'var(--g)';
                log('CALL_CONNECTED: ' + remoteId);
            });
            
            call.on('close', () => {
                log('CALL_ENDED');
                $('call-status').textContent = 'CALL_ENDED';
                APP.guest.isActive = false;
            });
            
            call.on('error', (err) => {
                log('CALL_ERROR: ' + err);
                $('call-status').textContent = 'CALL_FAILED';
                $('call-status').style.color = 'var(--r)';
            });
            
            APP.peer.call = call;
            
        } catch (e) {
            log('CALL_ERROR: ' + e.message);
            $('call-status').textContent = 'FAILED: ' + e.message;
            $('call-status').style.color = 'var(--r)';
        }
    };
    
    $('btn-hangup').onclick = () => {
        if (APP.peer && APP.peer.call) {
            APP.peer.call.close();
        }
        if (APP.peer && APP.peer.localStream) {
            APP.peer.localStream.getTracks().forEach(t => t.stop());
        }
        APP.guest.isActive = false;
        APP.guest.stream = null;
        $('call-status').textContent = 'DISCONNECTED';
        $('call-status').style.color = 'var(--text-dim)';
        log('CALL_ENDED');
    };

    // ========================================
    // ========================================
    // PRO-AUDIO: 48KHZ RAW DIRECT PATH
    // NO ECHO/NOISE PROCESSING
    // ========================================
    async function scanAudioInputDevices() {
        try {
            // Request permission with basic constraints first
            await navigator.mediaDevices.getUserMedia({ audio: true });
            
            const devices = await navigator.mediaDevices.enumerateDevices();
            const audioInputs = devices.filter(d => d.kind === 'audioinput');
            
            APP.inputDevices.list = audioInputs;
            
            const select = $('audio-input-select');
            select.innerHTML = '<option value="">SELECT_DEVICE...</option>';
            
            audioInputs.forEach((device, idx) => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.textContent = device.label || `INPUT_${idx + 1}`;
                select.appendChild(option);
            });
            
            log('SCAN: ' + audioInputs.length + ' AUDIO_INPUTS');
            return audioInputs;
        } catch (e) {
            log('SCAN_ERROR: ' + e.message);
            return [];
        }
    }
    
    // 48KHZ RAW DIRECT PATH - DISABLE ALL BROWSER PROCESSING
    async function switchAudioInput(deviceId) {
        if (APP.inputDevices.stream) {
            APP.inputDevices.stream.getTracks().forEach(t => t.stop());
        }
        
        try {
            // PRO-AUDIO CONSTRAINTS: 48kHz, NO PROCESSING
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    deviceId: { exact: deviceId },
                    sampleRate: { ideal: 48000 },
                    sampleSize: { ideal: 24 },
                    channelCount: { ideal: 2 },
                    // DISABLE ALL BROWSER PROCESSING FOR RAW SIGNAL
                    echoCancellation: { exact: false },
                    noiseSuppression: { exact: false },
                    autoGainControl: { exact: false }
                }
            });
            
            APP.inputDevices.stream = stream;
            APP.inputDevices.selectedId = deviceId;
            
            // Create high-quality AudioContext at 48kHz
            if (!APP.audio.ctx || APP.audio.ctx.sampleRate !== 48000) {
                APP.audio.ctx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
            }
            
            const source = APP.audio.ctx.createMediaStreamSource(stream);
            APP.inputDevices.analyzer = APP.audio.ctx.createAnalyser();
            APP.inputDevices.analyzer.fftSize = 512; // Higher resolution
            APP.inputDevices.analyzer.smoothingTimeConstant = 0.3;
            source.connect(APP.inputDevices.analyzer);
            
            // Start input level monitoring with seismic
            monitorInputLevel();
            
            log('PRO_AUDIO: 48KHZ_RAW // ' + deviceId.substring(0, 8));
        } catch (e) {
            // Fallback without exact constraints
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        deviceId: { exact: deviceId },
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });
                APP.inputDevices.stream = stream;
                APP.inputDevices.selectedId = deviceId;
                
                if (!APP.audio.ctx) {
                    APP.audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                const source = APP.audio.ctx.createMediaStreamSource(stream);
                APP.inputDevices.analyzer = APP.audio.ctx.createAnalyser();
                APP.inputDevices.analyzer.fftSize = 512;
                source.connect(APP.inputDevices.analyzer);
                
                monitorInputLevel();
                log('INPUT_SWITCHED: ' + deviceId.substring(0, 8));
            } catch (e2) {
                log('INPUT_ERROR: ' + e2.message);
            }
        }
    }
    
    // SEISMIC SHAKE TRIGGER THRESHOLD
    let seismicTimeout = null;
    
    function monitorInputLevel() {
        if (!APP.inputDevices.analyzer) return;
        
        const dataArray = new Uint8Array(APP.inputDevices.analyzer.frequencyBinCount);
        const bassArray = new Uint8Array(16); // Low frequencies only
        
        function update() {
            if (!APP.inputDevices.analyzer) return;
            
            APP.inputDevices.analyzer.getByteFrequencyData(dataArray);
            
            // Overall level
            const avg = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
            const level = Math.min(100, (avg / 128) * 100);
            
            // Bass level (first 16 bins = low frequencies)
            for (let i = 0; i < 16; i++) bassArray[i] = dataArray[i];
            const bassAvg = bassArray.reduce((a, b) => a + b, 0) / bassArray.length;
            const bassLevel = Math.min(100, (bassAvg / 128) * 100);
            
            $('input-level-bar').style.width = level + '%';
            
            // SEISMIC SHAKE on loud bass or mic input
            if (bassLevel > 70 || level > 80) {
                if (!seismicTimeout) {
                    document.body.classList.add('seismic-active');
                    seismicTimeout = setTimeout(() => {
                        document.body.classList.remove('seismic-active');
                        seismicTimeout = null;
                    }, 150);
                }
            }
            
            // Voice reactivity - WHITE_FLASH
            if (APP.atmosphere.voiceReact && level > 60) {
                document.body.classList.add('voice-flash');
                setTimeout(() => document.body.classList.remove('voice-flash'), 80);
                
                // Speed up trasudate drops on high volume
                if (APP.trasudate.active && APP.trasudate.drops) {
                    APP.trasudate.drops.forEach(drop => {
                        drop.vy += 0.5;
                    });
                }
            }
            
            requestAnimationFrame(update);
        }
        update();
    }
    
    $('btn-scan-inputs').onclick = scanAudioInputDevices;
    $('audio-input-select').onchange = (e) => {
        if (e.target.value) {
            switchAudioInput(e.target.value);
        }
    };

    // ========================================
    // SATELLITE_ATMOSPHERE_ENGINE
    // GEO_HANDSHAKE + OPEN-METEO API + REFRACTIVE RAIN
    // ========================================
    
    // Initialize atmosphere canvas and refraction buffer
    function initAtmosphereCanvas() {
        APP.atmosphere.canvas = $('atmos-canvas');
        APP.atmosphere.refractionCanvas = $('refraction-buffer');
        
        if (APP.atmosphere.canvas) {
            APP.atmosphere.ctx = APP.atmosphere.canvas.getContext('2d');
            const stage = $('stage');
            APP.atmosphere.canvas.width = stage.clientWidth;
            APP.atmosphere.canvas.height = stage.clientHeight;
        }
        
        if (APP.atmosphere.refractionCanvas) {
            APP.atmosphere.refractionCtx = APP.atmosphere.refractionCanvas.getContext('2d');
            APP.atmosphere.refractionCanvas.width = APP.render.canvas.width;
            APP.atmosphere.refractionCanvas.height = APP.render.canvas.height;
        }
    }
    
    // GEO_HANDSHAKE: Get real coordinates
   async function initAtmosphere() {
    log('GEO_HANDSHAKE: ACQUIRING...');
    const geoStatus = $('geo-status');
    if (geoStatus) geoStatus.textContent = 'GEO: ACQUIRING...';
    
    return new Promise((resolve) => {
        if (!navigator.geolocation) {
            log('GEO: NOT_SUPPORTED');
            resolve(false);
            return;
        }
        
        // This triggers the real browser popup
        navigator.geolocation.getCurrentPosition(
            async (position) => {
                APP.atmosphere.latitude = position.coords.latitude;
                APP.atmosphere.longitude = position.coords.longitude;
                log(`GPS_LOCKED: ${APP.atmosphere.latitude.toFixed(2)}`);
                await fetchSatelliteWeather();
                resolve(true);
            },
            async (error) => {
                log('GPS_DENIED: FALLBACK_ENGAGED');
                // Use the IP lookup ONLY if the user said NO to GPS
                try {
                    const res = await fetch('https://ipapi.co/json/');
                    const data = await res.json();
                    APP.atmosphere.latitude = data.latitude;
                    APP.atmosphere.longitude = data.longitude;
                    APP.atmosphere.city = data.city.toUpperCase();
                    await fetchSatelliteWeather();
                } catch (e) {
                    APP.atmosphere.latitude = 52.52; // Absolute backup
                    APP.atmosphere.longitude = 13.41;
                    await fetchSatelliteWeather();
                }
                resolve(false);
            },
            { enableHighAccuracy: true, timeout: 8000 }
        );
    });
}
    
    // Fetch weather from Open-Meteo with reverse geocoding
    async function fetchSatelliteWeather() {
        try {
            const lat = APP.atmosphere.latitude || 52.52;
            const lon = APP.atmosphere.longitude || 13.41;
            
            // Weather data
            const weatherResp = await fetch(
                `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=weathercode`
            );
            const weather = await weatherResp.json();
            
            const temp = weather.current_weather.temperature;
            const weatherCode = weather.current_weather.weathercode;
            const windSpeed = weather.current_weather.windspeed;
            
            APP.atmosphere.temperature = temp;
            APP.atmosphere.weatherCode = weatherCode;
            
            // Weather code interpretation
            const weatherMap = {
                0: 'CLEAR', 1: 'MAINLY_CLEAR', 2: 'PARTLY_CLOUDY', 3: 'OVERCAST',
                45: 'FOG', 48: 'RIME_FOG',
                51: 'LIGHT_DRIZZLE', 53: 'DRIZZLE', 55: 'DENSE_DRIZZLE',
                61: 'LIGHT_RAIN', 63: 'RAIN', 65: 'HEAVY_RAIN',
                71: 'LIGHT_SNOW', 73: 'SNOW', 75: 'HEAVY_SNOW',
                80: 'LIGHT_SHOWERS', 81: 'SHOWERS', 82: 'VIOLENT_SHOWERS',
                95: 'THUNDERSTORM', 96: 'HAIL_STORM', 99: 'HEAVY_HAIL'
            };
            
            const condition = weatherMap[weatherCode] || 'UNKNOWN';
            APP.atmosphere.metar = `${temp}C // ${condition} // ${windSpeed}KMH`;
            
            // Check if raining
            APP.atmosphere.isRaining = [51, 53, 55, 61, 63, 65, 80, 81, 82, 95, 96, 99].includes(weatherCode);
            
            // Reverse geocoding for city name
            try {
                const geoResp = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json`
                );
                const geo = await geoResp.json();
                APP.atmosphere.city = (geo.address?.city || geo.address?.town || geo.address?.village || 'UNKNOWN').toUpperCase();
                APP.atmosphere.country = (geo.address?.country_code || '').toUpperCase();
            } catch (e) {
                APP.atmosphere.city = 'UNKNOWN';
            }
            
            // Update geo status
            const geoStatus = $('geo-status');
            if (geoStatus) geoStatus.textContent = `GEO: ${APP.atmosphere.city} [${APP.atmosphere.country}]`;
            
            // Update ticker with METAR data
            updateTickerWithMetar();
            
            // ========================================
            // AUTO-WEATHER TRIGGER: Geolocation -> Satellite -> Trasudate
            // This bridges the satellite data to the rain engine
            // ========================================
            processWeatherCondition(weatherCode, condition);
            
            log(`SATELLITE: [${APP.atmosphere.city}] ${APP.atmosphere.metar}`);
            
        } catch (e) {
            log('SATELLITE_ERROR: ' + e.message);
            const weatherStatus = $('weather-status');
            if (weatherStatus) weatherStatus.textContent = 'WEATHER: ERROR';
        }
    }
    
    // Update bottom ticker with location and METAR
  function updateTickerWithMetar() {
    const ticker = $('ticker-text');
    if (ticker && APP.atmosphere.city) {
        // This line forces the ticker to use the ACTUAL data fetched from the API
        const city = APP.atmosphere.city;
        const temp = APP.atmosphere.temperature;
        const status = APP.atmosphere.isRaining ? "PRECIPITATION_DETECTED" : "ATMOS_STABLE";
        
        ticker.innerHTML = `[LOC: ${city}] // [TEMP: ${temp}°C] // [SYSTEM: ${status}] // [SAT_LINK: 100%]`;
        
        // This is the "Truth" log
        log(`REAL_TIME_SYNC: ${city} @ ${temp}°C`);
    }
}
    
    // Initialize refraction buffer for displacement mapping
    function initRefractionBuffer() {
        if (!APP.atmosphere.refractionCanvas) {
            APP.atmosphere.refractionCanvas = $('refraction-buffer');
            if (APP.atmosphere.refractionCanvas) {
                APP.atmosphere.refractionCtx = APP.atmosphere.refractionCanvas.getContext('2d');
                const stage = $('stage');
                APP.atmosphere.refractionCanvas.width = stage.clientWidth;
                APP.atmosphere.refractionCanvas.height = stage.clientHeight;
            }
        }
        $('refraction-buffer').classList.add('active');
    }
    
    // CLEAN RAIN DROP - realistic stutter-and-slide physics
    function createRefractiveRainDrop() {
        if (!APP.atmosphere.ctx) return;
        
        const canvas = APP.atmosphere.canvas;
        const intensity = APP.atmosphere.intensity || 50;
        const drop = {
            x: Math.random() * canvas.width,
            y: -30,
            length: 15 + Math.random() * 25,
            speed: 8 + Math.random() * 12 + (intensity / 10),
            opacity: 0.3 + Math.random() * 0.4,
            // Stutter-and-slide physics
            velocity: 0,
            gravity: 0.6 + Math.random() * 0.4,
            stutter: Math.random() < 0.2,
            stutterCounter: 0,
            maxStutter: 3 + Math.floor(Math.random() * 6),
            refractIndex: 1.15 + Math.random() * 0.2
        };
        APP.atmosphere.rainDrops.push(drop);
    }
    
    // Render CLEAN realistic rain - no psychedelic colors
    function renderRefractiveRain() {
        if (!APP.atmosphere.ctx || !APP.trasudate.active) return;
        
        const ctx = APP.atmosphere.ctx;
        const canvas = APP.atmosphere.canvas;
        const vjCanvas = APP.render.canvas;
        const intensity = APP.atmosphere.intensity || 50;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Create new drops based on intensity
        const spawnRate = intensity / 30;
        if (Math.random() < spawnRate) {
            createRefractiveRainDrop();
        }
        
        // Update and draw drops with stutter-and-slide physics
        APP.atmosphere.rainDrops = APP.atmosphere.rainDrops.filter(drop => {
            // Stutter-and-slide gravity
            if (drop.stutter && drop.stutterCounter < drop.maxStutter) {
                drop.stutterCounter++;
                drop.velocity *= 0.4;
            } else {
                drop.velocity += drop.gravity;
                drop.stutter = Math.random() < 0.03;
                drop.stutterCounter = 0;
            }
            
            drop.y += drop.velocity;
            
            // Draw CLEAN rain drop - realistic blue/white gradient
            const gradient = ctx.createLinearGradient(drop.x, drop.y, drop.x, drop.y + drop.length);
            gradient.addColorStop(0, 'transparent');
            gradient.addColorStop(0.2, `rgba(200, 220, 255, ${drop.opacity * 0.3})`);
            gradient.addColorStop(0.5, `rgba(180, 200, 240, ${drop.opacity * 0.6})`);
            gradient.addColorStop(0.8, `rgba(160, 180, 220, ${drop.opacity * 0.4})`);
            gradient.addColorStop(1, 'transparent');
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(drop.x, drop.y);
            ctx.lineTo(drop.x, drop.y + drop.length);
            ctx.stroke();
            
            // Subtle magnification effect
            if (APP.atmosphere.refractionCtx && vjCanvas) {
                try {
                    const scale = drop.refractIndex;
                    const sourceX = (drop.x / canvas.width) * vjCanvas.width;
                    const sourceY = (drop.y / canvas.height) * vjCanvas.height;
                    const sourceW = 15;
                    const sourceH = drop.length * 1.5;
                    
                    APP.atmosphere.refractionCtx.globalAlpha = 0.08;
                    APP.atmosphere.refractionCtx.drawImage(
                        vjCanvas,
                        sourceX - sourceW/2, sourceY - sourceH/2, sourceW, sourceH,
                        drop.x - sourceW*scale/2, drop.y - sourceH*scale/2, sourceW * scale, sourceH * scale
                    );
                    APP.atmosphere.refractionCtx.globalAlpha = 1;
                } catch (e) { /* ignore */ }
            }
            
            return drop.y < canvas.height + 50;
        });
        
        if (APP.trasudate.active) {
            requestAnimationFrame(renderRefractiveRain);
        }
    }
    
    // ========================================
    // GEOLOCATION -> SATELLITE -> TRASUDATE
    // Auto-weather integration (no manual buttons)
    // ========================================
    
    // Update weather UI status displays
    function updateWeatherUI(condition, isRaining) {
        const weatherStatus = $('weather-status');
        const rainStatus = $('rain-status');
        const atmosDot = $('atmos-dot');
        
        if (weatherStatus) weatherStatus.textContent = 'WEATHER: ' + condition.toUpperCase();
        
        if (rainStatus) {
            if (isRaining) {
                rainStatus.textContent = 'RAIN: AUTO_ENABLED';
                rainStatus.style.color = 'var(--c)';
            } else {
                rainStatus.textContent = 'RAIN: AUTO_DISABLED';
                rainStatus.style.color = 'var(--text-dim)';
            }
        }
        
        if (atmosDot) atmosDot.classList.toggle('off', !isRaining);
    }
    
    // Enable rain automatically based on satellite weather
    function enableRainAuto() {
        if (!APP.trasudate.active) {
            APP.trasudate.active = true;
            initTrasudateEngine();
            initAtmosphereCanvas();
            initRefractionBuffer();
            renderRefractiveRain();
            log('WEATHER_AUTO: RAIN_ENABLED');
        }
    }
    
    // Disable rain automatically
    function disableRainAuto() {
        if (APP.trasudate.active) {
            APP.trasudate.active = false;
            stopTrasudateEngine();
            APP.atmosphere.rainDrops = [];
            if (APP.atmosphere.ctx) {
                APP.atmosphere.ctx.clearRect(0, 0, APP.atmosphere.canvas.width, APP.atmosphere.canvas.height);
            }
            log('WEATHER_AUTO: RAIN_DISABLED');
        }
    }
    
    // Parse weather condition and trigger visual effects automatically
    function processWeatherCondition(weatherCode, condition) {
        // Weather codes: 51,53,55 = drizzle, 61,63,65 = rain, 80,81,82 = showers, 95,96,99 = thunderstorm
        const rainCodes = [51, 53, 55, 61, 63, 65, 80, 81, 82, 95, 96, 99];
        const isRaining = rainCodes.includes(weatherCode);
        const temp = APP.atmosphere.temperature || 20;
        const isHot = temp > 30;
        
        updateWeatherUI(condition, isRaining);
        
        // AUTO LENS DRIP - Rain triggers water droplet effect
        if (isRaining) {
            enableRainAuto();
            activateLensDrip(true);
            if ($('weather-fx')) $('weather-fx').textContent = 'FX: LENS_DRIP (RAIN)';
        } else {
            disableRainAuto();
            activateLensDrip(false);
        }
        
        // AUTO HEAT HAZE - Hot weather (>30C) triggers distortion
        if (isHot && !isRaining) {
            activateHeatHaze(true);
            if ($('weather-fx')) $('weather-fx').textContent = 'FX: HEAT_HAZE (' + temp + 'C)';
        } else if (!isRaining) {
            activateHeatHaze(false);
            if ($('weather-fx')) $('weather-fx').textContent = 'FX: NONE';
        }
    }
    
    // LENS DRIP EFFECT - Water droplets on lens during rain
    function activateLensDrip(active) {
        const canvas = $('lens-drip-canvas');
        if (!canvas) return;
        
        APP.shaders.lensDrip.active = active;
        canvas.classList.toggle('active', active);
        
        if (active && !APP.shaders.lensDrip.rafId) {
            animateLensDrip();
        }
    }
    
    function animateLensDrip() {
        if (!APP.shaders.lensDrip.active) {
            APP.shaders.lensDrip.rafId = null;
            return;
        }
        
        const canvas = $('lens-drip-canvas');
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        
        const stage = $('stage');
        if (stage) {
            canvas.width = stage.clientWidth;
            canvas.height = stage.clientHeight;
        }
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const time = APP.shaders.lensDrip.time++;
        const intensity = (APP.atmosphere.intensity || 50) / 100;
        
        // Draw water droplets
        for (let i = 0; i < Math.floor(20 * intensity); i++) {
            const x = (Math.sin(time * 0.01 + i * 1.7) * 0.4 + 0.5) * canvas.width;
            const y = ((time * 2 + i * 70) % (canvas.height + 120)) - 60;
            const size = 12 + Math.sin(i * 0.8) * 6;
            
            // Droplet with refraction
            const gradient = ctx.createRadialGradient(x, y, 0, x, y + size * 0.2, size);
            gradient.addColorStop(0, 'rgba(220, 240, 255, 0.3)');
            gradient.addColorStop(0.5, 'rgba(200, 220, 255, 0.15)');
            gradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(x, y, size * 0.5, size, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.arc(x - size * 0.15, y - size * 0.2, size * 0.12, 0, Math.PI * 2);
            ctx.fill();
        }
        
        APP.shaders.lensDrip.rafId = requestAnimationFrame(animateLensDrip);
    }
    
    // HEAT HAZE EFFECT - Thermal distortion during hot weather
    function activateHeatHaze(active) {
        const canvas = $('heat-haze-canvas');
        if (!canvas) return;
        
        APP.shaders.heatHaze.active = active;
        canvas.classList.toggle('active', active);
        
        if (active && !APP.shaders.heatHaze.rafId) {
            animateHeatHaze();
        }
    }
    
    function animateHeatHaze() {
        if (!APP.shaders.heatHaze.active) {
            APP.shaders.heatHaze.rafId = null;
            return;
        }
        
        const canvas = $('heat-haze-canvas');
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        
        const stage = $('stage');
        if (stage) {
            canvas.width = stage.clientWidth;
            canvas.height = stage.clientHeight;
        }
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const time = APP.shaders.heatHaze.time++;
        const temp = APP.atmosphere.temperature || 25;
        const intensity = Math.min((temp - 25) / 20, 1);
        
        if (intensity <= 0) return;
        
        // Draw heat waves from bottom
        ctx.save();
        ctx.globalAlpha = 0.1 * intensity;
        
        for (let y = canvas.height; y > canvas.height * 0.4; y -= 25) {
            const waveOffset = Math.sin(time * 0.03 + y * 0.005) * 6 * intensity;
            const heatColor = `rgba(255, ${Math.floor(200 - (canvas.height - y) / canvas.height * 100)}, 80, ${0.08 * intensity})`;
            
            ctx.strokeStyle = heatColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, y);
            
            for (let x = 0; x < canvas.width; x += 12) {
                const wave = Math.sin(time * 0.04 + x * 0.012) * waveOffset;
                ctx.lineTo(x, y + wave);
            }
            ctx.stroke();
        }
        
        ctx.restore();
        APP.shaders.heatHaze.rafId = requestAnimationFrame(animateHeatHaze);
    }
    
    // Initialize shaders state
    APP.shaders = APP.shaders || {
        lensDrip: { active: false, time: 0, rafId: null },
        heatHaze: { active: false, time: 0, rafId: null }
    };
    
    // Initialize satellite atmosphere on load
    initAtmosphere();

    // ========================================
    // NFT_VAULT: SCAN WALLET ASSETS
    // ========================================
    $('btn-scan-nfts').onclick = async () => {
        if (!APP.wallet.connected || !APP.wallet.address) {
            $('nft-vault-list').innerHTML = 'CONNECT_WALLET_FIRST';
            return;
        }
        
        $('nft-vault-list').innerHTML = 'SCANNING...';
        log('NFT_VAULT: SCANNING...');
        
        try {
            // Using Alchemy API (free tier)
            // Reads key from window.VNGRD_CONFIG (injected at build/deploy time) or falls back to meta tag
            const alchemyKey = (window.VNGRD_CONFIG && window.VNGRD_CONFIG.ALCHEMY_KEY)
                || document.querySelector('meta[name="alchemy-key"]')?.content
                || 'demo';
            const resp = await fetch(`https://eth-mainnet.g.alchemy.com/nft/v2/${alchemyKey}/getNFTs?owner=${APP.wallet.address}&pageSize=10`);
            const data = await resp.json();
            
            if (data.ownedNfts && data.ownedNfts.length > 0) {
                APP.wallet.nfts = data.ownedNfts;
                $('nft-count').textContent = 'ASSETS: ' + data.totalCount;
                $('vault-dot').classList.remove('off');
                
                let html = '';
                data.ownedNfts.slice(0, 5).forEach(nft => {
                    const name = nft.title || nft.contract.name || 'UNKNOWN';
                    html += `<div style="margin:2px 0;color:var(--accent);">${name.substring(0, 20)}</div>`;
                });
                $('nft-vault-list').innerHTML = html;
                log('NFT_VAULT: ' + data.totalCount + ' ASSETS');
            } else {
                $('nft-vault-list').innerHTML = 'NO_NFTS_FOUND';
                $('nft-count').textContent = 'ASSETS: 0';
            }
        } catch (e) {
            $('nft-vault-list').innerHTML = 'SCAN_FAILED';
            log('NFT_VAULT_ERROR: ' + e.message);
        }
    };

    // ========================================
    // NEURAL_INJECT: AI IMAGE GENERATION
    // ========================================
    $('btn-generate-ai').onclick = async () => {
        const prompt = $('ai-prompt').value.trim();
        if (!prompt) {
            $('ai-status').textContent = 'ENTER_PROMPT';
            return;
        }
        
        if (APP.neural.generating) return;
        
        APP.neural.generating = true;
        $('ai-status').textContent = 'GENERATING...';
        $('ai-status').style.color = 'var(--v)';
        $('neural-dot').classList.remove('off');
        $('btn-generate-ai').classList.add('on');
        log('NEURAL: GENERATING...');
        
        try {
            // Using placeholder API - replace with actual AI image API
            // For demo, create a procedural gradient based on prompt hash
            const hash = prompt.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
            const hue1 = hash % 360;
            const hue2 = (hash * 2) % 360;
            
            // Create gradient image on canvas
            const imgCanvas = document.createElement('canvas');
            imgCanvas.width = 512;
            imgCanvas.height = 512;
            const ctx = imgCanvas.getContext('2d');
            
            const gradient = ctx.createLinearGradient(0, 0, 512, 512);
            gradient.addColorStop(0, `hsl(${hue1}, 80%, 30%)`);
            gradient.addColorStop(0.5, `hsl(${hue2}, 90%, 20%)`);
            gradient.addColorStop(1, `hsl(${(hue1 + 120) % 360}, 70%, 25%)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // Add noise pattern
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                ctx.fillStyle = `hsla(${Math.random() * 360}, 100%, 50%, ${Math.random() * 0.3})`;
                ctx.fillRect(x, y, 2, 2);
            }
            
            const imageUrl = imgCanvas.toDataURL('image/png');
            APP.neural.lastImage = imageUrl;
            
            // Apply glitch-fade to Nanoflux background
            const stage = $('stage');
            stage.style.transition = 'none';
            stage.style.filter = 'brightness(3) saturate(2)';
            
            setTimeout(() => {
                stage.style.transition = 'filter 0.5s';
                stage.style.filter = '';
                stage.style.backgroundImage = `url(${imageUrl})`;
                stage.style.backgroundSize = 'cover';
                stage.style.backgroundBlendMode = 'overlay';
            }, 100);
            
            $('ai-status').textContent = 'NANOFLUX_INJECTED';
            $('ai-status').style.color = 'var(--g)';
            log('NEURAL: NANOFLUX_INJECTED');
            
            setTimeout(() => {
                APP.neural.generating = false;
                $('btn-generate-ai').classList.remove('on');
            }, 1000);
            
        } catch (e) {
            $('ai-status').textContent = 'GENERATION_FAILED';
            $('ai-status').style.color = 'var(--r)';
            APP.neural.generating = false;
            $('btn-generate-ai').classList.remove('on');
            log('NEURAL_ERROR: ' + e.message);
        }
    };

    // --- DRAG INITIALIZATION (mid-script) ---
    makeLogSafeDraggable($('sys-log'));

    // ========================================
    // TRASUDATE_ENGINE - LIQUID_PHYSICS
    // DISPLACEMENT_MAP WARPING ENTIRE UI
    // ========================================
    
    function initTrasudateEngine() {
        const layer = $('trasudate-layer');
        const canvas = $('trasudate-canvas');
        
        if (!canvas) return;
        
        APP.trasudate.canvas = canvas;
        APP.trasudate.ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        APP.trasudate.drops = [];
        document.body.classList.add('trasudate-active');
        
        // Create initial drops
        for (let i = 0; i < 8; i++) {
            createTrasudateDrop(Math.random() * canvas.width, -50 - Math.random() * 200);
        }
        
        // Start physics loop
        APP.trasudate.rafId = requestAnimationFrame(trasudatePhysicsLoop);
        log('TRASUDATE: FLUID_DYNAMICS_ONLINE');
    }
    
    function stopTrasudateEngine() {
        if (APP.trasudate.rafId) {
            cancelAnimationFrame(APP.trasudate.rafId);
            APP.trasudate.rafId = null;
        }
        
        APP.trasudate.drops = [];
        document.body.classList.remove('trasudate-active');
        
        if (APP.trasudate.ctx) {
            APP.trasudate.ctx.clearRect(0, 0, APP.trasudate.canvas.width, APP.trasudate.canvas.height);
        }
        
        // Remove DOM drops
        const layer = $('trasudate-layer');
        layer.querySelectorAll('.trasudate-drop, .trasudate-trail').forEach(el => el.remove());
        
        log('TRASUDATE: OFFLINE');
    }
    
    function createTrasudateDrop(x, y, size = null) {
        const drop = {
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 0.5,
            vy: 0.5 + Math.random() * 1,
            size: size || 12 + Math.random() * 25,
            mass: 1,
            trail: [],
            maxTrail: 8,
            wobble: Math.random() * Math.PI * 2,
            wobbleSpeed: 0.05 + Math.random() * 0.05,
            surfaceTension: APP.trasudate.physics.surfaceTension,
            age: 0,
            element: null
        };
        
        drop.mass = drop.size / 15;
        
        // Create DOM element for visual
        const el = document.createElement('div');
        el.className = 'trasudate-drop';
        el.style.width = drop.size + 'px';
        el.style.height = drop.size * 1.2 + 'px';
        el.style.left = drop.x + 'px';
        el.style.top = drop.y + 'px';
        $('trasudate-layer').appendChild(el);
        drop.element = el;
        
        APP.trasudate.drops.push(drop);
        return drop;
    }
    
    function trasudatePhysicsLoop() {
        if (!APP.trasudate.active) return;
        
        const ctx = APP.trasudate.ctx;
        const canvas = APP.trasudate.canvas;
        const physics = APP.trasudate.physics;
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Spawn new drops occasionally
        if (APP.trasudate.drops.length < physics.maxDrops && Math.random() < 0.02) {
            createTrasudateDrop(Math.random() * canvas.width, -30);
        }
        
        // Update and render drops
        for (let i = APP.trasudate.drops.length - 1; i >= 0; i--) {
            const drop = APP.trasudate.drops[i];
            
            // Apply gravity
            drop.vy += physics.gravity * drop.mass;
            
            // Apply viscosity/drag
            drop.vx *= physics.viscosity;
            drop.vy *= physics.viscosity;
            
            // Surface tension wobble
            drop.wobble += drop.wobbleSpeed;
            const wobbleX = Math.sin(drop.wobble) * 0.3;
            drop.vx += wobbleX * drop.surfaceTension;
            
            // Update position
            drop.x += drop.vx;
            drop.y += drop.vy;
            drop.age++;
            
            // Trail
            drop.trail.push({ x: drop.x, y: drop.y });
            if (drop.trail.length > drop.maxTrail) {
                drop.trail.shift();
            }
            
            // Update DOM element
            if (drop.element) {
                drop.element.style.left = drop.x + 'px';
                drop.element.style.top = drop.y + 'px';
                drop.element.style.transform = `scaleX(${1 + drop.vx * 0.1}) scaleY(${1 + drop.vy * 0.05})`;
            }
            
            // Draw trail on canvas
            if (drop.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(drop.trail[0].x + drop.size/2, drop.trail[0].y + drop.size/2);
                for (let t = 1; t < drop.trail.length; t++) {
                    ctx.lineTo(drop.trail[t].x + drop.size/2, drop.trail[t].y + drop.size/2);
                }
                ctx.strokeStyle = `rgba(200, 220, 255, ${0.2 - physics.trailFade * drop.age})`;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            // Check for merging with other drops
            for (let j = i - 1; j >= 0; j--) {
                const other = APP.trasudate.drops[j];
                const dx = drop.x - other.x;
                const dy = drop.y - other.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < physics.mergeThreshold) {
                    // Merge drops
                    const newSize = Math.sqrt(drop.size * drop.size + other.size * other.size);
                    const newX = (drop.x * drop.mass + other.x * other.mass) / (drop.mass + other.mass);
                    const newY = (drop.y * drop.mass + other.y * other.mass) / (drop.mass + other.mass);
                    const newVx = (drop.vx * drop.mass + other.vx * other.mass) / (drop.mass + other.mass);
                    const newVy = (drop.vy * drop.mass + other.vy * other.mass) / (drop.mass + other.mass);
                    
                    // Remove old elements
                    if (drop.element) drop.element.remove();
                    if (other.element) other.element.remove();
                    
                    // Remove from array
                    APP.trasudate.drops.splice(i, 1);
                    APP.trasudate.drops.splice(j, 1);
                    
                    // Create merged drop
                    const merged = createTrasudateDrop(newX, newY, Math.min(newSize, 50));
                    merged.vx = newVx;
                    merged.vy = newVy;
                    
                    break;
                }
            }
            
            // Remove if off screen
            if (drop.y > canvas.height + 50) {
                if (drop.element) drop.element.remove();
                APP.trasudate.drops.splice(i, 1);
            }
        }
        
        APP.trasudate.rafId = requestAnimationFrame(trasudatePhysicsLoop);
    }

    // initHologram() REMOVED — single 3D engine lives in module script
    // Widget-layer is hidden by default; only the module btn-inject-3d activates it
    
    // Widget-layer wheel/drag handlers REMOVED — Touch-Bridge handles all scaling
    
    // Initialize hologram after a short delay
    setTimeout(initHologram, 500);

    // ========================================
    // WEBGL LENS DRIP SHADER
    // ========================================
    function initLensDripShader() {
        const canvas = $('lens-drip-canvas');
        if (!canvas) return;
        
        const stage = $('stage');
        canvas.width = stage.clientWidth;
        canvas.height = stage.clientHeight;
        
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) { log('WEBGL_NOT_SUPPORTED'); return; }
        
        APP.shaders.lensDrip.canvas = canvas;
        APP.shaders.lensDrip.gl = gl;
        
        // Simple drip distortion effect using 2D canvas fallback
        const ctx = canvas.getContext('2d');
        if (ctx) {
            APP.shaders.lensDrip.ctx = ctx;
        }
        
        log('LENS_DRIP_SHADER: INITIALIZED');
    }
    
    function toggleLensDrip() {
        APP.shaders.lensDrip.active = !APP.shaders.lensDrip.active;
        $('lens-drip-canvas').classList.toggle('active', APP.shaders.lensDrip.active);
        $('btn-lens-drip').classList.toggle('on', APP.shaders.lensDrip.active);
        
        if (APP.shaders.lensDrip.active) {
            initLensDripShader();
            animateLensDrip();
        } else {
            if (APP.shaders.lensDrip.rafId) cancelAnimationFrame(APP.shaders.lensDrip.rafId);
        }
        log('LENS_DRIP: ' + (APP.shaders.lensDrip.active ? 'ON' : 'OFF'));
    }
    
    function animateLensDrip() {
        if (!APP.shaders.lensDrip.active) return;
        
        const canvas = APP.shaders.lensDrip.canvas;
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw drip effect
        const time = APP.shaders.lensDrip.time++;
        const intensity = APP.atmosphere.intensity / 100;
        
        for (let i = 0; i < 10 * intensity; i++) {
            const x = Math.sin(time * 0.02 + i) * canvas.width * 0.3 + canvas.width / 2;
            const y = (time * 2 + i * 50) % (canvas.height + 100) - 50;
            const size = 20 + Math.sin(i) * 10;
            
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
            gradient.addColorStop(0, 'rgba(200, 220, 255, 0.3)');
            gradient.addColorStop(0.5, 'rgba(180, 200, 240, 0.15)');
            gradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(x, y, size * 0.6, size, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        
        APP.shaders.lensDrip.rafId = requestAnimationFrame(animateLensDrip);
    }
    
    if ($('btn-lens-drip')) {
        $('btn-lens-drip').onclick = toggleLensDrip;
    }
    
    // ========================================
    // WEBGL HEAT HAZE SHADER
    // ========================================
    function toggleHeatHaze() {
        APP.shaders.heatHaze.active = !APP.shaders.heatHaze.active;
        $('heat-haze-canvas').classList.toggle('active', APP.shaders.heatHaze.active);
        $('btn-heat-haze').classList.toggle('on', APP.shaders.heatHaze.active);
        
        if (APP.shaders.heatHaze.active) {
            initHeatHazeShader();
            animateHeatHaze();
        } else {
            if (APP.shaders.heatHaze.rafId) cancelAnimationFrame(APP.shaders.heatHaze.rafId);
        }
        log('HEAT_HAZE: ' + (APP.shaders.heatHaze.active ? 'ON' : 'OFF'));
    }
    
    function initHeatHazeShader() {
        const canvas = $('heat-haze-canvas');
        if (!canvas) return;
        
        const stage = $('stage');
        canvas.width = stage.clientWidth;
        canvas.height = stage.clientHeight;
        
        APP.shaders.heatHaze.canvas = canvas;
        log('HEAT_HAZE_SHADER: INITIALIZED');
    }
    
    function animateHeatHaze() {
        if (!APP.shaders.heatHaze.active) return;
        
        const canvas = APP.shaders.heatHaze.canvas;
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const time = APP.shaders.heatHaze.time++;
        const intensity = APP.atmosphere.heatIntensity / 100;
        
        // Draw heat distortion waves
        ctx.save();
        ctx.globalAlpha = 0.1 * intensity;
        
        for (let y = 0; y < canvas.height; y += 20) {
            const wave = Math.sin(time * 0.05 + y * 0.01) * 5 * intensity;
            ctx.strokeStyle = `rgba(255, ${200 - y/canvas.height * 100}, 100, ${0.1 * intensity})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, y);
            for (let x = 0; x < canvas.width; x += 10) {
                ctx.lineTo(x, y + Math.sin(time * 0.1 + x * 0.02) * wave);
            }
            ctx.stroke();
        }
        
        ctx.restore();
        
        APP.shaders.heatHaze.rafId = requestAnimationFrame(animateHeatHaze);
    }
    
    if ($('btn-heat-haze')) {
        $('btn-heat-haze').onclick = toggleHeatHaze;
    }
    
    // Heat intensity slider
    if ($('sl-heat')) {
        $('sl-heat').oninput = e => {
            APP.atmosphere.heatIntensity = parseInt(e.target.value);
            $('val-heat').textContent = e.target.value + '%';
        };
    }
    
    // Shatter all button
    if ($('btn-shatter-all')) {
        $('btn-shatter-all').onclick = () => {
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                if (typeof createGlassFracture === 'function') createGlassFracture(x, y);
            }
            log('SHATTER_ALL: TRIGGERED');
        };
    }
    
    // ========================================
    // CAMERA PREVIEW - FLOATING BOX
    // ========================================
    function updateCameraPreview() {
        const preview = $('cam-preview-float');
        const previewVid = $('preview-vid-float');
        
        if (APP.camera.stream && preview && previewVid) {
            previewVid.srcObject = APP.camera.stream;
            preview.classList.add('active');
            APP.camera.previewEl = previewVid;
        }
    }
    
    // Hook into camera init
    const originalInitCamera = window.initCamera;
    window.initCamera = async function() {
        if (typeof originalInitCamera === 'function') {
            await originalInitCamera();
        }
        setTimeout(updateCameraPreview, 500);
    };
    
    // ========================================
    // GEODATA TICKER INJECTION
    // ========================================
    function injectGeoToTicker() {
        const ticker = $('ticker-text');
        if (!ticker || !APP.atmosphere.city) return;
        
        const geoData = `[LOC: ${APP.atmosphere.city.toUpperCase()}] // [LAT: ${APP.atmosphere.latitude?.toFixed(2) || '?'}] // [LON: ${APP.atmosphere.longitude?.toFixed(2) || '?'}]`;
        
        // Prepend geo data to ticker
        if (!ticker.textContent.includes('[LOC:')) {
            ticker.textContent = geoData + ' // ' + ticker.textContent;
        }
    }
    
    // ========================================
    // PRO-AUDIO: SPATIAL PANNING + PITCH RANDOMIZATION
    // ========================================
    function playImpactSoundWithSpatial(x, y) {
        if (!APP.shooting.audioCtx) return;
        
        const ctx = APP.shooting.audioCtx;
        
        // Create oscillator for tink
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const panner = ctx.createStereoPanner();
        
        // PITCH RANDOMIZATION (+/- 20%)
        const basePitch = 1600;
        const pitchVariation = basePitch * 0.2 * (Math.random() * 2 - 1);
        osc.frequency.value = basePitch + pitchVariation;
        osc.type = 'square';
        
        // SPATIAL PANNING (X-axis)
        const panValue = (x / window.innerWidth) * 2 - 1; // -1 to 1
        panner.pan.value = panValue;
        
        // Volume scaled
        gain.gain.setValueAtTime(0.3, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.05);
        
        osc.connect(gain);
        gain.connect(panner);
        panner.connect(ctx.destination);
        
        osc.start();
        osc.stop(ctx.currentTime + 0.05);
    }
    
    // Override playMetalTink to use spatial panning
    const originalPlayMetalTink = window.playMetalTink;
    window.playMetalTink = function(x, y) {
        playImpactSoundWithSpatial(x || window.innerWidth/2, y || window.innerHeight/2);
    };

    // Trinity drag is now canvas-space (initTrinityDrag) — no DOM drag needed

    // KEEP THIS: Initialize geo ticker injection
    setTimeout(injectGeoToTicker, 3000);
    
    // Initialize geo ticker injection
    setTimeout(injectGeoToTicker, 3000);

}); // THIS IS THE END of the startup block. Do not put code after this line.
</script>
<script type="module">
    import * as THREE from 'three';
    import { STLLoader } from 'three/addons/loaders/STLLoader.js';
    import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // ═══ SINGLE 3D ENGINE — robust loader with auto-center/scale ═══
    // Supports OBJ, STL, GLTF/GLB. Lazy-inits scene/camera/renderer.
    // renderLoop drives rotation + render — zero rAF here.

    function ensureHologramEngine() {
        // Lazy-init: create renderer/scene/camera only once
        if (APP.hologram.renderer) return;

        const container = document.getElementById('widget-layer');
        container.innerHTML = '<canvas id="hologram-canvas"></canvas>';
        container.style.opacity = '1';
        container.style.display = 'block';

        const scene = new THREE.Scene();
        // Two-point lighting for depth on all model types
        scene.add(new THREE.AmbientLight(0xffffff, 1.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(5, 5, 5);
        scene.add(dirLight);

        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('hologram-canvas'),
            alpha: true, antialias: true,
            preserveDrawingBuffer: true
        });
        renderer.setClearColor(0x000000, 0);
        renderer.setSize(300, 300);

        APP.hologram.scene = scene;
        APP.hologram.camera = camera;
        APP.hologram.renderer = renderer;
    }

    function disposePreviousMesh() {
        if (!APP.hologram.mesh || !APP.hologram.scene) return;
        APP.hologram.scene.remove(APP.hologram.mesh);
        APP.hologram.mesh.traverse(child => {
            if (child.isMesh) {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    // Material can be array or single
                    const mats = Array.isArray(child.material) ? child.material : [child.material];
                    mats.forEach(m => m.dispose());
                }
            }
        });
        APP.hologram.mesh = null;
    }

    function centerAndScale(model) {
        // Auto-correct: center at origin, scale to fit camera view
        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z) || 1;

        // Negate the center offset so the model sits at (0,0,0)
        model.position.set(-center.x, -center.y, -center.z);

        // Scale to fit camera frustum: camera.z = 5, FOV = 75
        // Visible height at z=0 = 2 * 5 * tan(37.5°) ≈ 7.7
        // Target ~60% of visible area = ~4.6 units
        const fitScale = 4.0 / maxDim;
        model.scale.setScalar(fitScale);
    }

    function injectModel(model, fileName) {
        // Apply wireframe normal material for consistent look
        model.traverse(child => {
            if (child.isMesh) {
                child.material = new THREE.MeshNormalMaterial({ wireframe: true });
            }
        });

        centerAndScale(model);

        APP.hologram.scene.add(model);
        APP.hologram.mesh = model;
        APP.trinity.holo.visible = true;

        // One initial render so canvas isn't blank — renderLoop takes over
        APP.hologram.renderer.render(APP.hologram.scene, APP.hologram.camera);
        if (typeof log === 'function') log('3D_MODEL: ' + fileName.toUpperCase() + ' LOADED');
    }

    // ═══ THE HYBRID FERRARI (Wide Support + Visibility Fix) ═══
// ═══ 3D IGNITION: FINAL FERRARI BUILD (AUTO-CENTER & FIT) ═══
const btn = document.getElementById('btn-inject-3d');
if (btn) {
    btn.onclick = () => {
        // 1. Safety Checks: Create the Engine State if Missing
        if (!window.APP) window.APP = {};
        if (!window.APP.hologram) window.APP.hologram = { scene: null, mesh: null, camera: null };
        if (!window.APP.trinity) window.APP.trinity = { holo: { visible: false } };

        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.obj,.stl'; // Rock-solid formats only

        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            const ext = file.name.split('.').pop().toLowerCase();

            // 2. ENGINE START: Create Scene & Lights (The "Dark Room" Fix)
            if (!window.APP.hologram.scene) {
                console.log("IGNITION: FIRING_MAIN_ENGINE");
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
                camera.position.z = 5; // Standard viewing distance
                
                // Lighting: Essential for visibility
                const ambient = new THREE.AmbientLight(0xffffff, 1.5);
                const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
                dirLight.position.set(2, 5, 5);
                scene.add(ambient);
                scene.add(dirLight);

                window.APP.hologram.scene = scene;
                window.APP.hologram.camera = camera;
            }

            // 3. CLEANUP: Remove Old Mesh
            if (window.APP.hologram.mesh) {
                window.APP.hologram.scene.remove(window.APP.hologram.mesh);
                // Try to dispose memory to prevent leaks
                if (window.APP.hologram.mesh.geometry) window.APP.hologram.mesh.geometry.dispose();
                window.APP.hologram.mesh = null;
            }

            // 4. LOAD & PROCESS
            let loader = (ext === 'obj') ? new THREE.OBJLoader() : new THREE.STLLoader();

            loader.load(url, (data) => {
                // Handle different return types (Group vs Mesh)
                let model = data.scene ? data.scene : (data.isBufferGeometry ? new THREE.Mesh(data) : data);

                // A. Apply Matrix Style (Wireframe)
                model.traverse(child => {
                    if (child.isMesh) {
                        child.material = new THREE.MeshNormalMaterial({ wireframe: true });
                    }
                });

                // B. AUTO-CENTERING LOGIC (The Fix)
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                // Shift the model so its visual center is at (0,0,0)
                model.position.x += (model.position.x - center.x);
                model.position.y += (model.position.y - center.y);
                model.position.z += (model.position.z - center.z);

                // C. AUTO-SCALING LOGIC
                const maxDim = Math.max(size.x, size.y, size.z);
                const scaleFactor = 3.0 / maxDim; // 3.0 fits perfectly in z=5 camera
                model.scale.setScalar(scaleFactor);

                // 5. GO LIVE
                window.APP.hologram.scene.add(model);
                window.APP.hologram.mesh = model;
                window.APP.trinity.holo.visible = true;

                console.log(`SYSTEM: 3D_ACTOR_READY [Scale: ${scaleFactor.toFixed(2)}x]`);
            }, 
            undefined, 
            (err) => console.error("LOADER_ERROR:", err));
        };
        input.click();
    };
}
// --- AUDIO ROTATION SYSTEM ---
const V_PLAYLIST = {
    tracks: [],
    index: 0,
    player: document.getElementById('audio-el')
};

// Connect your file input to the handler
document.getElementById('file-audio').addEventListener('change', function(e) {
    handleAudioPlaylist(e.target.files);
});

// Auto-advance when song ends
V_PLAYLIST.player.addEventListener('ended', () => {
    if (V_PLAYLIST.tracks.length > 0) {
        V_PLAYLIST.index = (V_PLAYLIST.index + 1) % V_PLAYLIST.tracks.length;
        runVanguardTrack();
    }
});

function handleAudioPlaylist(files) {
    // DO NOT reset V_PLAYLIST.tracks = [] here
    const isFirstLoad = V_PLAYLIST.tracks.length === 0;

    Array.from(files).forEach(f => {
        if (f.type.startsWith('audio/')) {
            // APPEND to the existing array
            V_PLAYLIST.tracks.push(URL.createObjectURL(f));
        }
    });

    if (V_PLAYLIST.tracks.length > 0) {
        log(`QUEUE_UPDATE: ${V_PLAYLIST.tracks.length} TOTAL_TRACKS`);
        
        // Only trigger the player if nothing is playing yet
        if (isFirstLoad) {
            V_PLAYLIST.index = 0;
            runVanguardTrack();
        }
    }
}

function runVanguardTrack() {
    const url = V_PLAYLIST.tracks[V_PLAYLIST.index];
    V_PLAYLIST.player.src = url;
    V_PLAYLIST.player.play();
    
    // UPDATED: Target the audio module label instead of the bottom ticker
    const trackID = `TRACK_0${V_PLAYLIST.index + 1}`;
    const audioLabel = document.querySelector('.audio-engine .module-header') || $('audio-status');
    
    if (audioLabel) {
        audioLabel.textContent = `AUDIO_ENGINE // ${trackID}`;
    }
    
    log(`AUDIO_SYNC: ${trackID}_STARTED`);
}



// --- INTEGRATED AUDIO DUCKING & UI CONTROLS ---

// 1. SIMPLEST HIDE BUTTON
if ($('btn-3d-x')) {
    $('btn-3d-x').onclick = () => {
        // 1. Kill the Zombie Loop
        if (APP.hologram && APP.hologram.rafId) {
            cancelAnimationFrame(APP.hologram.rafId);
            APP.hologram.rafId = null;
        }

        // 2. Wipe the Canvas References
        if (APP.hologram && APP.hologram.renderer) {
            APP.hologram.renderer.dispose();
            APP.hologram.renderer.forceContextLoss();
            APP.hologram.renderer = null;
        }

        // 3. Hide the Legacy Layer
        const layer = $('widget-layer');
        if (layer) {
            layer.innerHTML = ''; // Physically removes the duplicate canvas
            layer.style.display = 'none';
        }

        // 4. Update the Trinity State
        APP.trinity.holo.visible = false;
        console.log('SYSTEM: GHOST_3D_PURGED');
    };
}

// 2. MASTER DUCKING FUNCTION
const applyAudioDuck = (isActive) => {
    // Priority: Ducking Gain Node -> Master Gain Node
    const gainNode = (APP.audio && APP.audio.duckingGain) ? APP.audio.duckingGain : (APP.audio && APP.audio.masterGain ? APP.audio.masterGain : null);
    
    if (gainNode) {
        const now = APP.audio.ctx ? APP.audio.ctx.currentTime : 0;
        const targetValue = isActive ? 0.25 : 1.0; // -12dB dip for broadcast
        
        // Professional fade (50ms) to avoid "pops" in the 15Mbps recording
        gainNode.gain.setTargetAtTime(targetValue, now, 0.05);
        console.log(isActive ? "CORE: BROADCAST_DUCKING_ON" : "CORE: BROADCAST_DUCKING_OFF");
    }
    if (typeof log === 'function') log(isActive ? 'DUCKING: ACTIVE [-12dB]' : 'DUCKING: RESTORED [0dB]');
};

// 3. EVENT INTERCEPTOR (Priority Phase)
document.addEventListener('click', (e) => {
    const btn = e.target.closest('button');
    if (!btn) return;
    
    const id = btn.id;
    if (id === 'btn-go-live') applyAudioDuck(true);
    if (id === 'btn-end' || id === 'btn-end-live' || id === 'btn-kill') applyAudioDuck(false);
}, true);

</script>
</body>
</html> 
